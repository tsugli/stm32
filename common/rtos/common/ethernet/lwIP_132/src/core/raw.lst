   1              		.code	16
   2              		.file	"raw.c"
  10              	.Ltext0:
  11              		.align	2
  12              		.global	raw_bind
  13              		.code	16
  14              		.thumb_func
  16              	raw_bind:
  17              	.LFB3:
  18              		.file 1 "rtos/common/ethernet/lwIP_132/src/core/raw.c"
   1:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /**
   2:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @file
   3:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Implementation of raw protocol PCBs for low-level handling of
   4:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * different types of protocols besides (or overriding) those
   5:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * already available in lwIP.
   6:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
   7:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
   8:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
   9:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /*
  10:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  11:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * All rights reserved.
  12:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
  13:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Redistribution and use in source and binary forms, with or without modification,
  14:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * are permitted provided that the following conditions are met:
  15:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
  16:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  17:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *    this list of conditions and the following disclaimer.
  18:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  19:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *    this list of conditions and the following disclaimer in the documentation
  20:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *    and/or other materials provided with the distribution.
  21:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * 3. The name of the author may not be used to endorse or promote products
  22:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *    derived from this software without specific prior written permission.
  23:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
  24:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
  25:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  26:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
  27:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  28:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
  29:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  30:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  31:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  32:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  33:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * OF SUCH DAMAGE.
  34:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
  35:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * This file is part of the lwIP TCP/IP stack.
  36:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
  37:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Author: Adam Dunkels <adam@sics.se>
  38:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
  39:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
  40:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
  41:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "lwip/opt.h"
  42:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
  43:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #if LWIP_RAW /* don't build if not configured for use in lwipopts.h */
  44:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
  45:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "lwip/def.h"
  46:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "lwip/memp.h"
  47:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "lwip/inet.h"
  48:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "lwip/ip_addr.h"
  49:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "lwip/netif.h"
  50:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "lwip/raw.h"
  51:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "lwip/stats.h"
  52:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "lwip/snmp.h"
  53:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include "arch/perf.h"
  54:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
  55:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #include <string.h>
  56:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
  57:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /** The list of RAW PCBs */
  58:rtos/common/ethernet/lwIP_132/src/core/raw.c **** static struct raw_pcb *raw_pcbs;
  59:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
  60:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /**
  61:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Determine if in incoming IP packet is covered by a RAW PCB
  62:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * and if so, pass it to a user-provided receive callback function.
  63:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
  64:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Given an incoming IP datagram (as a chain of pbufs) this function
  65:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * finds a corresponding RAW PCB and calls the corresponding receive
  66:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * callback function.
  67:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
  68:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param p pbuf to be demultiplexed to a RAW PCB.
  69:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param inp network interface on which the datagram was received.
  70:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @return - 1 if the packet has been eaten by a RAW PCB receive
  71:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *           callback function. The caller MAY NOT not reference the
  72:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *           packet any longer, and MAY NOT call pbuf_free().
  73:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @return - 0 if packet is not eaten (pbuf is still referenced by the
  74:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *           caller).
  75:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
  76:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
  77:rtos/common/ethernet/lwIP_132/src/core/raw.c **** u8_t
  78:rtos/common/ethernet/lwIP_132/src/core/raw.c **** raw_input(struct pbuf *p, struct netif *inp)
  79:rtos/common/ethernet/lwIP_132/src/core/raw.c **** {
  80:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   struct raw_pcb *pcb, *prev;
  81:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   struct ip_hdr *iphdr;
  82:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   s16_t proto;
  83:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   u8_t eaten = 0;
  84:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
  85:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   LWIP_UNUSED_ARG(inp);
  86:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
  87:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   iphdr = p->payload;
  88:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   proto = IPH_PROTO(iphdr);
  89:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
  90:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   prev = NULL;
  91:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   pcb = raw_pcbs;
  92:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   /* loop through all raw pcbs until the packet is eaten by one */
  93:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   /* this allows multiple pcbs to match against the packet by design */
  94:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   while ((eaten == 0) && (pcb != NULL)) {
  95:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     if (pcb->protocol == proto) {
  96:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #if IP_SOF_BROADCAST_RECV
  97:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       /* broadcast filter? */
  98:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       if ((pcb->so_options & SOF_BROADCAST) || !ip_addr_isbroadcast(&(iphdr->dest), inp))
  99:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #endif /* IP_SOF_BROADCAST_RECV */
 100:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       {
 101:rtos/common/ethernet/lwIP_132/src/core/raw.c ****         /* receive callback function available? */
 102:rtos/common/ethernet/lwIP_132/src/core/raw.c ****         if (pcb->recv != NULL) {
 103:rtos/common/ethernet/lwIP_132/src/core/raw.c ****           /* the receive callback function did not eat the packet? */
 104:rtos/common/ethernet/lwIP_132/src/core/raw.c ****           if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0) {
 105:rtos/common/ethernet/lwIP_132/src/core/raw.c ****             /* receive function ate the packet */
 106:rtos/common/ethernet/lwIP_132/src/core/raw.c ****             p = NULL;
 107:rtos/common/ethernet/lwIP_132/src/core/raw.c ****             eaten = 1;
 108:rtos/common/ethernet/lwIP_132/src/core/raw.c ****             if (prev != NULL) {
 109:rtos/common/ethernet/lwIP_132/src/core/raw.c ****             /* move the pcb to the front of raw_pcbs so that is
 110:rtos/common/ethernet/lwIP_132/src/core/raw.c ****                found faster next time */
 111:rtos/common/ethernet/lwIP_132/src/core/raw.c ****               prev->next = pcb->next;
 112:rtos/common/ethernet/lwIP_132/src/core/raw.c ****               pcb->next = raw_pcbs;
 113:rtos/common/ethernet/lwIP_132/src/core/raw.c ****               raw_pcbs = pcb;
 114:rtos/common/ethernet/lwIP_132/src/core/raw.c ****             }
 115:rtos/common/ethernet/lwIP_132/src/core/raw.c ****           }
 116:rtos/common/ethernet/lwIP_132/src/core/raw.c ****         }
 117:rtos/common/ethernet/lwIP_132/src/core/raw.c ****         /* no receive callback function was set for this raw PCB */
 118:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       }
 119:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       /* drop the packet */
 120:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     }
 121:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     prev = pcb;
 122:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     pcb = pcb->next;
 123:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   }
 124:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   return eaten;
 125:rtos/common/ethernet/lwIP_132/src/core/raw.c **** }
 126:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 127:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /**
 128:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Bind a RAW PCB.
 129:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 130:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param pcb RAW PCB to be bound with a local address ipaddr.
 131:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param ipaddr local IP address to bind with. Use IP_ADDR_ANY to
 132:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * bind to all local interfaces.
 133:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 134:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @return lwIP error code.
 135:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * - ERR_OK. Successful. No error occured.
 136:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * - ERR_USE. The specified IP address is already bound to by
 137:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * another RAW PCB.
 138:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 139:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @see raw_disconnect()
 140:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
 141:rtos/common/ethernet/lwIP_132/src/core/raw.c **** err_t
 142:rtos/common/ethernet/lwIP_132/src/core/raw.c **** raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
 143:rtos/common/ethernet/lwIP_132/src/core/raw.c **** {
  19              		.loc 1 143 0
  20              	.LVL0:
 144:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   ip_addr_set(&pcb->local_ip, ipaddr);
  21              		.loc 1 144 0
  22 0000 0029     		cmp	r1, #0
  23 0002 00D0     		beq	.L3
  24 0004 0968     		ldr	r1, [r1]
  25              	.LVL1:
  26              	.L3:
  27 0006 0160     		str	r1, [r0]
  28              	.LVL2:
 145:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   return ERR_OK;
 146:rtos/common/ethernet/lwIP_132/src/core/raw.c **** }
  29              		.loc 1 146 0
  30 0008 0020     		mov	r0, #0
  31              	.LVL3:
  32              		@ sp needed for prologue
  33 000a 7047     		bx	lr
  34              	.LFE3:
  36              		.align	2
  37              		.global	raw_connect
  38              		.code	16
  39              		.thumb_func
  41              	raw_connect:
  42              	.LFB4:
 147:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 148:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /**
 149:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Connect an RAW PCB. This function is required by upper layers
 150:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * of lwip. Using the raw api you could use raw_sendto() instead
 151:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 152:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * This will associate the RAW PCB with the remote address.
 153:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 154:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param pcb RAW PCB to be connected with remote address ipaddr and port.
 155:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param ipaddr remote IP address to connect with.
 156:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 157:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @return lwIP error code
 158:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 159:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @see raw_disconnect() and raw_sendto()
 160:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
 161:rtos/common/ethernet/lwIP_132/src/core/raw.c **** err_t
 162:rtos/common/ethernet/lwIP_132/src/core/raw.c **** raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
 163:rtos/common/ethernet/lwIP_132/src/core/raw.c **** {
  43              		.loc 1 163 0
  44              	.LVL4:
 164:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   ip_addr_set(&pcb->remote_ip, ipaddr);
  45              		.loc 1 164 0
  46 000c 0029     		cmp	r1, #0
  47 000e 00D0     		beq	.L7
  48 0010 0968     		ldr	r1, [r1]
  49              	.LVL5:
  50              	.L7:
  51 0012 4160     		str	r1, [r0, #4]
  52              	.LVL6:
 165:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   return ERR_OK;
 166:rtos/common/ethernet/lwIP_132/src/core/raw.c **** }
  53              		.loc 1 166 0
  54 0014 0020     		mov	r0, #0
  55              	.LVL7:
  56              		@ sp needed for prologue
  57 0016 7047     		bx	lr
  58              	.LFE4:
  60              		.align	2
  61              		.global	raw_recv
  62              		.code	16
  63              		.thumb_func
  65              	raw_recv:
  66              	.LFB5:
 167:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 168:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 169:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /**
 170:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Set the callback function for received packets that match the
 171:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * raw PCB's protocol and binding. 
 172:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * 
 173:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * The callback function MUST either
 174:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * - eat the packet by calling pbuf_free() and returning non-zero. The
 175:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *   packet will not be passed to other raw PCBs or other protocol layers.
 176:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * - not free the packet, and return zero. The packet will be matched
 177:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *   against further PCBs and/or forwarded to another protocol layers.
 178:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * 
 179:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @return non-zero if the packet was free()d, zero if the packet remains
 180:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * available for others.
 181:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
 182:rtos/common/ethernet/lwIP_132/src/core/raw.c **** void
 183:rtos/common/ethernet/lwIP_132/src/core/raw.c **** raw_recv(struct raw_pcb *pcb,
 184:rtos/common/ethernet/lwIP_132/src/core/raw.c ****          u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
 185:rtos/common/ethernet/lwIP_132/src/core/raw.c ****                       struct ip_addr *addr),
 186:rtos/common/ethernet/lwIP_132/src/core/raw.c ****          void *recv_arg)
 187:rtos/common/ethernet/lwIP_132/src/core/raw.c **** {
  67              		.loc 1 187 0
  68              	.LVL8:
 188:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   /* remember recv() callback and user data */
 189:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   pcb->recv = recv;
  69              		.loc 1 189 0
  70 0018 4161     		str	r1, [r0, #20]
 190:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   pcb->recv_arg = recv_arg;
  71              		.loc 1 190 0
  72 001a 8261     		str	r2, [r0, #24]
 191:rtos/common/ethernet/lwIP_132/src/core/raw.c **** }
  73              		.loc 1 191 0
  74              		@ sp needed for prologue
  75 001c 7047     		bx	lr
  76              	.LFE5:
  78 001e C046     		.align	2
  79              		.global	raw_new
  80              		.code	16
  81              		.thumb_func
  83              	raw_new:
  84              	.LFB9:
 192:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 193:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /**
 194:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Send the raw IP packet to the given address. Note that actually you cannot
 195:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * modify the IP headers (this is inconsistent with the receive callback where
 196:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * you actually get the IP headers), you can only specify the IP payload here.
 197:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * It requires some more changes in lwIP. (there will be a raw_send() function
 198:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * then.)
 199:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 200:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param pcb the raw pcb which to send
 201:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param p the IP payload to send
 202:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param ipaddr the destination address of the IP packet
 203:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 204:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
 205:rtos/common/ethernet/lwIP_132/src/core/raw.c **** err_t
 206:rtos/common/ethernet/lwIP_132/src/core/raw.c **** raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
 207:rtos/common/ethernet/lwIP_132/src/core/raw.c **** {
 208:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   err_t err;
 209:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   struct netif *netif;
 210:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   struct ip_addr *src_ip;
 211:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   struct pbuf *q; /* q will be sent down the stack */
 212:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   
 213:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
 214:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   
 215:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   /* not enough space to add an IP header to first pbuf in given p chain? */
 216:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   if (pbuf_header(p, IP_HLEN)) {
 217:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* allocate header in new pbuf */
 218:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
 219:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* new header pbuf could not be allocated? */
 220:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     if (q == NULL) {
 221:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allo
 222:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       return ERR_MEM;
 223:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     }
 224:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* chain header q in front of given pbuf p */
 225:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     pbuf_chain(q, p);
 226:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* { first pbuf q points to header pbuf } */
 227:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (
 228:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   }  else {
 229:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* first pbuf q equals given pbuf */
 230:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     q = p;
 231:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     if(pbuf_header(q, -IP_HLEN)) {
 232:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       LWIP_ASSERT("Can't restore header we just removed!", 0);
 233:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       return ERR_MEM;
 234:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     }
 235:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   }
 236:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 237:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   if ((netif = ip_route(ipaddr)) == NULL) {
 238:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr
 239:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* free any temporary header pbuf allocated by pbuf_header() */
 240:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     if (q != p) {
 241:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       pbuf_free(q);
 242:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     }
 243:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     return ERR_RTE;
 244:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   }
 245:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 246:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #if IP_SOF_BROADCAST
 247:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   /* broadcast filter? */
 248:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   if ( ((pcb->so_options & SOF_BROADCAST) == 0) && ip_addr_isbroadcast(ipaddr, netif) ) {
 249:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: SOF_BROADCAST not enabled on pcb 
 250:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* free any temporary header pbuf allocated by pbuf_header() */
 251:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     if (q != p) {
 252:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       pbuf_free(q);
 253:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     }
 254:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     return ERR_VAL;
 255:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   }
 256:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #endif /* IP_SOF_BROADCAST */
 257:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 258:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   if (ip_addr_isany(&pcb->local_ip)) {
 259:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* use outgoing network interface IP address as source address */
 260:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     src_ip = &(netif->ip_addr);
 261:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   } else {
 262:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* use RAW PCB local IP address as source address */
 263:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     src_ip = &(pcb->local_ip);
 264:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   }
 265:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 266:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #if LWIP_NETIF_HWADDRHINT
 267:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   netif->addr_hint = &(pcb->addr_hint);
 268:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #endif /* LWIP_NETIF_HWADDRHINT*/
 269:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
 270:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #if LWIP_NETIF_HWADDRHINT
 271:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   netif->addr_hint = NULL;
 272:rtos/common/ethernet/lwIP_132/src/core/raw.c **** #endif /* LWIP_NETIF_HWADDRHINT*/
 273:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 274:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   /* did we chain a header earlier? */
 275:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   if (q != p) {
 276:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* free the header */
 277:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     pbuf_free(q);
 278:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   }
 279:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   return err;
 280:rtos/common/ethernet/lwIP_132/src/core/raw.c **** }
 281:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 282:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /**
 283:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Send the raw IP packet to the address given by raw_connect()
 284:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 285:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param pcb the raw pcb which to send
 286:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param p the IP payload to send
 287:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 288:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
 289:rtos/common/ethernet/lwIP_132/src/core/raw.c **** err_t
 290:rtos/common/ethernet/lwIP_132/src/core/raw.c **** raw_send(struct raw_pcb *pcb, struct pbuf *p)
 291:rtos/common/ethernet/lwIP_132/src/core/raw.c **** {
 292:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   return raw_sendto(pcb, p, &pcb->remote_ip);
 293:rtos/common/ethernet/lwIP_132/src/core/raw.c **** }
 294:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 295:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /**
 296:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Remove an RAW PCB.
 297:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 298:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param pcb RAW PCB to be removed. The PCB is removed from the list of
 299:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * RAW PCB's and the data structure is freed from memory.
 300:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 301:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @see raw_new()
 302:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
 303:rtos/common/ethernet/lwIP_132/src/core/raw.c **** void
 304:rtos/common/ethernet/lwIP_132/src/core/raw.c **** raw_remove(struct raw_pcb *pcb)
 305:rtos/common/ethernet/lwIP_132/src/core/raw.c **** {
 306:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   struct raw_pcb *pcb2;
 307:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   /* pcb to be removed is first in list? */
 308:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   if (raw_pcbs == pcb) {
 309:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* make list start at 2nd pcb */
 310:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     raw_pcbs = raw_pcbs->next;
 311:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* pcb not 1st in list */
 312:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   } else {
 313:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 314:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       /* find pcb in raw_pcbs list */
 315:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       if (pcb2->next != NULL && pcb2->next == pcb) {
 316:rtos/common/ethernet/lwIP_132/src/core/raw.c ****         /* remove pcb from list */
 317:rtos/common/ethernet/lwIP_132/src/core/raw.c ****         pcb2->next = pcb->next;
 318:rtos/common/ethernet/lwIP_132/src/core/raw.c ****       }
 319:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     }
 320:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   }
 321:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   memp_free(MEMP_RAW_PCB, pcb);
 322:rtos/common/ethernet/lwIP_132/src/core/raw.c **** }
 323:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 324:rtos/common/ethernet/lwIP_132/src/core/raw.c **** /**
 325:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * Create a RAW PCB.
 326:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 327:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @return The RAW PCB which was created. NULL if the PCB data structure
 328:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * could not be allocated.
 329:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 330:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 331:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  *
 332:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  * @see raw_remove()
 333:rtos/common/ethernet/lwIP_132/src/core/raw.c ****  */
 334:rtos/common/ethernet/lwIP_132/src/core/raw.c **** struct raw_pcb *
 335:rtos/common/ethernet/lwIP_132/src/core/raw.c **** raw_new(u8_t proto) {
  85              		.loc 1 335 0
  86 0020 10B5     		push	{r4, lr}
  87              	.LCFI0:
  88              	.LVL9:
  89 0022 0006     		lsl	r0, r0, #24
  90              	.LVL10:
  91 0024 040E     		lsr	r4, r0, #24
  92              	.LVL11:
 336:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   struct raw_pcb *pcb;
 337:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 338:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));
 339:rtos/common/ethernet/lwIP_132/src/core/raw.c **** 
 340:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   pcb = memp_malloc(MEMP_RAW_PCB);
  93              		.loc 1 340 0
  94 0026 0020     		mov	r0, #0
  95 0028 FFF7FEFF 		bl	memp_malloc
 341:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   /* could allocate RAW PCB? */
 342:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   if (pcb != NULL) {
  96              		.loc 1 342 0
  97 002c 0028     		cmp	r0, #0
  98 002e 10D0     		beq	.L12
  99              	.LVL12:
 343:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     /* initialize PCB to all zeroes */
 344:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     memset(pcb, 0, sizeof(struct raw_pcb));
 100              		.loc 1 344 0
 101 0030 0022     		mov	r2, #0
 102 0032 031C     		mov	r3, r0
 103 0034 04C3     		stmia	r3!, {r2}
 104 0036 04C3     		stmia	r3!, {r2}
 105 0038 04C3     		stmia	r3!, {r2}
 106 003a 04C3     		stmia	r3!, {r2}
 107 003c 04C3     		stmia	r3!, {r2}
 108 003e 04C3     		stmia	r3!, {r2}
 109 0040 1A60     		str	r2, [r3]
 345:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     pcb->protocol = proto;
 110              		.loc 1 345 0
 111 0042 0474     		strb	r4, [r0, #16]
 346:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     pcb->ttl = RAW_TTL;
 112              		.loc 1 346 0
 113 0044 0123     		mov	r3, #1
 114 0046 5B42     		neg	r3, r3
 115 0048 C372     		strb	r3, [r0, #11]
 347:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     pcb->next = raw_pcbs;
 116              		.loc 1 347 0
 117 004a 034A     		ldr	r2, .L14
 118 004c 1368     		ldr	r3, [r2]
 119 004e C360     		str	r3, [r0, #12]
 348:rtos/common/ethernet/lwIP_132/src/core/raw.c ****     raw_pcbs = pcb;
 120              		.loc 1 348 0
 121 0050 1060     		str	r0, [r2]
 122              	.L12:
 123              	.LVL13:
 349:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   }
 350:rtos/common/ethernet/lwIP_132/src/core/raw.c ****   return pcb;
 351:rtos/common/ethernet/lwIP_132/src/core/raw.c **** }
 124              		.loc 1 351 0
 125              		@ sp needed for prologue
 126              	.LVL14:
 127 0052 10BC     		pop	{r4}
 128 0054 02BC     		pop	{r1}
 129 0056 0847     		bx	r1
 130              	.L15:
 131              		.align	2
 132              	.L14:
 133 0058 00000000 		.word	raw_pcbs
 134              	.LFE9:
 136              		.align	2
 137              		.global	raw_remove
 138              		.code	16
 139              		.thumb_func
 141              	raw_remove:
 142              	.LFB8:
 143              		.loc 1 305 0
 144 005c 00B5     		push	{lr}
 145              	.LCFI1:
 146              	.LVL15:
 147 005e 011C     		mov	r1, r0
 148              		.loc 1 308 0
 149 0060 0C4B     		ldr	r3, .L23
 150 0062 1B68     		ldr	r3, [r3]
 151              	.LVL16:
 152 0064 8B42     		cmp	r3, r1
 153 0066 02D0     		beq	.L17
 154              	.LVL17:
 155              		.loc 1 313 0
 156 0068 002B     		cmp	r3, #0
 157 006a 05D1     		bne	.L22
 158 006c 0DE0     		b	.L19
 159              	.L17:
 160              		.loc 1 310 0
 161 006e 094A     		ldr	r2, .L23
 162 0070 DB68     		ldr	r3, [r3, #12]
 163              	.LVL18:
 164 0072 1360     		str	r3, [r2]
 165 0074 09E0     		b	.L19
 166              	.LVL19:
 167              	.L20:
 168 0076 131C     		mov	r3, r2
 169              	.LVL20:
 170              	.L22:
 171              		.loc 1 315 0
 172 0078 DA68     		ldr	r2, [r3, #12]
 173              	.LVL21:
 174 007a 002A     		cmp	r2, #0
 175 007c 05D0     		beq	.L19
 176 007e 9142     		cmp	r1, r2
 177 0080 F9D1     		bne	.L20
 178              		.loc 1 317 0
 179 0082 CA68     		ldr	r2, [r1, #12]
 180 0084 DA60     		str	r2, [r3, #12]
 181              		.loc 1 313 0
 182 0086 002A     		cmp	r2, #0
 183 0088 F5D1     		bne	.L20
 184              	.L19:
 185              		.loc 1 321 0
 186 008a 0020     		mov	r0, #0
 187 008c FFF7FEFF 		bl	memp_free
 188              	.LVL22:
 189              		.loc 1 322 0
 190              		@ sp needed for prologue
 191 0090 01BC     		pop	{r0}
 192 0092 0047     		bx	r0
 193              	.L24:
 194              		.align	2
 195              	.L23:
 196 0094 00000000 		.word	raw_pcbs
 197              	.LFE8:
 199              		.align	2
 200              		.global	raw_sendto
 201              		.code	16
 202              		.thumb_func
 204              	raw_sendto:
 205              	.LFB6:
 206              		.loc 1 207 0
 207 0098 F0B5     		push	{r4, r5, r6, r7, lr}
 208              	.LCFI2:
 209              	.LVL23:
 210 009a 83B0     		sub	sp, sp, #12
 211              	.LCFI3:
 212 009c 041C     		mov	r4, r0
 213 009e 0E1C     		mov	r6, r1
 214 00a0 171C     		mov	r7, r2
 215              		.loc 1 216 0
 216 00a2 081C     		mov	r0, r1
 217              	.LVL24:
 218 00a4 1421     		mov	r1, #20
 219              	.LVL25:
 220 00a6 FFF7FEFF 		bl	pbuf_header
 221              	.LVL26:
 222 00aa 0028     		cmp	r0, #0
 223 00ac 0BD0     		beq	.L26
 224              		.loc 1 218 0
 225 00ae 0120     		mov	r0, #1
 226 00b0 0021     		mov	r1, #0
 227 00b2 0022     		mov	r2, #0
 228 00b4 FFF7FEFF 		bl	pbuf_alloc
 229 00b8 051C     		mov	r5, r0
 230              	.LVL27:
 231              		.loc 1 220 0
 232 00ba 0028     		cmp	r0, #0
 233 00bc 32D0     		beq	.L27
 234              	.LVL28:
 235              		.loc 1 225 0
 236 00be 311C     		mov	r1, r6
 237 00c0 FFF7FEFF 		bl	pbuf_chain
 238              	.LVL29:
 239 00c4 07E0     		b	.L28
 240              	.LVL30:
 241              	.L26:
 242              		.loc 1 231 0
 243 00c6 1421     		mov	r1, #20
 244 00c8 4942     		neg	r1, r1
 245 00ca 301C     		mov	r0, r6
 246 00cc FFF7FEFF 		bl	pbuf_header
 247 00d0 0028     		cmp	r0, #0
 248 00d2 27D1     		bne	.L27
 249 00d4 351C     		mov	r5, r6
 250              	.LVL31:
 251              	.L28:
 252              		.loc 1 237 0
 253 00d6 381C     		mov	r0, r7
 254 00d8 FFF7FEFF 		bl	ip_route
 255 00dc 0028     		cmp	r0, #0
 256 00de 08D1     		bne	.L29
 257              	.LVL32:
 258              		.loc 1 240 0
 259 00e0 B542     		cmp	r5, r6
 260 00e2 01D1     		bne	.L30
 261 00e4 FC24     		mov	r4, #252
 262              	.LVL33:
 263 00e6 1EE0     		b	.L31
 264              	.LVL34:
 265              	.L30:
 266              		.loc 1 241 0
 267 00e8 281C     		mov	r0, r5
 268              	.LVL35:
 269 00ea FFF7FEFF 		bl	pbuf_free
 270 00ee FC24     		mov	r4, #252
 271              	.LVL36:
 272 00f0 19E0     		b	.L31
 273              	.LVL37:
 274              	.L29:
 275              		.loc 1 258 0
 276 00f2 211C     		mov	r1, r4
 277              	.LVL38:
 278 00f4 002C     		cmp	r4, #0
 279 00f6 02D0     		beq	.L32
 280 00f8 2368     		ldr	r3, [r4]
 281 00fa 002B     		cmp	r3, #0
 282 00fc 00D1     		bne	.L33
 283              	.L32:
 284              		.loc 1 260 0
 285 00fe 011D     		add	r1, r0, #4
 286              	.L33:
 287              		.loc 1 269 0
 288 0100 E37A     		ldrb	r3, [r4, #11]
 289 0102 A27A     		ldrb	r2, [r4, #10]
 290 0104 0092     		str	r2, [sp]
 291 0106 227C     		ldrb	r2, [r4, #16]
 292 0108 0192     		str	r2, [sp, #4]
 293 010a 0290     		str	r0, [sp, #8]
 294 010c 281C     		mov	r0, r5
 295              	.LVL39:
 296 010e 3A1C     		mov	r2, r7
 297 0110 FFF7FEFF 		bl	ip_output_if
 298              	.LVL40:
 299 0114 0006     		lsl	r0, r0, #24
 300 0116 040E     		lsr	r4, r0, #24
 301              	.LVL41:
 302              		.loc 1 275 0
 303 0118 B542     		cmp	r5, r6
 304 011a 04D0     		beq	.L31
 305              		.loc 1 277 0
 306 011c 281C     		mov	r0, r5
 307 011e FFF7FEFF 		bl	pbuf_free
 308 0122 00E0     		b	.L31
 309              	.LVL42:
 310              	.L27:
 311 0124 FF24     		mov	r4, #255
 312              	.LVL43:
 313              	.L31:
 314 0126 2006     		lsl	r0, r4, #24
 315              	.LVL44:
 316 0128 0016     		asr	r0, r0, #24
 317              		.loc 1 280 0
 318 012a 03B0     		add	sp, sp, #12
 319              		@ sp needed for prologue
 320              	.LVL45:
 321              	.LVL46:
 322              	.LVL47:
 323              	.LVL48:
 324 012c F0BC     		pop	{r4, r5, r6, r7}
 325 012e 02BC     		pop	{r1}
 326 0130 0847     		bx	r1
 327              	.LFE6:
 329 0132 C046     		.align	2
 330              		.global	raw_send
 331              		.code	16
 332              		.thumb_func
 334              	raw_send:
 335              	.LFB7:
 336              		.loc 1 291 0
 337 0134 00B5     		push	{lr}
 338              	.LCFI4:
 339              	.LVL49:
 340              		.loc 1 292 0
 341 0136 021D     		add	r2, r0, #4
 342 0138 FFF7FEFF 		bl	raw_sendto
 343              	.LVL50:
 344 013c 0006     		lsl	r0, r0, #24
 345 013e 0016     		asr	r0, r0, #24
 346              		.loc 1 293 0
 347              		@ sp needed for prologue
 348 0140 02BC     		pop	{r1}
 349 0142 0847     		bx	r1
 350              	.LFE7:
 352              		.align	2
 353              		.global	raw_input
 354              		.code	16
 355              		.thumb_func
 357              	raw_input:
 358              	.LFB2:
 359              		.loc 1 79 0
 360 0144 F0B5     		push	{r4, r5, r6, r7, lr}
 361              	.LCFI5:
 362 0146 5746     		mov	r7, sl
 363 0148 4E46     		mov	r6, r9
 364 014a 4546     		mov	r5, r8
 365 014c E0B4     		push	{r5, r6, r7}
 366              	.LCFI6:
 367              	.LVL51:
 368 014e 8246     		mov	sl, r0
 369              		.loc 1 87 0
 370 0150 4568     		ldr	r5, [r0, #4]
 371              	.LVL52:
 372              		.loc 1 88 0
 373 0152 2889     		ldrh	r0, [r5, #8]
 374              	.LVL53:
 375 0154 FFF7FEFF 		bl	ntohs
 376              	.LVL54:
 377 0158 FF23     		mov	r3, #255
 378 015a 1840     		and	r0, r0, r3
 379              	.LVL55:
 380              		.loc 1 91 0
 381 015c 184B     		ldr	r3, .L44
 382 015e 1C68     		ldr	r4, [r3]
 383              	.LVL56:
 384              		.loc 1 94 0
 385 0160 002C     		cmp	r4, #0
 386 0162 24D0     		beq	.L38
 387              		.loc 1 104 0
 388 0164 0C35     		add	r5, r5, #12
 389 0166 A846     		mov	r8, r5
 390 0168 0025     		mov	r5, #0
 391              	.LVL57:
 392              		.loc 1 95 0
 393 016a 0004     		lsl	r0, r0, #16
 394              	.LVL58:
 395 016c 0714     		asr	r7, r0, #16
 396              	.LVL59:
 397              	.L42:
 398 016e 237C     		ldrb	r3, [r4, #16]
 399 0170 BB42     		cmp	r3, r7
 400 0172 16D1     		bne	.L39
 401              		.loc 1 102 0
 402 0174 6669     		ldr	r6, [r4, #20]
 403 0176 002E     		cmp	r6, #0
 404 0178 13D0     		beq	.L39
 405              		.loc 1 104 0
 406 017a A069     		ldr	r0, [r4, #24]
 407 017c 211C     		mov	r1, r4
 408 017e 5246     		mov	r2, sl
 409 0180 4346     		mov	r3, r8
 410 0182 00F01FF8 		bl	.L46
 411 0186 0028     		cmp	r0, #0
 412 0188 0BD0     		beq	.L39
 413              		.loc 1 108 0
 414 018a 002D     		cmp	r5, #0
 415 018c 01D1     		bne	.L40
 416 018e 0120     		mov	r0, #1
 417              	.LVL60:
 418 0190 0EE0     		b	.L41
 419              	.LVL61:
 420              	.L40:
 421              		.loc 1 111 0
 422 0192 E368     		ldr	r3, [r4, #12]
 423 0194 EB60     		str	r3, [r5, #12]
 424              		.loc 1 112 0
 425 0196 0A4A     		ldr	r2, .L44
 426 0198 1368     		ldr	r3, [r2]
 427 019a E360     		str	r3, [r4, #12]
 428              		.loc 1 113 0
 429 019c 1460     		str	r4, [r2]
 430 019e 0120     		mov	r0, #1
 431              	.LVL62:
 432 01a0 06E0     		b	.L41
 433              	.LVL63:
 434              	.L39:
 435              		.loc 1 122 0
 436 01a2 E368     		ldr	r3, [r4, #12]
 437              	.LVL64:
 438              		.loc 1 94 0
 439 01a4 002B     		cmp	r3, #0
 440 01a6 02D0     		beq	.L38
 441 01a8 251C     		mov	r5, r4
 442 01aa 1C1C     		mov	r4, r3
 443 01ac DFE7     		b	.L42
 444              	.LVL65:
 445              	.L38:
 446 01ae 0020     		mov	r0, #0
 447              	.LVL66:
 448              	.L41:
 449              	.LVL67:
 450              		.loc 1 125 0
 451              		@ sp needed for prologue
 452              	.LVL68:
 453              	.LVL69:
 454              	.LVL70:
 455 01b0 1CBC     		pop	{r2, r3, r4}
 456 01b2 9046     		mov	r8, r2
 457 01b4 9946     		mov	r9, r3
 458 01b6 A246     		mov	sl, r4
 459 01b8 F0BC     		pop	{r4, r5, r6, r7}
 460 01ba 02BC     		pop	{r1}
 461 01bc 0847     		bx	r1
 462              	.L45:
 463 01be C046     		.align	2
 464              	.L44:
 465 01c0 00000000 		.word	raw_pcbs
 466              	.LFE2:
 468              		.bss
 469              		.align	2
 470              	raw_pcbs:
 471 0000 00000000 		.space	4
 614              	.Letext0:
 2577              		.code 16
 2578              		.align	1
 2579              	.L46:
 2580 01c4 3047C046 		bx	r6
DEFINED SYMBOLS
                            *ABS*:00000000 raw.c
     /tmp/ccv9YB63.s:1      .text:00000000 $t
     /tmp/ccv9YB63.s:16     .text:00000000 raw_bind
     /tmp/ccv9YB63.s:41     .text:0000000c raw_connect
     /tmp/ccv9YB63.s:65     .text:00000018 raw_recv
     /tmp/ccv9YB63.s:83     .text:00000020 raw_new
     /tmp/ccv9YB63.s:133    .text:00000058 $d
     /tmp/ccv9YB63.s:470    .bss:00000000 raw_pcbs
     /tmp/ccv9YB63.s:141    .text:0000005c raw_remove
     /tmp/ccv9YB63.s:138    .text:0000005c $t
     /tmp/ccv9YB63.s:196    .text:00000094 $d
     /tmp/ccv9YB63.s:204    .text:00000098 raw_sendto
     /tmp/ccv9YB63.s:201    .text:00000098 $t
     /tmp/ccv9YB63.s:334    .text:00000134 raw_send
     /tmp/ccv9YB63.s:357    .text:00000144 raw_input
     /tmp/ccv9YB63.s:465    .text:000001c0 $d
     /tmp/ccv9YB63.s:2577   .text:000001c4 $t

UNDEFINED SYMBOLS
memp_malloc
memp_free
pbuf_header
pbuf_alloc
pbuf_chain
ip_route
pbuf_free
ip_output_if
ntohs
