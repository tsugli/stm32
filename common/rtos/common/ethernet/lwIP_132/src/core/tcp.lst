   1              		.code	16
   2              		.file	"tcp.c"
  10              	.Ltext0:
  11              		.align	2
  12              		.code	16
  13              		.thumb_func
  15              	tcp_accept_null:
  16              	.LFB294:
  17              		.file 1 "rtos/common/ethernet/lwIP_132/src/core/tcp.c"
   1:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
   2:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @file
   3:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Transmission Control Protocol for IP
   4:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
   5:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * This file contains common functions for the TCP implementation, such as functinos
   6:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * for manipulating the data structures and the TCP timer functions. TCP functions
   7:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * related to input and output is found in tcp_in.c and tcp_out.c respectively.
   8:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
   9:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
  10:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  11:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /*
  12:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
  13:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * All rights reserved. 
  14:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * 
  15:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Redistribution and use in source and binary forms, with or without modification, 
  16:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * are permitted provided that the following conditions are met:
  17:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
  18:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  19:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *    this list of conditions and the following disclaimer.
  20:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  21:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *    this list of conditions and the following disclaimer in the documentation
  22:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *    and/or other materials provided with the distribution.
  23:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * 3. The name of the author may not be used to endorse or promote products
  24:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *    derived from this software without specific prior written permission. 
  25:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
  26:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
  27:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
  28:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
  29:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
  30:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
  31:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  32:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  33:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
  34:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
  35:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * OF SUCH DAMAGE.
  36:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
  37:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * This file is part of the lwIP TCP/IP stack.
  38:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * 
  39:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Author: Adam Dunkels <adam@sics.se>
  40:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
  41:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
  42:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  43:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #include "lwip/opt.h"
  44:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  45:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
  46:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  47:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #include "lwip/def.h"
  48:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #include "lwip/mem.h"
  49:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #include "lwip/memp.h"
  50:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #include "lwip/snmp.h"
  51:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #include "lwip/tcp.h"
  52:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #include "lwip/debug.h"
  53:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #include "lwip/stats.h"
  54:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  55:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #include <string.h>
  56:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  57:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** const char *tcp_state_str[] = {
  58:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "CLOSED",      
  59:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "LISTEN",      
  60:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "SYN_SENT",    
  61:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "SYN_RCVD",    
  62:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "ESTABLISHED", 
  63:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "FIN_WAIT_1",  
  64:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "FIN_WAIT_2",  
  65:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "CLOSE_WAIT",  
  66:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "CLOSING",     
  67:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "LAST_ACK",    
  68:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   "TIME_WAIT"   
  69:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** };
  70:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  71:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /* Incremented every coarse grained timer shot (typically every 500 ms). */
  72:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** u32_t tcp_ticks;
  73:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** const u8_t tcp_backoff[13] =
  74:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     { 1, 2, 3, 4, 5, 6, 7, 7, 7, 7, 7, 7, 7};
  75:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  /* Times per slowtmr hits */
  76:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** const u8_t tcp_persist_backoff[7] = { 3, 6, 12, 24, 48, 96, 120 };
  77:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  78:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /* The TCP PCB lists. */
  79:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  80:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /** List of all TCP PCBs bound but not yet (connected || listening) */
  81:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** struct tcp_pcb *tcp_bound_pcbs;  
  82:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /** List of all TCP PCBs in LISTEN state */
  83:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** union tcp_listen_pcbs_t tcp_listen_pcbs;
  84:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /** List of all TCP PCBs that are in a state in which
  85:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * they accept or send data. */
  86:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** struct tcp_pcb *tcp_active_pcbs;  
  87:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /** List of all TCP PCBs in TIME-WAIT state */
  88:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** struct tcp_pcb *tcp_tw_pcbs;
  89:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  90:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** struct tcp_pcb *tcp_tmp_pcb;
  91:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  92:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** static u8_t tcp_timer;
  93:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** static u16_t tcp_new_port(void);
  94:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
  95:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
  96:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Called periodically to dispatch TCP timers.
  97:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
  98:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
  99:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
 100:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_tmr(void)
 101:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 102:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* Call tcp_fasttmr() every 250 ms */
 103:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   tcp_fasttmr();
 104:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 105:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (++tcp_timer & 1) {
 106:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Call tcp_tmr() every 500 ms, i.e., every other timer
 107:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        tcp_tmr() is called. */
 108:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_slowtmr();
 109:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 110:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 111:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 112:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 113:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Closes the connection held by the PCB.
 114:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 115:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Listening pcbs are freed and may not be referenced any more.
 116:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Connection pcbs are freed if not yet connected and may not be referenced
 117:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * any more. If a connection is established (at least SYN received or in
 118:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * a closing state), the connection is closed, and put in a closing state.
 119:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * The pcb is then automatically freed in tcp_slowtmr(). It is therefore
 120:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * unsafe to reference it.
 121:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 122:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb the tcp_pcb to close
 123:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return ERR_OK if connection has been closed
 124:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *         another err_t if closing failed and pcb is not freed
 125:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 126:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** err_t
 127:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_close(struct tcp_pcb *pcb)
 128:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 129:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   err_t err;
 130:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 131:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_DEBUG
 132:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
 133:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   tcp_debug_print_state(pcb->state);
 134:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_DEBUG */
 135:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 136:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   switch (pcb->state) {
 137:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   case CLOSED:
 138:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Closing a pcb in the CLOSED state might seem erroneous,
 139:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      * however, it is in this state once allocated and as yet unused
 140:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      * and the user needs some way to free it should the need arise.
 141:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
 142:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      * or for a pcb that has been used and then entered the CLOSED state 
 143:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      * is erroneous, but this should never happen as the pcb has in those cases
 144:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      * been freed, and so any remaining handles are bogus. */
 145:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     err = ERR_OK;
 146:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     TCP_RMV(&tcp_bound_pcbs, pcb);
 147:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB, pcb);
 148:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb = NULL;
 149:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     break;
 150:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   case LISTEN:
 151:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     err = ERR_OK;
 152:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
 153:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 154:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb = NULL;
 155:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     break;
 156:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   case SYN_SENT:
 157:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     err = ERR_OK;
 158:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_pcb_remove(&tcp_active_pcbs, pcb);
 159:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB, pcb);
 160:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb = NULL;
 161:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     snmp_inc_tcpattemptfails();
 162:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     break;
 163:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   case SYN_RCVD:
 164:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     err = tcp_send_ctrl(pcb, TCP_FIN);
 165:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (err == ERR_OK) {
 166:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       snmp_inc_tcpattemptfails();
 167:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb->state = FIN_WAIT_1;
 168:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 169:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     break;
 170:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   case ESTABLISHED:
 171:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     err = tcp_send_ctrl(pcb, TCP_FIN);
 172:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (err == ERR_OK) {
 173:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       snmp_inc_tcpestabresets();
 174:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb->state = FIN_WAIT_1;
 175:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 176:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     break;
 177:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   case CLOSE_WAIT:
 178:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     err = tcp_send_ctrl(pcb, TCP_FIN);
 179:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (err == ERR_OK) {
 180:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       snmp_inc_tcpestabresets();
 181:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb->state = LAST_ACK;
 182:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 183:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     break;
 184:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   default:
 185:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Has already been closed, do nothing. */
 186:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     err = ERR_OK;
 187:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb = NULL;
 188:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     break;
 189:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 190:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 191:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb != NULL && err == ERR_OK) {
 192:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* To ensure all data has been sent when tcp_close returns, we have
 193:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        to make sure tcp_output doesn't fail.
 194:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        Since we don't really have to ensure all data has been sent when tcp_close
 195:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        returns (unsent data is sent from tcp timer functions, also), we don't care
 196:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        for the return value of tcp_output for now. */
 197:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* @todo: When implementing SO_LINGER, this must be changed somehow:
 198:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        If SOF_LINGER is set, the data should be sent when tcp_close returns. */
 199:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_output(pcb);
 200:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 201:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return err;
 202:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 203:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 204:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 205:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Abandons a connection and optionally sends a RST to the remote
 206:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * host.  Deletes the local protocol control block. This is done when
 207:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * a connection is killed because of shortage of memory.
 208:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 209:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb the tcp_pcb to abort
 210:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param reset boolean to indicate whether a reset should be sent
 211:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 212:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
 213:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_abandon(struct tcp_pcb *pcb, int reset)
 214:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 215:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u32_t seqno, ackno;
 216:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u16_t remote_port, local_port;
 217:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct ip_addr remote_ip, local_ip;
 218:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_CALLBACK_API  
 219:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   void (* errf)(void *arg, err_t err);
 220:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 221:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   void *errf_arg;
 222:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 223:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
 224:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* Figure out on which TCP PCB list we are, and remove us. If we
 225:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      are in an active state, call the receive function associated with
 226:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      the PCB with a NULL argument, and send an RST to the remote end. */
 227:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb->state == TIME_WAIT) {
 228:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 229:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB, pcb);
 230:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   } else {
 231:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     seqno = pcb->snd_nxt;
 232:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     ackno = pcb->rcv_nxt;
 233:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     ip_addr_set(&local_ip, &(pcb->local_ip));
 234:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     ip_addr_set(&remote_ip, &(pcb->remote_ip));
 235:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     local_port = pcb->local_port;
 236:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     remote_port = pcb->remote_port;
 237:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_CALLBACK_API
 238:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     errf = pcb->errf;
 239:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 240:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     errf_arg = pcb->callback_arg;
 241:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_pcb_remove(&tcp_active_pcbs, pcb);
 242:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->unacked != NULL) {
 243:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       tcp_segs_free(pcb->unacked);
 244:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 245:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->unsent != NULL) {
 246:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       tcp_segs_free(pcb->unsent);
 247:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 248:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ    
 249:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->ooseq != NULL) {
 250:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       tcp_segs_free(pcb->ooseq);
 251:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 252:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_QUEUE_OOSEQ */
 253:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     memp_free(MEMP_TCP_PCB, pcb);
 254:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 255:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (reset) {
 256:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
 257:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
 258:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 259:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 260:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 261:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 262:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 263:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Binds the connection to a local portnumber and IP address. If the
 264:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * IP address is not given (i.e., ipaddr == NULL), the IP address of
 265:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * the outgoing network interface is used instead.
 266:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 267:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb the tcp_pcb to bind (no check is done whether this pcb is
 268:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *        already bound!)
 269:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param ipaddr the local ip address to bind to (use IP_ADDR_ANY to bind
 270:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *        to any local address
 271:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param port the local port to bind to
 272:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return ERR_USE if the port is already in use
 273:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *         ERR_OK if bound
 274:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 275:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** err_t
 276:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
 277:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 278:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_pcb *cpcb;
 279:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 280:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 281:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 282:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (port == 0) {
 283:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     port = tcp_new_port();
 284:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 285:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* Check if the address already is in use. */
 286:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* Check the listen pcbs. */
 287:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
 288:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       cpcb != NULL; cpcb = cpcb->next) {
 289:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (cpcb->local_port == port) {
 290:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (ip_addr_isany(&(cpcb->local_ip)) ||
 291:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           ip_addr_isany(ipaddr) ||
 292:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 293:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         return ERR_USE;
 294:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 295:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 296:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 297:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* Check the connected pcbs. */
 298:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(cpcb = tcp_active_pcbs;
 299:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       cpcb != NULL; cpcb = cpcb->next) {
 300:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (cpcb->local_port == port) {
 301:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (ip_addr_isany(&(cpcb->local_ip)) ||
 302:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           ip_addr_isany(ipaddr) ||
 303:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 304:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         return ERR_USE;
 305:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 306:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 307:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 308:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* Check the bound, not yet connected pcbs. */
 309:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 310:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (cpcb->local_port == port) {
 311:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (ip_addr_isany(&(cpcb->local_ip)) ||
 312:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           ip_addr_isany(ipaddr) ||
 313:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 314:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         return ERR_USE;
 315:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 316:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 317:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 318:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
 319:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****    * we have to check the pcbs in TIME-WAIT state, also: */
 320:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
 321:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (cpcb->local_port == port) {
 322:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 323:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         return ERR_USE;
 324:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 325:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 326:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 327:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 328:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (!ip_addr_isany(ipaddr)) {
 329:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->local_ip = *ipaddr;
 330:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 331:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->local_port = port;
 332:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   TCP_REG(&tcp_bound_pcbs, pcb);
 333:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
 334:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return ERR_OK;
 335:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 336:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_CALLBACK_API
 337:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 338:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Default accept callback if no accept callback is specified by the user.
 339:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 340:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** static err_t
 341:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
 342:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
  18              		.loc 1 342 0
  19              	.LVL0:
  20              		.loc 1 342 0
  21 0000 0520     		mov	r0, #5
  22              	.LVL1:
  23 0002 4042     		neg	r0, r0
 343:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_UNUSED_ARG(arg);
 344:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_UNUSED_ARG(pcb);
 345:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_UNUSED_ARG(err);
 346:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 347:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return ERR_ABRT;
 348:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
  24              		.loc 1 348 0
  25              		@ sp needed for prologue
  26 0004 7047     		bx	lr
  27              	.LFE294:
  29 0006 C046     		.align	2
  30              		.global	tcp_update_rcv_ann_wnd
  31              		.code	16
  32              		.thumb_func
  34              	tcp_update_rcv_ann_wnd:
  35              	.LFB296:
 349:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 350:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 351:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 352:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Set the state of the connection to be LISTEN, which means that it
 353:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * is able to accept incoming connections. The protocol control block
 354:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * is reallocated in order to consume less memory. Setting the
 355:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * connection to LISTEN is an irreversible process.
 356:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 357:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb the original tcp_pcb
 358:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param backlog the incoming connections queue limit
 359:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return tcp_pcb used for listening, consumes less memory.
 360:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 361:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @note The original tcp_pcb is freed. This function therefore has to be
 362:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *       called like this:
 363:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *             tpcb = tcp_listen(tpcb);
 364:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 365:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** struct tcp_pcb *
 366:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
 367:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 368:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_pcb_listen *lpcb;
 369:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 370:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_UNUSED_ARG(backlog);
 371:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 372:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 373:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* already listening? */
 374:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb->state == LISTEN) {
 375:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     return pcb;
 376:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 377:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
 378:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (lpcb == NULL) {
 379:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     return NULL;
 380:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 381:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->callback_arg = pcb->callback_arg;
 382:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->local_port = pcb->local_port;
 383:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->state = LISTEN;
 384:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->so_options = pcb->so_options;
 385:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->so_options |= SOF_ACCEPTCONN;
 386:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->ttl = pcb->ttl;
 387:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->tos = pcb->tos;
 388:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
 389:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   TCP_RMV(&tcp_bound_pcbs, pcb);
 390:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   memp_free(MEMP_TCP_PCB, pcb);
 391:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_CALLBACK_API
 392:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->accept = tcp_accept_null;
 393:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 394:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_LISTEN_BACKLOG
 395:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->accepts_pending = 0;
 396:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   lpcb->backlog = (backlog ? backlog : 1);
 397:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_LISTEN_BACKLOG */
 398:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
 399:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return (struct tcp_pcb *)lpcb;
 400:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 401:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 402:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /** 
 403:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Update the state that tracks the available window space to advertise.
 404:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 405:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Returns how much extra window would be advertised if we sent an
 406:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * update now.
 407:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 408:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
 409:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
  36              		.loc 1 409 0
  37 0008 70B5     		push	{r4, r5, r6, lr}
  38              	.LCFI0:
  39              	.LVL2:
 410:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
  40              		.loc 1 410 0
  41 000a 846A     		ldr	r4, [r0, #40]
  42 000c 858D     		ldrh	r5, [r0, #44]
  43 000e 2E19     		add	r6, r5, r4
  44              	.LVL3:
 411:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 412:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
  45              		.loc 1 412 0
  46 0010 016B     		ldr	r1, [r0, #48]
  47 0012 828F     		ldrh	r2, [r0, #60]
  48 0014 8023     		mov	r3, #128
  49 0016 5B00     		lsl	r3, r3, #1
  50 0018 9A42     		cmp	r2, r3
  51 001a 00D9     		bls	.L5
  52 001c 1A1C     		mov	r2, r3
  53              	.L5:
  54 001e 731A     		sub	r3, r6, r1
  55 0020 9342     		cmp	r3, r2
  56 0022 03D4     		bmi	.L6
 413:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* we can advertise more window */
 414:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->rcv_ann_wnd = pcb->rcv_wnd;
  57              		.loc 1 414 0
  58 0024 C585     		strh	r5, [r0, #46]
 415:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     return new_right_edge - pcb->rcv_ann_right_edge;
  59              		.loc 1 415 0
  60 0026 036B     		ldr	r3, [r0, #48]
  61 0028 F01A     		sub	r0, r6, r3
  62              	.LVL4:
  63 002a 09E0     		b	.L7
  64              	.LVL5:
  65              	.L6:
 416:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   } else {
 417:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
  66              		.loc 1 417 0
  67 002c 631A     		sub	r3, r4, r1
  68 002e 002B     		cmp	r3, #0
  69 0030 03DD     		ble	.L8
 418:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* Can happen due to other end sending out of advertised window,
 419:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        * but within actual available (but not yet advertised) window */
 420:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb->rcv_ann_wnd = 0;
  70              		.loc 1 420 0
  71 0032 0023     		mov	r3, #0
  72 0034 C385     		strh	r3, [r0, #46]
  73 0036 0020     		mov	r0, #0
  74              	.LVL6:
  75 0038 02E0     		b	.L7
  76              	.LVL7:
  77              	.L8:
 421:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     } else {
 422:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* keep the right edge of window constant */
 423:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb->rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
  78              		.loc 1 423 0
  79 003a 0B1B     		sub	r3, r1, r4
  80 003c C385     		strh	r3, [r0, #46]
  81 003e 0020     		mov	r0, #0
  82              	.LVL8:
  83              	.L7:
 424:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 425:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     return 0;
 426:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 427:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
  84              		.loc 1 427 0
  85              		@ sp needed for prologue
  86              	.LVL9:
  87 0040 70BC     		pop	{r4, r5, r6}
  88 0042 02BC     		pop	{r1}
  89 0044 0847     		bx	r1
  90              	.LFE296:
  92 0046 C046     		.align	2
  93              		.code	16
  94              		.thumb_func
  96              	tcp_new_port:
  97              	.LFB298:
 428:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 429:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 430:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * This function should be called by the application when it has
 431:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * processed the data. The purpose is to advertise a larger window
 432:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * when the data has been processed.
 433:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 434:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb the tcp_pcb for which data is read
 435:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param len the amount of bytes that have been read by the application
 436:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 437:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
 438:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_recved(struct tcp_pcb *pcb, u16_t len)
 439:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 440:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   int wnd_inflation;
 441:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 442:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
 443:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****               len <= 0xffff - pcb->rcv_wnd );
 444:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 445:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->rcv_wnd += len;
 446:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb->rcv_wnd > TCP_WND)
 447:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->rcv_wnd = TCP_WND;
 448:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 449:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 450:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 451:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* If the change in the right edge of window is significant (default
 452:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****    * watermark is TCP_WND/2), then send an explicit update now.
 453:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****    * Otherwise wait for a packet to be sent in the normal course of
 454:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****    * events (or more window to be available later) */
 455:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) 
 456:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_ack_now(pcb);
 457:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 458:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
 459:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****          len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
 460:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 461:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 462:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 463:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * A nastly hack featuring 'goto' statements that allocates a
 464:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * new TCP local port.
 465:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 466:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return a new (free) local TCP port number
 467:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 468:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** static u16_t
 469:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_new_port(void)
 470:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
  98              		.loc 1 470 0
  99 0048 70B5     		push	{r4, r5, r6, lr}
 100              	.LCFI1:
 101 004a 5646     		mov	r6, sl
 102 004c 4546     		mov	r5, r8
 103 004e 60B4     		push	{r5, r6}
 104              	.LCFI2:
 471:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_pcb *pcb;
 472:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #ifndef TCP_LOCAL_PORT_RANGE_START
 473:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #define TCP_LOCAL_PORT_RANGE_START 4096
 474:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #define TCP_LOCAL_PORT_RANGE_END   0x7fff
 475:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif
 476:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   static u16_t port = TCP_LOCAL_PORT_RANGE_START;
 477:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
 478:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  again:
 479:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (++port > TCP_LOCAL_PORT_RANGE_END) {
 480:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     port = TCP_LOCAL_PORT_RANGE_START;
 481:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 482:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
 483:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 105              		.loc 1 483 0
 106 0050 234B     		ldr	r3, .L25
 107 0052 1868     		ldr	r0, [r3]
 108              	.LVL10:
 484:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->local_port == port) {
 485:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       goto again;
 486:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 487:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 488:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 109              		.loc 1 488 0
 110 0054 234B     		ldr	r3, .L25+4
 111 0056 1C68     		ldr	r4, [r3]
 112              	.LVL11:
 489:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->local_port == port) {
 490:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       goto again;
 491:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 492:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 493:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
 113              		.loc 1 493 0
 114 0058 234B     		ldr	r3, .L25+8
 115 005a 1D68     		ldr	r5, [r3]
 116              	.LVL12:
 117 005c 234B     		ldr	r3, .L25+12
 118 005e 1988     		ldrh	r1, [r3]
 119              		.loc 1 479 0
 120 0060 8026     		mov	r6, #128
 121 0062 7601     		lsl	r6, r6, #5
 494:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->local_port == port) {
 122              		.loc 1 494 0
 123 0064 AA46     		mov	sl, r5
 124              		.loc 1 489 0
 125 0066 A046     		mov	r8, r4
 126              		.loc 1 484 0
 127 0068 8446     		mov	ip, r0
 128              	.LVL13:
 129              	.L24:
 130              		.loc 1 479 0
 131 006a 4B1C     		add	r3, r1, #1
 132 006c 1B04     		lsl	r3, r3, #16
 133 006e 190C     		lsr	r1, r3, #16
 134 0070 002B     		cmp	r3, #0
 135 0072 00DA     		bge	.L11
 136 0074 311C     		mov	r1, r6
 137              	.L11:
 138              		.loc 1 483 0
 139 0076 0028     		cmp	r0, #0
 140 0078 0AD0     		beq	.L12
 141              	.LVL14:
 142              		.loc 1 484 0
 143 007a 838B     		ldrh	r3, [r0, #28]
 144 007c 8B42     		cmp	r3, r1
 145 007e F4D0     		beq	.L24
 146 0080 6246     		mov	r2, ip
 147 0082 02E0     		b	.L14
 148              	.LVL15:
 149              	.L15:
 150 0084 938B     		ldrh	r3, [r2, #28]
 151 0086 8B42     		cmp	r3, r1
 152 0088 EFD0     		beq	.L24
 153              	.LVL16:
 154              	.L14:
 155              		.loc 1 483 0
 156 008a D268     		ldr	r2, [r2, #12]
 157 008c 002A     		cmp	r2, #0
 158 008e F9D1     		bne	.L15
 159              	.LVL17:
 160              	.L12:
 161              		.loc 1 488 0
 162 0090 002C     		cmp	r4, #0
 163 0092 0AD0     		beq	.L16
 164              	.LVL18:
 165              		.loc 1 489 0
 166 0094 A38B     		ldrh	r3, [r4, #28]
 167 0096 8B42     		cmp	r3, r1
 168 0098 E7D0     		beq	.L24
 169 009a 4246     		mov	r2, r8
 170 009c 02E0     		b	.L17
 171              	.LVL19:
 172              	.L18:
 173 009e 938B     		ldrh	r3, [r2, #28]
 174 00a0 8B42     		cmp	r3, r1
 175 00a2 E2D0     		beq	.L24
 176              	.LVL20:
 177              	.L17:
 178              		.loc 1 488 0
 179 00a4 D268     		ldr	r2, [r2, #12]
 180 00a6 002A     		cmp	r2, #0
 181 00a8 F9D1     		bne	.L18
 182              	.LVL21:
 183              	.L16:
 184              		.loc 1 493 0
 185 00aa 002D     		cmp	r5, #0
 186 00ac 02D1     		bne	.L19
 187              	.LVL22:
 188 00ae 0F4B     		ldr	r3, .L25+12
 189 00b0 1980     		strh	r1, [r3]
 190 00b2 0CE0     		b	.L20
 191              	.L19:
 192              		.loc 1 494 0
 193 00b4 AB8B     		ldrh	r3, [r5, #28]
 194 00b6 8B42     		cmp	r3, r1
 195 00b8 D7D0     		beq	.L24
 196 00ba 5246     		mov	r2, sl
 197 00bc 02E0     		b	.L21
 198              	.LVL23:
 199              	.L22:
 200 00be 938B     		ldrh	r3, [r2, #28]
 201 00c0 8B42     		cmp	r3, r1
 202 00c2 D2D0     		beq	.L24
 203              	.LVL24:
 204              	.L21:
 205              		.loc 1 493 0
 206 00c4 D268     		ldr	r2, [r2, #12]
 207 00c6 002A     		cmp	r2, #0
 208 00c8 F9D1     		bne	.L22
 209 00ca 084B     		ldr	r3, .L25+12
 210 00cc 1980     		strh	r1, [r3]
 211              	.LVL25:
 212              	.L20:
 213 00ce 074B     		ldr	r3, .L25+12
 214 00d0 1888     		ldrh	r0, [r3]
 495:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       goto again;
 496:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 497:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 498:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return port;
 499:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 215              		.loc 1 499 0
 216              		@ sp needed for prologue
 217 00d2 0CBC     		pop	{r2, r3}
 218 00d4 9046     		mov	r8, r2
 219 00d6 9A46     		mov	sl, r3
 220 00d8 70BC     		pop	{r4, r5, r6}
 221 00da 02BC     		pop	{r1}
 222 00dc 0847     		bx	r1
 223              	.L26:
 224 00de C046     		.align	2
 225              	.L25:
 226 00e0 00000000 		.word	tcp_active_pcbs
 227 00e4 00000000 		.word	tcp_tw_pcbs
 228 00e8 00000000 		.word	tcp_listen_pcbs
 229 00ec 30000000 		.word	port.5683
 230              	.LFE298:
 232              		.align	2
 233              		.global	tcp_setprio
 234              		.code	16
 235              		.thumb_func
 237              	tcp_setprio:
 238              	.LFB304:
 500:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 501:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 502:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Connects to another host. The function given as the "connected"
 503:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * argument will be called when the connection has been established.
 504:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 505:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb the tcp_pcb used to establish the connection
 506:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param ipaddr the remote ip address to connect to
 507:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param port the remote tcp port to connect to
 508:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param connected callback function to call when connected (or on error)
 509:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return ERR_VAL if invalid arguments are given
 510:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *         ERR_OK if connect request has been sent
 511:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *         other err_t values if connect request couldn't be sent
 512:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 513:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** err_t
 514:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
 515:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
 516:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 517:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   err_t ret;
 518:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u32_t iss;
 519:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 520:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_
 521:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 522:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
 523:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (ipaddr != NULL) {
 524:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->remote_ip = *ipaddr;
 525:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   } else {
 526:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     return ERR_VAL;
 527:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 528:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->remote_port = port;
 529:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb->local_port == 0) {
 530:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->local_port = tcp_new_port();
 531:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 532:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   iss = tcp_next_iss();
 533:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->rcv_nxt = 0;
 534:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->snd_nxt = iss;
 535:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->lastack = iss - 1;
 536:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->snd_lbb = iss - 1;
 537:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->rcv_wnd = TCP_WND;
 538:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->rcv_ann_wnd = TCP_WND;
 539:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 540:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->snd_wnd = TCP_WND;
 541:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* As initial send MSS, we use TCP_MSS but limit it to 536.
 542:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      The send MSS is updated when an MSS option is received. */
 543:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 544:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_CALCULATE_EFF_SEND_MSS
 545:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
 546:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
 547:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->cwnd = 1;
 548:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->ssthresh = pcb->mss * 10;
 549:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->state = SYN_SENT;
 550:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_CALLBACK_API  
 551:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->connected = connected;
 552:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 553:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   TCP_RMV(&tcp_bound_pcbs, pcb);
 554:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   TCP_REG(&tcp_active_pcbs, pcb);
 555:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 556:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   snmp_inc_tcpactiveopens();
 557:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
 558:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, TF_SEG_OPTS_MSS
 559:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_TCP_TIMESTAMPS
 560:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****                     | TF_SEG_OPTS_TS
 561:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif
 562:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****                     );
 563:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (ret == ERR_OK) { 
 564:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_output(pcb);
 565:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 566:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return ret;
 567:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** } 
 568:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 569:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 570:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Called every 500 ms and implements the retransmission timer and the timer that
 571:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * removes PCBs that have been in TIME-WAIT for enough time. It also increments
 572:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * various timers such as the inactivity timer in each PCB.
 573:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 574:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Automatically called from tcp_tmr().
 575:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 576:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
 577:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_slowtmr(void)
 578:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 579:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_pcb *pcb, *pcb2, *prev;
 580:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u16_t eff_wnd;
 581:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u8_t pcb_remove;      /* flag if a PCB should be removed */
 582:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u8_t pcb_reset;       /* flag if a RST should be sent when removing */
 583:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   err_t err;
 584:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 585:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   err = ERR_OK;
 586:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 587:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   ++tcp_ticks;
 588:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 589:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* Steps through all of the active PCBs. */
 590:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   prev = NULL;
 591:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb = tcp_active_pcbs;
 592:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb == NULL) {
 593:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
 594:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 595:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   while (pcb != NULL) {
 596:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
 597:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 598:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 599:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 600:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 601:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb_remove = 0;
 602:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb_reset = 0;
 603:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 604:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 605:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       ++pcb_remove;
 606:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
 607:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 608:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     else if (pcb->nrtx == TCP_MAXRTX) {
 609:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       ++pcb_remove;
 610:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
 611:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     } else {
 612:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (pcb->persist_backoff > 0) {
 613:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         /* If snd_wnd is zero, use persist timer to send 1 byte probes
 614:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****          * instead of using the standard retransmission mechanism. */
 615:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         pcb->persist_cnt++;
 616:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 617:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           pcb->persist_cnt = 0;
 618:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 619:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****             pcb->persist_backoff++;
 620:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           }
 621:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           tcp_zero_window_probe(pcb);
 622:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         }
 623:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       } else {
 624:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         /* Increase the retransmission timer if it is running */
 625:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         if(pcb->rtime >= 0)
 626:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           ++pcb->rtime;
 627:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 628:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 629:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           /* Time for a retransmission. */
 630:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
 631:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****                                       " pcb->rto %"S16_F"\n",
 632:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****                                       pcb->rtime, pcb->rto));
 633:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 634:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           /* Double retransmission time-out unless we are trying to
 635:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****            * connect to somebody (i.e., we are in SYN_SENT). */
 636:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           if (pcb->state != SYN_SENT) {
 637:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****             pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 638:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           }
 639:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 640:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           /* Reset the retransmission timer. */
 641:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           pcb->rtime = 0;
 642:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 643:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           /* Reduce congestion window and ssthresh. */
 644:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 645:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           pcb->ssthresh = eff_wnd >> 1;
 646:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           if (pcb->ssthresh < pcb->mss) {
 647:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****             pcb->ssthresh = pcb->mss * 2;
 648:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           }
 649:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           pcb->cwnd = pcb->mss;
 650:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"U16_F
 651:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****                                        " ssthresh %"U16_F"\n",
 652:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****                                        pcb->cwnd, pcb->ssthresh));
 653:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  
 654:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           /* The following needs to be called AFTER cwnd is set to one
 655:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****              mss - STJ */
 656:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           tcp_rexmit_rto(pcb);
 657:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         }
 658:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 659:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 660:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Check if this PCB has stayed too long in FIN-WAIT-2 */
 661:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->state == FIN_WAIT_2) {
 662:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if ((u32_t)(tcp_ticks - pcb->tmr) >
 663:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
 664:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         ++pcb_remove;
 665:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
 666:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 667:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 668:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 669:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Check if KEEPALIVE should be sent */
 670:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if((pcb->so_options & SOF_KEEPALIVE) && 
 671:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        ((pcb->state == ESTABLISHED) || 
 672:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         (pcb->state == CLOSE_WAIT))) {
 673:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_TCP_KEEPALIVE
 674:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if((u32_t)(tcp_ticks - pcb->tmr) > 
 675:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****          (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
 676:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****          / TCP_SLOW_INTERVAL)
 677:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #else      
 678:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if((u32_t)(tcp_ticks - pcb->tmr) > 
 679:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****          (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
 680:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_TCP_KEEPALIVE */
 681:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       {
 682:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"
 683:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****                                 ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
 684:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****                                 ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
 685:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         
 686:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         ++pcb_remove;
 687:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         ++pcb_reset;
 688:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 689:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_TCP_KEEPALIVE
 690:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       else if((u32_t)(tcp_ticks - pcb->tmr) > 
 691:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****               (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
 692:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****               / TCP_SLOW_INTERVAL)
 693:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #else
 694:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       else if((u32_t)(tcp_ticks - pcb->tmr) > 
 695:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****               (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
 696:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****               / TCP_SLOW_INTERVAL)
 697:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_TCP_KEEPALIVE */
 698:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       {
 699:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         tcp_keepalive(pcb);
 700:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         pcb->keep_cnt_sent++;
 701:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 702:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 703:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 704:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* If this PCB has queued out of sequence data, but has been
 705:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        inactive for too long, will drop the data (it will eventually
 706:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        be retransmitted). */
 707:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ    
 708:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->ooseq != NULL &&
 709:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 710:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       tcp_segs_free(pcb->ooseq);
 711:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb->ooseq = NULL;
 712:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
 713:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 714:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_QUEUE_OOSEQ */
 715:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 716:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Check if this PCB has stayed too long in SYN-RCVD */
 717:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->state == SYN_RCVD) {
 718:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if ((u32_t)(tcp_ticks - pcb->tmr) >
 719:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
 720:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         ++pcb_remove;
 721:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
 722:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 723:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 724:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 725:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Check if this PCB has stayed too long in LAST-ACK */
 726:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->state == LAST_ACK) {
 727:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 728:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         ++pcb_remove;
 729:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
 730:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 731:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 732:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 733:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* If the PCB should be removed, do it. */
 734:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb_remove) {
 735:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       tcp_pcb_purge(pcb);      
 736:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* Remove PCB from tcp_active_pcbs list. */
 737:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (prev != NULL) {
 738:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 739:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         prev->next = pcb->next;
 740:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       } else {
 741:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         /* This PCB was the first. */
 742:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 743:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         tcp_active_pcbs = pcb->next;
 744:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 745:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 746:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
 747:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (pcb_reset) {
 748:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 749:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           pcb->local_port, pcb->remote_port);
 750:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 751:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 752:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb2 = pcb->next;
 753:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       memp_free(MEMP_TCP_PCB, pcb);
 754:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb = pcb2;
 755:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     } else {
 756:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 757:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* We check if we should poll the connection. */
 758:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       ++pcb->polltmr;
 759:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (pcb->polltmr >= pcb->pollinterval) {
 760:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         pcb->polltmr = 0;
 761:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
 762:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         TCP_EVENT_POLL(pcb, err);
 763:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         if (err == ERR_OK) {
 764:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           tcp_output(pcb);
 765:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         }
 766:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 767:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       
 768:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       prev = pcb;
 769:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb = pcb->next;
 770:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 771:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 772:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 773:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
 774:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* Steps through all of the TIME-WAIT PCBs. */
 775:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   prev = NULL;    
 776:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb = tcp_tw_pcbs;
 777:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   while (pcb != NULL) {
 778:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 779:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb_remove = 0;
 780:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 781:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Check if this PCB has stayed long enough in TIME-WAIT */
 782:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 783:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       ++pcb_remove;
 784:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 785:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     
 786:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 787:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 788:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* If the PCB should be removed, do it. */
 789:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb_remove) {
 790:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       tcp_pcb_purge(pcb);      
 791:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* Remove PCB from tcp_tw_pcbs list. */
 792:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (prev != NULL) {
 793:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 794:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         prev->next = pcb->next;
 795:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       } else {
 796:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         /* This PCB was the first. */
 797:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 798:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         tcp_tw_pcbs = pcb->next;
 799:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 800:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb2 = pcb->next;
 801:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       memp_free(MEMP_TCP_PCB, pcb);
 802:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb = pcb2;
 803:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     } else {
 804:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       prev = pcb;
 805:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb = pcb->next;
 806:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 807:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 808:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 809:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 810:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 811:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Is called every TCP_FAST_INTERVAL (250 ms) and process data previously
 812:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * "refused" by upper layer (application) and sends delayed ACKs.
 813:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 814:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Automatically called from tcp_tmr().
 815:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 816:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
 817:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_fasttmr(void)
 818:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 819:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_pcb *pcb;
 820:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 821:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 822:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* If there is data which was previously "refused" by upper layer */
 823:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->refused_data != NULL) {
 824:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* Notify again application with data previously received. */
 825:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       err_t err;
 826:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
 827:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
 828:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (err == ERR_OK) {
 829:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         pcb->refused_data = NULL;
 830:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
 831:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 832:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 833:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* send delayed ACKs */  
 834:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->flags & TF_ACK_DELAY) {
 835:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
 836:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       tcp_ack_now(pcb);
 837:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 838:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 839:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 840:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 841:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 842:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 843:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Deallocates a list of TCP segments (tcp_seg structures).
 844:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 845:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param seg tcp_seg list of TCP segments to free
 846:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return the number of pbufs that were deallocated
 847:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 848:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** u8_t
 849:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_segs_free(struct tcp_seg *seg)
 850:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 851:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u8_t count = 0;
 852:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_seg *next;
 853:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   while (seg != NULL) {
 854:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     next = seg->next;
 855:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     count += tcp_seg_free(seg);
 856:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     seg = next;
 857:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 858:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return count;
 859:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 860:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 861:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 862:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Frees a TCP segment (tcp_seg structure).
 863:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 864:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param seg single tcp_seg to free
 865:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return the number of pbufs that were deallocated
 866:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 867:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** u8_t
 868:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_seg_free(struct tcp_seg *seg)
 869:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 870:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u8_t count = 0;
 871:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
 872:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (seg != NULL) {
 873:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (seg->p != NULL) {
 874:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       count = pbuf_free(seg->p);
 875:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_DEBUG
 876:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       seg->p = NULL;
 877:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_DEBUG */
 878:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 879:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     memp_free(MEMP_TCP_SEG, seg);
 880:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 881:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return count;
 882:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 883:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 884:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 885:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Sets the priority of a connection.
 886:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 887:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb the tcp_pcb to manipulate
 888:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param prio new priority
 889:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 890:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
 891:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
 892:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 239              		.loc 1 892 0
 240              	.LVL26:
 893:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->prio = prio;
 241              		.loc 1 893 0
 242 00f0 0175     		strb	r1, [r0, #20]
 894:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 243              		.loc 1 894 0
 244              		@ sp needed for prologue
 245 00f2 7047     		bx	lr
 246              	.LFE304:
 248              		.align	2
 249              		.global	tcp_arg
 250              		.code	16
 251              		.thumb_func
 253              	tcp_arg:
 254              	.LFB311:
 895:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ
 896:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 897:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 898:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Returns a copy of the given TCP segment.
 899:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * The pbuf and data are not copied, only the pointers
 900:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 901:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param seg the old tcp_seg
 902:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return a copy of seg
 903:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */ 
 904:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** struct tcp_seg *
 905:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_seg_copy(struct tcp_seg *seg)
 906:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 907:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_seg *cseg;
 908:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 909:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   cseg = memp_malloc(MEMP_TCP_SEG);
 910:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (cseg == NULL) {
 911:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     return NULL;
 912:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 913:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
 914:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pbuf_ref(cseg->p);
 915:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return cseg;
 916:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 917:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif
 918:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 919:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_CALLBACK_API
 920:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 921:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Default receive callback that is called if the user didn't register
 922:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * a recv callback for the pcb.
 923:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 924:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** err_t
 925:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
 926:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 927:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_UNUSED_ARG(arg);
 928:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (p != NULL) {
 929:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_recved(pcb, p->tot_len);
 930:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pbuf_free(p);
 931:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   } else if (err == ERR_OK) {
 932:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     return tcp_close(pcb);
 933:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 934:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return ERR_OK;
 935:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 936:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
 937:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 938:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 939:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Kills the oldest active connection that has lower priority than prio.
 940:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
 941:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param prio minimum priority
 942:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 943:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** static void
 944:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_kill_prio(u8_t prio)
 945:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 946:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_pcb *pcb, *inactive;
 947:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u32_t inactivity;
 948:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u8_t mprio;
 949:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 950:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 951:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   mprio = TCP_PRIO_MAX;
 952:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
 953:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* We kill the oldest active connection that has lower priority than prio. */
 954:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   inactivity = 0;
 955:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   inactive = NULL;
 956:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 957:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->prio <= prio &&
 958:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        pcb->prio <= mprio &&
 959:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 960:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       inactivity = tcp_ticks - pcb->tmr;
 961:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       inactive = pcb;
 962:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       mprio = pcb->prio;
 963:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 964:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 965:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (inactive != NULL) {
 966:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
 967:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****            (void *)inactive, inactivity));
 968:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_abort(inactive);
 969:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }      
 970:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 971:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 972:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 973:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Kills the oldest connection that is in TIME_WAIT state.
 974:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Called from tcp_alloc() if no more connections are available.
 975:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
 976:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** static void
 977:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_kill_timewait(void)
 978:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 979:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_pcb *pcb, *inactive;
 980:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u32_t inactivity;
 981:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 982:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   inactivity = 0;
 983:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   inactive = NULL;
 984:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
 985:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 986:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 987:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       inactivity = tcp_ticks - pcb->tmr;
 988:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       inactive = pcb;
 989:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
 990:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
 991:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (inactive != NULL) {
 992:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
 993:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****            (void *)inactive, inactivity));
 994:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_abort(inactive);
 995:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }      
 996:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 997:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
 998:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
 999:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Allocate a new tcp_pcb structure.
1000:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1001:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param prio priority for the new pcb
1002:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return a new tcp_pcb that initially is in state CLOSED
1003:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
1004:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** struct tcp_pcb *
1005:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_alloc(u8_t prio)
1006:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
1007:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct tcp_pcb *pcb;
1008:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u32_t iss;
1009:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
1010:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb = memp_malloc(MEMP_TCP_PCB);
1011:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb == NULL) {
1012:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Try killing oldest connection in TIME-WAIT. */
1013:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
1014:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_kill_timewait();
1015:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Try to allocate a tcp_pcb again. */
1016:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb = memp_malloc(MEMP_TCP_PCB);
1017:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb == NULL) {
1018:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* Try killing active connections with lower priority than the new one. */
1019:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
1020:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       tcp_kill_prio(prio);
1021:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* Try to allocate a tcp_pcb again. */
1022:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb = memp_malloc(MEMP_TCP_PCB);
1023:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       if (pcb != NULL) {
1024:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         /* adjust err stats: memp_malloc failed twice before */
1025:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
1026:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
1027:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
1028:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb != NULL) {
1029:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* adjust err stats: timewait PCB was freed above */
1030:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       MEMP_STATS_DEC(err, MEMP_TCP_PCB);
1031:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
1032:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
1033:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb != NULL) {
1034:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     memset(pcb, 0, sizeof(struct tcp_pcb));
1035:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->prio = TCP_PRIO_NORMAL;
1036:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->snd_buf = TCP_SND_BUF;
1037:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->snd_queuelen = 0;
1038:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->rcv_wnd = TCP_WND;
1039:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->rcv_ann_wnd = TCP_WND;
1040:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->tos = 0;
1041:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->ttl = TCP_TTL;
1042:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* As initial send MSS, we use TCP_MSS but limit it to 536.
1043:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        The send MSS is updated when an MSS option is received. */
1044:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
1045:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->rto = 3000 / TCP_SLOW_INTERVAL;
1046:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->sa = 0;
1047:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->sv = 3000 / TCP_SLOW_INTERVAL;
1048:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->rtime = -1;
1049:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->cwnd = 1;
1050:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     iss = tcp_next_iss();
1051:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->snd_wl2 = iss;
1052:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->snd_nxt = iss;
1053:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->lastack = iss;
1054:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->snd_lbb = iss;   
1055:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->tmr = tcp_ticks;
1056:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1057:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->polltmr = 0;
1058:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1059:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_CALLBACK_API
1060:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->recv = tcp_recv_null;
1061:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */  
1062:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     
1063:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Init KEEPALIVE timer */
1064:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
1065:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     
1066:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_TCP_KEEPALIVE
1067:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
1068:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
1069:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_TCP_KEEPALIVE */
1070:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1071:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->keep_cnt_sent = 0;
1072:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
1073:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return pcb;
1074:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
1075:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1076:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1077:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Creates a new TCP protocol control block but doesn't place it on
1078:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * any of the TCP PCB lists.
1079:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * The pcb is not put on any list until binding using tcp_bind().
1080:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1081:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @internal: Maybe there should be a idle TCP PCB list where these
1082:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * PCBs are put on. Port reservation using tcp_bind() is implemented but
1083:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * allocated pcbs that are not bound can't be killed automatically if wanting
1084:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * to allocate a pcb with higher prio (@see tcp_kill_prio())
1085:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1086:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return a new tcp_pcb that initially is in state CLOSED
1087:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
1088:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** struct tcp_pcb *
1089:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_new(void)
1090:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
1091:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return tcp_alloc(TCP_PRIO_NORMAL);
1092:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
1093:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1094:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1095:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Used to specify the argument that should be passed callback
1096:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * functions.
1097:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1098:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb tcp_pcb to set the callback argument
1099:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param arg void pointer argument to pass to callback functions
1100:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */ 
1101:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
1102:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_arg(struct tcp_pcb *pcb, void *arg)
1103:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {  
 255              		.loc 1 1103 0
 256              	.LVL27:
1104:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->callback_arg = arg;
 257              		.loc 1 1104 0
 258 00f4 8161     		str	r1, [r0, #24]
1105:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 259              		.loc 1 1105 0
 260              		@ sp needed for prologue
 261 00f6 7047     		bx	lr
 262              	.LFE311:
 264              		.align	2
 265              		.global	tcp_recv
 266              		.code	16
 267              		.thumb_func
 269              	tcp_recv:
 270              	.LFB312:
1106:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_CALLBACK_API
1107:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1108:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1109:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Used to specify the function that should be called when a TCP
1110:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * connection receives data.
1111:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1112:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb tcp_pcb to set the recv callback
1113:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param recv callback function to call for this pcb when data is received
1114:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */ 
1115:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
1116:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_recv(struct tcp_pcb *pcb,
1117:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****    err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
1118:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 271              		.loc 1 1118 0
 272              	.LVL28:
1119:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->recv = recv;
 273              		.loc 1 1119 0
 274 00f8 8C23     		mov	r3, #140
 275 00fa C150     		str	r1, [r0, r3]
1120:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 276              		.loc 1 1120 0
 277              		@ sp needed for prologue
 278 00fc 7047     		bx	lr
 279              	.LFE312:
 281 00fe C046     		.align	2
 282              		.global	tcp_sent
 283              		.code	16
 284              		.thumb_func
 286              	tcp_sent:
 287              	.LFB313:
1121:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1122:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1123:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Used to specify the function that should be called when TCP data
1124:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * has been successfully delivered to the remote host.
1125:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1126:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb tcp_pcb to set the sent callback
1127:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param sent callback function to call for this pcb when data is successfully sent
1128:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */ 
1129:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
1130:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_sent(struct tcp_pcb *pcb,
1131:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****    err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
1132:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 288              		.loc 1 1132 0
 289              	.LVL29:
1133:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->sent = sent;
 290              		.loc 1 1133 0
 291 0100 8823     		mov	r3, #136
 292 0102 C150     		str	r1, [r0, r3]
1134:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 293              		.loc 1 1134 0
 294              		@ sp needed for prologue
 295 0104 7047     		bx	lr
 296              	.LFE313:
 298 0106 C046     		.align	2
 299              		.global	tcp_err
 300              		.code	16
 301              		.thumb_func
 303              	tcp_err:
 304              	.LFB314:
1135:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1136:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1137:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Used to specify the function that should be called when a fatal error
1138:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * has occured on the connection.
1139:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1140:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb tcp_pcb to set the err callback
1141:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param errf callback function to call for this pcb when a fatal error
1142:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *        has occured on the connection
1143:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */ 
1144:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
1145:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_err(struct tcp_pcb *pcb,
1146:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****    void (* errf)(void *arg, err_t err))
1147:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 305              		.loc 1 1147 0
 306              	.LVL30:
1148:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->errf = errf;
 307              		.loc 1 1148 0
 308 0108 9823     		mov	r3, #152
 309 010a C150     		str	r1, [r0, r3]
1149:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 310              		.loc 1 1149 0
 311              		@ sp needed for prologue
 312 010c 7047     		bx	lr
 313              	.LFE314:
 315 010e C046     		.align	2
 316              		.global	tcp_accept
 317              		.code	16
 318              		.thumb_func
 320              	tcp_accept:
 321              	.LFB315:
1150:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1151:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1152:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Used for specifying the function that should be called when a
1153:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * LISTENing connection has been connected to another host.
1154:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1155:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb tcp_pcb to set the accept callback
1156:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param accept callback function to call for this pcb when LISTENing
1157:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *        connection has been connected to another host
1158:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */ 
1159:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
1160:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_accept(struct tcp_pcb *pcb,
1161:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
1162:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 322              		.loc 1 1162 0
 323              	.LVL31:
1163:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->accept = accept;
 324              		.loc 1 1163 0
 325 0110 0162     		str	r1, [r0, #32]
1164:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 326              		.loc 1 1164 0
 327              		@ sp needed for prologue
 328 0112 7047     		bx	lr
 329              	.LFE315:
 331              		.align	2
 332              		.global	tcp_poll
 333              		.code	16
 334              		.thumb_func
 336              	tcp_poll:
 337              	.LFB316:
1165:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */
1166:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1167:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1168:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1169:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Used to specify the function that should be called periodically
1170:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * from TCP. The interval is specified in terms of the TCP coarse
1171:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * timer interval, which is called twice a second.
1172:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1173:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */ 
1174:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
1175:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_poll(struct tcp_pcb *pcb,
1176:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****    err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
1177:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 338              		.loc 1 1177 0
 339              	.LVL32:
1178:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if LWIP_CALLBACK_API
1179:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->poll = poll;
 340              		.loc 1 1179 0
 341 0114 9423     		mov	r3, #148
 342 0116 C150     		str	r1, [r0, r3]
1180:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* LWIP_CALLBACK_API */  
1181:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->pollinterval = interval;
 343              		.loc 1 1181 0
 344 0118 3923     		mov	r3, #57
 345 011a C254     		strb	r2, [r0, r3]
1182:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 346              		.loc 1 1182 0
 347              		@ sp needed for prologue
 348 011c 7047     		bx	lr
 349              	.LFE316:
 351 011e C046     		.align	2
 352              		.global	tcp_next_iss
 353              		.code	16
 354              		.thumb_func
 356              	tcp_next_iss:
 357              	.LFB319:
1183:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1184:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1185:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Purges a TCP PCB. Removes any buffered data and frees the buffer memory
1186:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * (pcb->ooseq, pcb->unsent and pcb->unacked are freed).
1187:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1188:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
1189:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
1190:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
1191:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_pcb_purge(struct tcp_pcb *pcb)
1192:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
1193:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb->state != CLOSED &&
1194:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      pcb->state != TIME_WAIT &&
1195:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      pcb->state != LISTEN) {
1196:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1197:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
1198:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1199:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_LISTEN_BACKLOG
1200:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->state == SYN_RCVD) {
1201:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
1202:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       struct tcp_pcb_listen *lpcb;
1203:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
1204:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         tcp_listen_pcbs.listen_pcbs != NULL);
1205:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
1206:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****         if ((lpcb->local_port == pcb->local_port) &&
1207:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****             (ip_addr_isany(&lpcb->local_ip) ||
1208:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****              ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
1209:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****             /* port and address of the listen pcb match the timed-out pcb */
1210:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****             LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
1211:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****               lpcb->accepts_pending > 0);
1212:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****             lpcb->accepts_pending--;
1213:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****             break;
1214:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****           }
1215:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       }
1216:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
1217:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_LISTEN_BACKLOG */
1218:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1219:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1220:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->refused_data != NULL) {
1221:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
1222:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pbuf_free(pcb->refused_data);
1223:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       pcb->refused_data = NULL;
1224:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
1225:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->unsent != NULL) {
1226:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
1227:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
1228:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->unacked != NULL) {
1229:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
1230:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
1231:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ /* LW */
1232:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     if (pcb->ooseq != NULL) {
1233:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
1234:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     }
1235:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1236:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* Stop the retransmission timer as it will expect data on unacked
1237:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****        queue if it fires */
1238:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->rtime = -1;
1239:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1240:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_segs_free(pcb->ooseq);
1241:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->ooseq = NULL;
1242:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_QUEUE_OOSEQ */
1243:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_segs_free(pcb->unsent);
1244:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_segs_free(pcb->unacked);
1245:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->unacked = pcb->unsent = NULL;
1246:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
1247:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
1248:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1249:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1250:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Purges the PCB and removes it from a PCB list. Any delayed ACKs are sent first.
1251:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1252:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcblist PCB list to purge.
1253:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
1254:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
1255:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** void
1256:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
1257:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
1258:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   TCP_RMV(pcblist, pcb);
1259:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1260:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   tcp_pcb_purge(pcb);
1261:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
1262:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   /* if there is an outstanding delayed ACKs, send it */
1263:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb->state != TIME_WAIT &&
1264:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      pcb->state != LISTEN &&
1265:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      pcb->flags & TF_ACK_DELAY) {
1266:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     pcb->flags |= TF_ACK_NOW;
1267:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     tcp_output(pcb);
1268:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
1269:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1270:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if (pcb->state != LISTEN) {
1271:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
1272:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
1273:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_QUEUE_OOSEQ
1274:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
1275:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_QUEUE_OOSEQ */
1276:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
1277:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1278:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   pcb->state = CLOSED;
1279:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1280:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
1281:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
1282:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1283:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1284:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Calculates a new initial sequence number for new connections.
1285:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  *
1286:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * @return u32_t pseudo random sequence number
1287:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
1288:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** u32_t
1289:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_next_iss(void)
1290:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 358              		.loc 1 1290 0
1291:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   static u32_t iss = 6510;
1292:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   
1293:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   iss += tcp_ticks;       /* XXX */
 359              		.loc 1 1293 0
 360 0120 034B     		ldr	r3, .L43
 361 0122 044A     		ldr	r2, .L43+4
 362 0124 1868     		ldr	r0, [r3]
 363 0126 1368     		ldr	r3, [r2]
 364 0128 C018     		add	r0, r0, r3
 365 012a 1060     		str	r0, [r2]
1294:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return iss;
1295:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 366              		.loc 1 1295 0
 367              		@ sp needed for prologue
 368 012c 7047     		bx	lr
 369              	.L44:
 370 012e C046     		.align	2
 371              	.L43:
 372 0130 00000000 		.word	tcp_ticks
 373 0134 2C000000 		.word	iss.6001
 374              	.LFE319:
 376              		.align	2
 377              		.global	tcp_debug_state_str
 378              		.code	16
 379              		.thumb_func
 381              	tcp_debug_state_str:
 382              	.LFB321:
1296:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1297:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #if TCP_CALCULATE_EFF_SEND_MSS
1298:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** /**
1299:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * Calcluates the effective send mss that can be used for a specific IP address
1300:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * by using ip_route to determin the netif used to send to the address and
1301:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  * calculating the minimum of TCP_MSS and that netif's mtu (if set).
1302:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****  */
1303:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** u16_t
1304:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
1305:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
1306:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   u16_t mss_s;
1307:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   struct netif *outif;
1308:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1309:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   outif = ip_route(addr);
1310:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   if ((outif != NULL) && (outif->mtu != 0)) {
1311:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
1312:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     /* RFC 1122, chap 4.2.2.6:
1313:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
1314:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      * We correct for TCP options in tcp_enqueue(), and don't support
1315:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      * IP options
1316:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****      */
1317:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****     sendmss = LWIP_MIN(sendmss, mss_s);
1318:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   }
1319:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return sendmss;
1320:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
1321:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** #endif /* TCP_CALCULATE_EFF_SEND_MSS */
1322:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** 
1323:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** const char*
1324:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** tcp_debug_state_str(enum tcp_state s)
1325:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** {
 383              		.loc 1 1325 0
 384              	.LVL33:
 385              		.loc 1 1325 0
 386 0138 014B     		ldr	r3, .L47
 387 013a 8000     		lsl	r0, r0, #2
 388              	.LVL34:
 389 013c C058     		ldr	r0, [r0, r3]
1326:rtos/common/ethernet/lwIP_132/src/core/tcp.c ****   return tcp_state_str[s];
1327:rtos/common/ethernet/lwIP_132/src/core/tcp.c **** }
 390              		.loc 1 1327 0
 391              		@ sp needed for prologue
 392 013e 7047     		bx	lr
 393              	.L48:
 394              		.align	2
 395              	.L47:
 396 0140 00000000 		.word	tcp_state_str
 397              	.LFE321:
 399              		.align	2
 400              		.global	tcp_eff_send_mss
 401              		.code	16
 402              		.thumb_func
 404              	tcp_eff_send_mss:
 405              	.LFB320:
 406              		.loc 1 1305 0
 407 0144 10B5     		push	{r4, lr}
 408              	.LCFI3:
 409              	.LVL35:
 410 0146 0004     		lsl	r0, r0, #16
 411              	.LVL36:
 412 0148 040C     		lsr	r4, r0, #16
 413              	.LVL37:
 414              		.loc 1 1309 0
 415 014a 081C     		mov	r0, r1
 416 014c FFF7FEFF 		bl	ip_route
 417              	.LVL38:
 418              		.loc 1 1310 0
 419 0150 0028     		cmp	r0, #0
 420 0152 0CD0     		beq	.L50
 421              	.LVL39:
 422 0154 808C     		ldrh	r0, [r0, #36]
 423              	.LVL40:
 424 0156 0028     		cmp	r0, #0
 425 0158 09D0     		beq	.L50
 426              		.loc 1 1317 0
 427 015a 011C     		mov	r1, r0
 428 015c 2839     		sub	r1, r1, #40
 429 015e 221C     		add	r2, r4, #0
 430 0160 0B04     		lsl	r3, r1, #16
 431 0162 1B0C     		lsr	r3, r3, #16
 432 0164 9C42     		cmp	r4, r3
 433 0166 00D9     		bls	.L51
 434 0168 0A1C     		add	r2, r1, #0
 435              	.LVL41:
 436              	.L51:
 437 016a 1304     		lsl	r3, r2, #16
 438 016c 1C0C     		lsr	r4, r3, #16
 439              	.LVL42:
 440              	.L50:
 441              		.loc 1 1320 0
 442 016e 201C     		mov	r0, r4
 443              	.LVL43:
 444              		@ sp needed for prologue
 445              	.LVL44:
 446 0170 10BC     		pop	{r4}
 447 0172 02BC     		pop	{r1}
 448 0174 0847     		bx	r1
 449              	.LFE320:
 451 0176 C046     		.align	2
 452              		.global	tcp_recved
 453              		.code	16
 454              		.thumb_func
 456              	tcp_recved:
 457              	.LFB297:
 458              		.loc 1 439 0
 459 0178 10B5     		push	{r4, lr}
 460              	.LCFI4:
 461              	.LVL45:
 462 017a 041C     		mov	r4, r0
 463 017c 0904     		lsl	r1, r1, #16
 464              	.LVL46:
 465 017e 090C     		lsr	r1, r1, #16
 466              	.LVL47:
 467              		.loc 1 445 0
 468 0180 838D     		ldrh	r3, [r0, #44]
 469 0182 C918     		add	r1, r1, r3
 470              	.LVL48:
 471 0184 0904     		lsl	r1, r1, #16
 472 0186 090C     		lsr	r1, r1, #16
 473 0188 8185     		strh	r1, [r0, #44]
 474              		.loc 1 446 0
 475 018a 8023     		mov	r3, #128
 476 018c 9B00     		lsl	r3, r3, #2
 477 018e 9942     		cmp	r1, r3
 478 0190 02D9     		bls	.L54
 479              		.loc 1 447 0
 480 0192 8023     		mov	r3, #128
 481 0194 9B00     		lsl	r3, r3, #2
 482 0196 8385     		strh	r3, [r0, #44]
 483              	.L54:
 484              		.loc 1 449 0
 485 0198 201C     		mov	r0, r4
 486              	.LVL49:
 487 019a FFF7FEFF 		bl	tcp_update_rcv_ann_wnd
 488              		.loc 1 455 0
 489 019e 7F28     		cmp	r0, #127
 490 01a0 07DD     		ble	.L56
 491              		.loc 1 456 0
 492 01a2 2623     		mov	r3, #38
 493 01a4 E25C     		ldrb	r2, [r4, r3]
 494 01a6 0221     		mov	r1, #2
 495 01a8 0A43     		orr	r2, r2, r1
 496 01aa E254     		strb	r2, [r4, r3]
 497 01ac 201C     		mov	r0, r4
 498 01ae FFF7FEFF 		bl	tcp_output
 499              	.L56:
 500              		.loc 1 460 0
 501              		@ sp needed for prologue
 502              	.LVL50:
 503 01b2 10BC     		pop	{r4}
 504 01b4 01BC     		pop	{r0}
 505 01b6 0047     		bx	r0
 506              	.LFE297:
 508              		.align	2
 509              		.global	tcp_seg_copy
 510              		.code	16
 511              		.thumb_func
 513              	tcp_seg_copy:
 514              	.LFB305:
 515              		.loc 1 906 0
 516 01b8 70B5     		push	{r4, r5, r6, lr}
 517              	.LCFI5:
 518              	.LVL51:
 519 01ba 051C     		mov	r5, r0
 520              		.loc 1 909 0
 521 01bc 0420     		mov	r0, #4
 522              	.LVL52:
 523 01be FFF7FEFF 		bl	memp_malloc
 524 01c2 041C     		mov	r4, r0
 525              	.LVL53:
 526              		.loc 1 910 0
 527 01c4 0028     		cmp	r0, #0
 528 01c6 08D0     		beq	.L58
 529              	.LVL54:
 530              		.loc 1 913 0
 531 01c8 031C     		mov	r3, r0
 532 01ca 2A1C     		mov	r2, r5
 533 01cc 43CA     		ldmia	r2!, {r0, r1, r6}
 534 01ce 43C3     		stmia	r3!, {r0, r1, r6}
 535              	.LVL55:
 536 01d0 03CA     		ldmia	r2!, {r0, r1}
 537 01d2 03C3     		stmia	r3!, {r0, r1}
 538              		.loc 1 914 0
 539 01d4 6068     		ldr	r0, [r4, #4]
 540 01d6 FFF7FEFF 		bl	pbuf_ref
 541              	.LVL56:
 542              	.L58:
 543              		.loc 1 916 0
 544 01da 201C     		mov	r0, r4
 545              		@ sp needed for prologue
 546              	.LVL57:
 547              	.LVL58:
 548 01dc 70BC     		pop	{r4, r5, r6}
 549 01de 02BC     		pop	{r1}
 550 01e0 0847     		bx	r1
 551              	.LFE305:
 553 01e2 C046     		.align	2
 554              		.global	tcp_seg_free
 555              		.code	16
 556              		.thumb_func
 558              	tcp_seg_free:
 559              	.LFB303:
 560              		.loc 1 869 0
 561 01e4 30B5     		push	{r4, r5, lr}
 562              	.LCFI6:
 563              	.LVL59:
 564 01e6 041C     		mov	r4, r0
 565              		.loc 1 872 0
 566 01e8 0028     		cmp	r0, #0
 567 01ea 01D1     		bne	.L61
 568 01ec 0025     		mov	r5, #0
 569              	.LVL60:
 570 01ee 0BE0     		b	.L62
 571              	.LVL61:
 572              	.L61:
 573              		.loc 1 873 0
 574 01f0 4068     		ldr	r0, [r0, #4]
 575              	.LVL62:
 576 01f2 0028     		cmp	r0, #0
 577 01f4 01D1     		bne	.L63
 578 01f6 0025     		mov	r5, #0
 579              	.LVL63:
 580 01f8 02E0     		b	.L64
 581              	.LVL64:
 582              	.L63:
 583              		.loc 1 874 0
 584 01fa FFF7FEFF 		bl	pbuf_free
 585 01fe 051C     		mov	r5, r0
 586              	.LVL65:
 587              	.L64:
 588              		.loc 1 879 0
 589 0200 0420     		mov	r0, #4
 590 0202 211C     		mov	r1, r4
 591 0204 FFF7FEFF 		bl	memp_free
 592              	.LVL66:
 593              	.L62:
 594              		.loc 1 882 0
 595 0208 281C     		mov	r0, r5
 596              		@ sp needed for prologue
 597              	.LVL67:
 598              	.LVL68:
 599 020a 30BC     		pop	{r4, r5}
 600 020c 02BC     		pop	{r1}
 601 020e 0847     		bx	r1
 602              	.LFE303:
 604              		.align	2
 605              		.global	tcp_segs_free
 606              		.code	16
 607              		.thumb_func
 609              	tcp_segs_free:
 610              	.LFB302:
 611              		.loc 1 850 0
 612 0210 30B5     		push	{r4, r5, lr}
 613              	.LCFI7:
 614              	.LVL69:
 615              		.loc 1 853 0
 616 0212 0028     		cmp	r0, #0
 617 0214 0AD0     		beq	.L67
 618 0216 0024     		mov	r4, #0
 619              	.LVL70:
 620              	.L69:
 621              		.loc 1 854 0
 622 0218 0568     		ldr	r5, [r0]
 623              		.loc 1 855 0
 624 021a FFF7FEFF 		bl	tcp_seg_free
 625              	.LVL71:
 626 021e 2018     		add	r0, r4, r0
 627 0220 0006     		lsl	r0, r0, #24
 628 0222 040E     		lsr	r4, r0, #24
 629              	.LVL72:
 630              		.loc 1 853 0
 631 0224 002D     		cmp	r5, #0
 632 0226 02D0     		beq	.L68
 633 0228 281C     		mov	r0, r5
 634              	.LVL73:
 635 022a F5E7     		b	.L69
 636              	.LVL74:
 637              	.L67:
 638 022c 0024     		mov	r4, #0
 639              	.LVL75:
 640              	.L68:
 641              		.loc 1 859 0
 642 022e 201C     		mov	r0, r4
 643              	.LVL76:
 644              		@ sp needed for prologue
 645              	.LVL77:
 646              	.LVL78:
 647 0230 30BC     		pop	{r4, r5}
 648 0232 02BC     		pop	{r1}
 649 0234 0847     		bx	r1
 650              	.LFE302:
 652 0236 C046     		.align	2
 653              		.global	tcp_pcb_purge
 654              		.code	16
 655              		.thumb_func
 657              	tcp_pcb_purge:
 658              	.LFB317:
 659              		.loc 1 1192 0
 660 0238 70B5     		push	{r4, r5, r6, lr}
 661              	.LCFI8:
 662              	.LVL79:
 663 023a 061C     		mov	r6, r0
 664              		.loc 1 1193 0
 665 023c 0369     		ldr	r3, [r0, #16]
 666 023e 002B     		cmp	r3, #0
 667 0240 1DD0     		beq	.L74
 668 0242 0A2B     		cmp	r3, #10
 669 0244 1BD0     		beq	.L74
 670 0246 012B     		cmp	r3, #1
 671 0248 19D0     		beq	.L74
 672              		.loc 1 1220 0
 673 024a 8423     		mov	r3, #132
 674 024c C058     		ldr	r0, [r0, r3]
 675              	.LVL80:
 676 024e 0028     		cmp	r0, #0
 677 0250 04D0     		beq	.L73
 678              		.loc 1 1222 0
 679 0252 FFF7FEFF 		bl	pbuf_free
 680              		.loc 1 1223 0
 681 0256 0022     		mov	r2, #0
 682 0258 8423     		mov	r3, #132
 683 025a F250     		str	r2, [r6, r3]
 684              	.L73:
 685              		.loc 1 1238 0
 686 025c 0123     		mov	r3, #1
 687 025e 5B42     		neg	r3, r3
 688 0260 7387     		strh	r3, [r6, #58]
 689              		.loc 1 1240 0
 690 0262 8025     		mov	r5, #128
 691 0264 7059     		ldr	r0, [r6, r5]
 692 0266 FFF7FEFF 		bl	tcp_segs_free
 693              		.loc 1 1241 0
 694 026a 0024     		mov	r4, #0
 695 026c 7451     		str	r4, [r6, r5]
 696              		.loc 1 1243 0
 697 026e B06F     		ldr	r0, [r6, #120]
 698 0270 FFF7FEFF 		bl	tcp_segs_free
 699              		.loc 1 1244 0
 700 0274 F06F     		ldr	r0, [r6, #124]
 701 0276 FFF7FEFF 		bl	tcp_segs_free
 702              		.loc 1 1245 0
 703 027a B467     		str	r4, [r6, #120]
 704 027c F467     		str	r4, [r6, #124]
 705              	.LVL81:
 706              	.L74:
 707              		.loc 1 1247 0
 708              		@ sp needed for prologue
 709              	.LVL82:
 710 027e 70BC     		pop	{r4, r5, r6}
 711 0280 01BC     		pop	{r0}
 712 0282 0047     		bx	r0
 713              	.LFE317:
 715              		.align	2
 716              		.global	tcp_pcb_remove
 717              		.code	16
 718              		.thumb_func
 720              	tcp_pcb_remove:
 721              	.LFB318:
 722              		.loc 1 1257 0
 723 0284 10B5     		push	{r4, lr}
 724              	.LCFI9:
 725              	.LVL83:
 726 0286 0C1C     		mov	r4, r1
 727              		.loc 1 1258 0
 728 0288 0268     		ldr	r2, [r0]
 729 028a A242     		cmp	r2, r4
 730 028c 02D1     		bne	.L76
 731              	.LVL84:
 732 028e D368     		ldr	r3, [r2, #12]
 733 0290 0360     		str	r3, [r0]
 734 0292 13E0     		b	.L77
 735              	.L76:
 736 0294 164B     		ldr	r3, .L84
 737 0296 1A60     		str	r2, [r3]
 738 0298 002A     		cmp	r2, #0
 739 029a 0FD0     		beq	.L77
 740 029c D368     		ldr	r3, [r2, #12]
 741 029e A342     		cmp	r3, r4
 742 02a0 05D0     		beq	.L78
 743 02a2 1A1C     		mov	r2, r3
 744 02a4 1249     		ldr	r1, .L84
 745 02a6 06E0     		b	.L79
 746              	.L81:
 747 02a8 D368     		ldr	r3, [r2, #12]
 748 02aa A342     		cmp	r3, r4
 749 02ac 02D1     		bne	.L80
 750              	.LVL85:
 751              	.L78:
 752 02ae E368     		ldr	r3, [r4, #12]
 753 02b0 D360     		str	r3, [r2, #12]
 754 02b2 03E0     		b	.L77
 755              	.LVL86:
 756              	.L80:
 757 02b4 1A1C     		mov	r2, r3
 758              	.L79:
 759 02b6 0A60     		str	r2, [r1]
 760 02b8 002A     		cmp	r2, #0
 761 02ba F5D1     		bne	.L81
 762              	.LVL87:
 763              	.L77:
 764 02bc 0023     		mov	r3, #0
 765 02be E360     		str	r3, [r4, #12]
 766              		.loc 1 1260 0
 767 02c0 201C     		mov	r0, r4
 768              	.LVL88:
 769 02c2 FFF7FEFF 		bl	tcp_pcb_purge
 770              		.loc 1 1263 0
 771 02c6 2369     		ldr	r3, [r4, #16]
 772 02c8 0A2B     		cmp	r3, #10
 773 02ca 0CD0     		beq	.L82
 774 02cc 012B     		cmp	r3, #1
 775 02ce 0AD0     		beq	.L82
 776 02d0 2623     		mov	r3, #38
 777 02d2 E25C     		ldrb	r2, [r4, r3]
 778 02d4 D307     		lsl	r3, r2, #31
 779 02d6 06D5     		bpl	.L82
 780              		.loc 1 1266 0
 781 02d8 0223     		mov	r3, #2
 782 02da 1A43     		orr	r2, r2, r3
 783 02dc 2623     		mov	r3, #38
 784 02de E254     		strb	r2, [r4, r3]
 785              		.loc 1 1267 0
 786 02e0 201C     		mov	r0, r4
 787 02e2 FFF7FEFF 		bl	tcp_output
 788              	.L82:
 789              		.loc 1 1278 0
 790 02e6 0023     		mov	r3, #0
 791 02e8 2361     		str	r3, [r4, #16]
 792              		.loc 1 1281 0
 793              		@ sp needed for prologue
 794              	.LVL89:
 795 02ea 10BC     		pop	{r4}
 796 02ec 01BC     		pop	{r0}
 797 02ee 0047     		bx	r0
 798              	.L85:
 799              		.align	2
 800              	.L84:
 801 02f0 00000000 		.word	tcp_tmp_pcb
 802              	.LFE318:
 804              		.global	__udivsi3
 805              		.align	2
 806              		.global	tcp_slowtmr
 807              		.code	16
 808              		.thumb_func
 810              	tcp_slowtmr:
 811              	.LFB300:
 812              		.loc 1 578 0
 813 02f4 F0B5     		push	{r4, r5, r6, r7, lr}
 814              	.LCFI10:
 815 02f6 5F46     		mov	r7, fp
 816 02f8 5646     		mov	r6, sl
 817 02fa 4D46     		mov	r5, r9
 818 02fc 4446     		mov	r4, r8
 819 02fe F0B4     		push	{r4, r5, r6, r7}
 820              	.LCFI11:
 821 0300 84B0     		sub	sp, sp, #16
 822              	.LCFI12:
 823              		.loc 1 587 0
 824 0302 AD4B     		ldr	r3, .L126
 825 0304 1A68     		ldr	r2, [r3]
 826 0306 0132     		add	r2, r2, #1
 827 0308 1A60     		str	r2, [r3]
 828              		.loc 1 591 0
 829 030a AC4B     		ldr	r3, .L126+4
 830 030c 1D68     		ldr	r5, [r3]
 831              	.LVL90:
 832              		.loc 1 595 0
 833 030e 002D     		cmp	r5, #0
 834 0310 00D1     		bne	.LCB750
 835 0312 24E1     		b	.L87	@long jump
 836              	.LCB750:
 837 0314 0020     		mov	r0, #0
 838 0316 8246     		mov	sl, r0
 839              	.LVL91:
 840              		.loc 1 608 0
 841 0318 4E21     		mov	r1, #78
 842 031a 8946     		mov	r9, r1
 843              		.loc 1 662 0
 844 031c A64A     		ldr	r2, .L126
 845 031e 0392     		str	r2, [sp, #12]
 846              		.loc 1 656 0
 847 0320 8046     		mov	r8, r0
 848              	.LVL92:
 849              		.loc 1 628 0
 850 0322 4C23     		mov	r3, #76
 851 0324 9B46     		mov	fp, r3
 852              		.loc 1 678 0
 853 0326 FA27     		mov	r7, #250
 854 0328 7F00     		lsl	r7, r7, #1
 855 032a 0297     		str	r7, [sp, #8]
 856              	.LVL93:
 857              	.L114:
 858              		.loc 1 604 0
 859 032c 2969     		ldr	r1, [r5, #16]
 860 032e 0229     		cmp	r1, #2
 861 0330 05D1     		bne	.L88
 862 0332 4846     		mov	r0, r9
 863 0334 2B5C     		ldrb	r3, [r5, r0]
 864 0336 042B     		cmp	r3, #4
 865 0338 01D1     		bne	.L88
 866 033a 0124     		mov	r4, #1
 867              	.LVL94:
 868 033c 6BE0     		b	.L89
 869              	.LVL95:
 870              	.L88:
 871              		.loc 1 608 0
 872 033e 4946     		mov	r1, r9
 873 0340 6B5C     		ldrb	r3, [r5, r1]
 874 0342 0C2B     		cmp	r3, #12
 875 0344 01D1     		bne	.L90
 876 0346 0124     		mov	r4, #1
 877              	.LVL96:
 878 0348 59E0     		b	.L91
 879              	.LVL97:
 880              	.L90:
 881              		.loc 1 612 0
 882 034a A422     		mov	r2, #164
 883 034c AB5C     		ldrb	r3, [r5, r2]
 884 034e 002B     		cmp	r3, #0
 885 0350 18D0     		beq	.L92
 886              		.loc 1 615 0
 887 0352 A023     		mov	r3, #160
 888 0354 E958     		ldr	r1, [r5, r3]
 889 0356 0131     		add	r1, r1, #1
 890 0358 E950     		str	r1, [r5, r3]
 891              		.loc 1 616 0
 892 035a 994B     		ldr	r3, .L126+8
 893 035c AA5C     		ldrb	r2, [r5, r2]
 894 035e 9B18     		add	r3, r3, r2
 895 0360 013B     		sub	r3, r3, #1
 896 0362 1B78     		ldrb	r3, [r3]
 897 0364 9942     		cmp	r1, r3
 898 0366 49D3     		bcc	.L93
 899              		.loc 1 617 0
 900 0368 A023     		mov	r3, #160
 901 036a 4746     		mov	r7, r8
 902 036c EF50     		str	r7, [r5, r3]
 903              		.loc 1 618 0
 904 036e A420     		mov	r0, #164
 905 0370 2B5C     		ldrb	r3, [r5, r0]
 906 0372 062B     		cmp	r3, #6
 907 0374 01D8     		bhi	.L94
 908              		.loc 1 619 0
 909 0376 0133     		add	r3, r3, #1
 910 0378 2B54     		strb	r3, [r5, r0]
 911              	.L94:
 912              		.loc 1 621 0
 913 037a 281C     		mov	r0, r5
 914 037c FFF7FEFF 		bl	tcp_zero_window_probe
 915 0380 4446     		mov	r4, r8
 916              	.LVL98:
 917 0382 3CE0     		b	.L91
 918              	.LVL99:
 919              	.L92:
 920              		.loc 1 625 0
 921 0384 6A8F     		ldrh	r2, [r5, #58]
 922 0386 1304     		lsl	r3, r2, #16
 923 0388 002B     		cmp	r3, #0
 924 038a 01DB     		blt	.L95
 925              		.loc 1 626 0
 926 038c 531C     		add	r3, r2, #1
 927 038e 6B87     		strh	r3, [r5, #58]
 928              	.L95:
 929              		.loc 1 628 0
 930 0390 EB6F     		ldr	r3, [r5, #124]
 931 0392 002B     		cmp	r3, #0
 932 0394 32D0     		beq	.L93
 933 0396 3A21     		mov	r1, #58
 934 0398 6A5E     		ldrsh	r2, [r5, r1]
 935 039a 5F46     		mov	r7, fp
 936 039c EB5F     		ldrsh	r3, [r5, r7]
 937 039e 9A42     		cmp	r2, r3
 938 03a0 2CDB     		blt	.L93
 939              		.loc 1 636 0
 940 03a2 2B69     		ldr	r3, [r5, #16]
 941 03a4 022B     		cmp	r3, #2
 942 03a6 0CD0     		beq	.L96
 943              		.loc 1 637 0
 944 03a8 4823     		mov	r3, #72
 945 03aa EB5E     		ldrsh	r3, [r5, r3]
 946 03ac DB10     		asr	r3, r3, #3
 947 03ae 4A22     		mov	r2, #74
 948 03b0 AA5E     		ldrsh	r2, [r5, r2]
 949 03b2 9B18     		add	r3, r3, r2
 950 03b4 8349     		ldr	r1, .L126+12
 951 03b6 4846     		mov	r0, r9
 952 03b8 2A5C     		ldrb	r2, [r5, r0]
 953 03ba 8A5C     		ldrb	r2, [r1, r2]
 954 03bc 9340     		lsl	r3, r3, r2
 955 03be 5946     		mov	r1, fp
 956 03c0 6B52     		strh	r3, [r5, r1]
 957              	.L96:
 958              		.loc 1 641 0
 959 03c2 4246     		mov	r2, r8
 960              	.LVL100:
 961 03c4 6A87     		strh	r2, [r5, #58]
 962              		.loc 1 645 0
 963 03c6 6023     		mov	r3, #96
 964 03c8 E85A     		ldrh	r0, [r5, r3]
 965 03ca 5627     		mov	r7, #86
 966 03cc E95B     		ldrh	r1, [r5, r7]
 967 03ce 0A04     		lsl	r2, r1, #16
 968 03d0 0304     		lsl	r3, r0, #16
 969 03d2 9342     		cmp	r3, r2
 970 03d4 00D2     		bcs	.L97
 971 03d6 011C     		add	r1, r0, #0
 972              	.L97:
 973 03d8 0B04     		lsl	r3, r1, #16
 974 03da 5B0C     		lsr	r3, r3, #17
 975 03dc 5822     		mov	r2, #88
 976 03de AB52     		strh	r3, [r5, r2]
 977              		.loc 1 646 0
 978 03e0 AA8F     		ldrh	r2, [r5, #60]
 979 03e2 9342     		cmp	r3, r2
 980 03e4 02D2     		bcs	.L98
 981              		.loc 1 647 0
 982 03e6 5200     		lsl	r2, r2, #1
 983 03e8 5823     		mov	r3, #88
 984 03ea EA52     		strh	r2, [r5, r3]
 985              	.L98:
 986              		.loc 1 649 0
 987 03ec AB8F     		ldrh	r3, [r5, #60]
 988 03ee 5620     		mov	r0, #86
 989 03f0 2B52     		strh	r3, [r5, r0]
 990              		.loc 1 656 0
 991 03f2 281C     		mov	r0, r5
 992 03f4 FFF7FEFF 		bl	tcp_rexmit_rto
 993 03f8 4446     		mov	r4, r8
 994              	.LVL101:
 995 03fa 00E0     		b	.L91
 996              	.LVL102:
 997              	.L93:
 998 03fc 4446     		mov	r4, r8
 999              	.LVL103:
 1000              	.L91:
 1001              		.loc 1 661 0
 1002 03fe 2969     		ldr	r1, [r5, #16]
 1003 0400 0629     		cmp	r1, #6
 1004 0402 08D1     		bne	.L89
 1005              		.loc 1 662 0
 1006 0404 039A     		ldr	r2, [sp, #12]
 1007 0406 1368     		ldr	r3, [r2]
 1008 0408 6A6B     		ldr	r2, [r5, #52]
 1009 040a 9B1A     		sub	r3, r3, r2
 1010 040c 282B     		cmp	r3, #40
 1011 040e 02D9     		bls	.L89
 1012              		.loc 1 664 0
 1013 0410 631C     		add	r3, r4, #1
 1014 0412 1B06     		lsl	r3, r3, #24
 1015 0414 1C0E     		lsr	r4, r3, #24
 1016              	.LVL104:
 1017              	.L89:
 1018              		.loc 1 670 0
 1019 0416 2B89     		ldrh	r3, [r5, #8]
 1020 0418 1F07     		lsl	r7, r3, #28
 1021 041a 29D5     		bpl	.L99
 1022 041c 0429     		cmp	r1, #4
 1023 041e 01D0     		beq	.L123
 1024 0420 0729     		cmp	r1, #7
 1025 0422 25D1     		bne	.L99
 1026              	.L123:
 1027              		.loc 1 678 0
 1028 0424 644B     		ldr	r3, .L126
 1029 0426 1A68     		ldr	r2, [r3]
 1030 0428 6B6B     		ldr	r3, [r5, #52]
 1031 042a D71A     		sub	r7, r2, r3
 1032 042c 9C23     		mov	r3, #156
 1033 042e EE58     		ldr	r6, [r5, r3]
 1034              	.LVL105:
 1035 0430 6549     		ldr	r1, .L126+16
 1036 0432 7018     		add	r0, r6, r1
 1037 0434 0299     		ldr	r1, [sp, #8]
 1038 0436 FFF7FEFF 		bl	__udivsi3
 1039 043a 8742     		cmp	r7, r0
 1040 043c 04D9     		bls	.L101
 1041              		.loc 1 686 0
 1042 043e 631C     		add	r3, r4, #1
 1043 0440 1B06     		lsl	r3, r3, #24
 1044 0442 1C0E     		lsr	r4, r3, #24
 1045              	.LVL106:
 1046 0444 0126     		mov	r6, #1
 1047              	.LVL107:
 1048 0446 14E0     		b	.L102
 1049              	.LVL108:
 1050              	.L101:
 1051              		.loc 1 694 0
 1052 0448 A523     		mov	r3, #165
 1053 044a EA5C     		ldrb	r2, [r5, r3]
 1054 044c 5F4B     		ldr	r3, .L126+20
 1055 044e 181C     		mov	r0, r3
 1056 0450 5043     		mul	r0, r2
 1057 0452 8019     		add	r0, r0, r6
 1058 0454 0299     		ldr	r1, [sp, #8]
 1059 0456 FFF7FEFF 		bl	__udivsi3
 1060 045a 8742     		cmp	r7, r0
 1061 045c 08D9     		bls	.L99
 1062              		.loc 1 699 0
 1063 045e 281C     		mov	r0, r5
 1064 0460 FFF7FEFF 		bl	tcp_keepalive
 1065              		.loc 1 700 0
 1066 0464 A522     		mov	r2, #165
 1067 0466 AB5C     		ldrb	r3, [r5, r2]
 1068 0468 0133     		add	r3, r3, #1
 1069 046a AB54     		strb	r3, [r5, r2]
 1070 046c 4646     		mov	r6, r8
 1071              	.LVL109:
 1072 046e 00E0     		b	.L102
 1073              	.L99:
 1074 0470 4646     		mov	r6, r8
 1075              	.L102:
 1076              		.loc 1 708 0
 1077 0472 8023     		mov	r3, #128
 1078 0474 E858     		ldr	r0, [r5, r3]
 1079 0476 0028     		cmp	r0, #0
 1080 0478 0FD0     		beq	.L103
 1081 047a 4F4B     		ldr	r3, .L126
 1082 047c 1968     		ldr	r1, [r3]
 1083 047e 6B6B     		ldr	r3, [r5, #52]
 1084 0480 C91A     		sub	r1, r1, r3
 1085 0482 5B46     		mov	r3, fp
 1086 0484 EA5E     		ldrsh	r2, [r5, r3]
 1087 0486 5300     		lsl	r3, r2, #1
 1088 0488 9B18     		add	r3, r3, r2
 1089 048a 5B00     		lsl	r3, r3, #1
 1090 048c 9942     		cmp	r1, r3
 1091 048e 04D3     		bcc	.L103
 1092              		.loc 1 710 0
 1093 0490 FFF7FEFF 		bl	tcp_segs_free
 1094              		.loc 1 711 0
 1095 0494 8023     		mov	r3, #128
 1096 0496 4046     		mov	r0, r8
 1097 0498 E850     		str	r0, [r5, r3]
 1098              	.L103:
 1099              		.loc 1 717 0
 1100 049a 2969     		ldr	r1, [r5, #16]
 1101 049c 0329     		cmp	r1, #3
 1102 049e 09D1     		bne	.L104
 1103              		.loc 1 718 0
 1104 04a0 454B     		ldr	r3, .L126
 1105 04a2 1B68     		ldr	r3, [r3]
 1106 04a4 6A6B     		ldr	r2, [r5, #52]
 1107 04a6 9B1A     		sub	r3, r3, r2
 1108 04a8 282B     		cmp	r3, #40
 1109 04aa 03D9     		bls	.L104
 1110              		.loc 1 720 0
 1111 04ac 631C     		add	r3, r4, #1
 1112 04ae 1B06     		lsl	r3, r3, #24
 1113 04b0 1C0E     		lsr	r4, r3, #24
 1114              	.LVL110:
 1115 04b2 0AE0     		b	.L105
 1116              	.LVL111:
 1117              	.L104:
 1118              		.loc 1 726 0
 1119 04b4 0929     		cmp	r1, #9
 1120 04b6 08D1     		bne	.L105
 1121              		.loc 1 727 0
 1122 04b8 3F4B     		ldr	r3, .L126
 1123 04ba 1B68     		ldr	r3, [r3]
 1124 04bc 6A6B     		ldr	r2, [r5, #52]
 1125 04be 9B1A     		sub	r3, r3, r2
 1126 04c0 F02B     		cmp	r3, #240
 1127 04c2 02D9     		bls	.L105
 1128              		.loc 1 728 0
 1129 04c4 631C     		add	r3, r4, #1
 1130 04c6 1B06     		lsl	r3, r3, #24
 1131 04c8 1C0E     		lsr	r4, r3, #24
 1132              	.LVL112:
 1133              	.L105:
 1134              		.loc 1 734 0
 1135 04ca 002C     		cmp	r4, #0
 1136 04cc 26D0     		beq	.L106
 1137              		.loc 1 735 0
 1138 04ce 281C     		mov	r0, r5
 1139 04d0 FFF7FEFF 		bl	tcp_pcb_purge
 1140              		.loc 1 737 0
 1141 04d4 5146     		mov	r1, sl
 1142 04d6 0029     		cmp	r1, #0
 1143 04d8 02D0     		beq	.L107
 1144              		.loc 1 739 0
 1145 04da EB68     		ldr	r3, [r5, #12]
 1146 04dc CB60     		str	r3, [r1, #12]
 1147 04de 02E0     		b	.L108
 1148              	.L107:
 1149              		.loc 1 743 0
 1150 04e0 364A     		ldr	r2, .L126+4
 1151 04e2 EB68     		ldr	r3, [r5, #12]
 1152 04e4 1360     		str	r3, [r2]
 1153              	.L108:
 1154              		.loc 1 746 0
 1155 04e6 9823     		mov	r3, #152
 1156 04e8 EB58     		ldr	r3, [r5, r3]
 1157 04ea 002B     		cmp	r3, #0
 1158 04ec 04D0     		beq	.L109
 1159 04ee A869     		ldr	r0, [r5, #24]
 1160 04f0 0521     		mov	r1, #5
 1161 04f2 4942     		neg	r1, r1
 1162 04f4 00F0B2FB 		bl	.L128
 1163              	.L109:
 1164              		.loc 1 747 0
 1165 04f8 002E     		cmp	r6, #0
 1166 04fa 09D0     		beq	.L110
 1167              		.loc 1 748 0
 1168 04fc E86D     		ldr	r0, [r5, #92]
 1169 04fe A96A     		ldr	r1, [r5, #40]
 1170 0500 2B1D     		add	r3, r5, #4
 1171 0502 AA8B     		ldrh	r2, [r5, #28]
 1172 0504 0092     		str	r2, [sp]
 1173 0506 AA8C     		ldrh	r2, [r5, #36]
 1174 0508 0192     		str	r2, [sp, #4]
 1175 050a 2A1C     		mov	r2, r5
 1176 050c FFF7FEFF 		bl	tcp_rst
 1177              	.L110:
 1178              		.loc 1 752 0
 1179 0510 EC68     		ldr	r4, [r5, #12]
 1180              	.LVL113:
 1181              		.loc 1 753 0
 1182 0512 0220     		mov	r0, #2
 1183 0514 291C     		mov	r1, r5
 1184 0516 FFF7FEFF 		bl	memp_free
 1185 051a 1CE0     		b	.L111
 1186              	.LVL114:
 1187              	.L106:
 1188              		.loc 1 758 0
 1189 051c 3822     		mov	r2, #56
 1190 051e AB5C     		ldrb	r3, [r5, r2]
 1191 0520 0133     		add	r3, r3, #1
 1192 0522 1B06     		lsl	r3, r3, #24
 1193 0524 1B0E     		lsr	r3, r3, #24
 1194 0526 AB54     		strb	r3, [r5, r2]
 1195              		.loc 1 759 0
 1196 0528 3922     		mov	r2, #57
 1197 052a AA5C     		ldrb	r2, [r5, r2]
 1198 052c 9A42     		cmp	r2, r3
 1199 052e 10D8     		bhi	.L112
 1200              		.loc 1 760 0
 1201 0530 3823     		mov	r3, #56
 1202 0532 4246     		mov	r2, r8
 1203 0534 EA54     		strb	r2, [r5, r3]
 1204              		.loc 1 762 0
 1205 0536 9423     		mov	r3, #148
 1206 0538 EB58     		ldr	r3, [r5, r3]
 1207 053a 002B     		cmp	r3, #0
 1208 053c 06D0     		beq	.L113
 1209 053e A869     		ldr	r0, [r5, #24]
 1210 0540 291C     		mov	r1, r5
 1211 0542 00F08BFB 		bl	.L128
 1212 0546 0006     		lsl	r0, r0, #24
 1213              		.loc 1 763 0
 1214 0548 0028     		cmp	r0, #0
 1215 054a 02D1     		bne	.L112
 1216              	.L113:
 1217              		.loc 1 764 0
 1218 054c 281C     		mov	r0, r5
 1219 054e FFF7FEFF 		bl	tcp_output
 1220              	.LVL115:
 1221              	.L112:
 1222              		.loc 1 769 0
 1223 0552 EC68     		ldr	r4, [r5, #12]
 1224              	.LVL116:
 1225 0554 AA46     		mov	sl, r5
 1226              	.LVL117:
 1227              	.L111:
 1228              		.loc 1 595 0
 1229 0556 002C     		cmp	r4, #0
 1230 0558 01D0     		beq	.L87
 1231              	.LVL118:
 1232 055a 251C     		mov	r5, r4
 1233 055c E6E6     		b	.L114
 1234              	.LVL119:
 1235              	.L87:
 1236              		.loc 1 776 0
 1237 055e 1C4B     		ldr	r3, .L126+24
 1238 0560 1D68     		ldr	r5, [r3]
 1239              	.LVL120:
 1240              		.loc 1 777 0
 1241 0562 002D     		cmp	r5, #0
 1242 0564 1FD0     		beq	.L122
 1243 0566 0026     		mov	r6, #0
 1244              	.LVL121:
 1245              		.loc 1 782 0
 1246 0568 134F     		ldr	r7, .L126
 1247              		.loc 1 798 0
 1248 056a 9846     		mov	r8, r3
 1249              	.LVL122:
 1250              	.L119:
 1251              		.loc 1 782 0
 1252 056c 3B68     		ldr	r3, [r7]
 1253 056e 6A6B     		ldr	r2, [r5, #52]
 1254 0570 9B1A     		sub	r3, r3, r2
 1255 0572 F02B     		cmp	r3, #240
 1256 0574 11D8     		bhi	.L116
 1257              		.loc 1 805 0
 1258 0576 EC68     		ldr	r4, [r5, #12]
 1259              	.LVL123:
 1260 0578 2E1C     		mov	r6, r5
 1261 057a 0AE0     		b	.L117
 1262              	.LVL124:
 1263              	.L120:
 1264              		.loc 1 794 0
 1265 057c EB68     		ldr	r3, [r5, #12]
 1266 057e F360     		str	r3, [r6, #12]
 1267 0580 02E0     		b	.L118
 1268              	.L125:
 1269              		.loc 1 798 0
 1270 0582 EB68     		ldr	r3, [r5, #12]
 1271 0584 4046     		mov	r0, r8
 1272 0586 0360     		str	r3, [r0]
 1273              	.L118:
 1274              		.loc 1 800 0
 1275 0588 EC68     		ldr	r4, [r5, #12]
 1276              	.LVL125:
 1277              		.loc 1 801 0
 1278 058a 0220     		mov	r0, #2
 1279 058c 291C     		mov	r1, r5
 1280 058e FFF7FEFF 		bl	memp_free
 1281              	.LVL126:
 1282              	.L117:
 1283              		.loc 1 777 0
 1284 0592 002C     		cmp	r4, #0
 1285 0594 07D0     		beq	.L122
 1286              	.LVL127:
 1287 0596 251C     		mov	r5, r4
 1288 0598 E8E7     		b	.L119
 1289              	.LVL128:
 1290              	.L116:
 1291              		.loc 1 790 0
 1292 059a 281C     		mov	r0, r5
 1293 059c FFF7FEFF 		bl	tcp_pcb_purge
 1294              		.loc 1 792 0
 1295 05a0 002E     		cmp	r6, #0
 1296 05a2 EBD1     		bne	.L120
 1297 05a4 EDE7     		b	.L125
 1298              	.LVL129:
 1299              	.L122:
 1300              		.loc 1 808 0
 1301 05a6 04B0     		add	sp, sp, #16
 1302              		@ sp needed for prologue
 1303              	.LVL130:
 1304              	.LVL131:
 1305              	.LVL132:
 1306              	.LVL133:
 1307              	.LVL134:
 1308 05a8 3CBC     		pop	{r2, r3, r4, r5}
 1309 05aa 9046     		mov	r8, r2
 1310 05ac 9946     		mov	r9, r3
 1311 05ae A246     		mov	sl, r4
 1312 05b0 AB46     		mov	fp, r5
 1313 05b2 F0BC     		pop	{r4, r5, r6, r7}
 1314 05b4 01BC     		pop	{r0}
 1315 05b6 0047     		bx	r0
 1316              	.L127:
 1317              		.align	2
 1318              	.L126:
 1319 05b8 00000000 		.word	tcp_ticks
 1320 05bc 00000000 		.word	tcp_active_pcbs
 1321 05c0 00000000 		.word	tcp_persist_backoff
 1322 05c4 00000000 		.word	tcp_backoff
 1323 05c8 B84C0A00 		.word	675000
 1324 05cc F8240100 		.word	75000
 1325 05d0 00000000 		.word	tcp_tw_pcbs
 1326              	.LFE300:
 1328              		.align	2
 1329              		.global	tcp_abandon
 1330              		.code	16
 1331              		.thumb_func
 1333              	tcp_abandon:
 1334              	.LFB292:
 1335              		.loc 1 214 0
 1336 05d4 F0B5     		push	{r4, r5, r6, r7, lr}
 1337              	.LCFI13:
 1338 05d6 5F46     		mov	r7, fp
 1339 05d8 5646     		mov	r6, sl
 1340 05da 4D46     		mov	r5, r9
 1341 05dc 4446     		mov	r4, r8
 1342 05de F0B4     		push	{r4, r5, r6, r7}
 1343              	.LCFI14:
 1344              	.LVL135:
 1345 05e0 84B0     		sub	sp, sp, #16
 1346              	.LCFI15:
 1347 05e2 041C     		mov	r4, r0
 1348 05e4 0F1C     		mov	r7, r1
 1349              		.loc 1 227 0
 1350 05e6 0369     		ldr	r3, [r0, #16]
 1351 05e8 0A2B     		cmp	r3, #10
 1352 05ea 08D1     		bne	.L130
 1353              	.LVL136:
 1354              		.loc 1 228 0
 1355 05ec 2948     		ldr	r0, .L141
 1356              	.LVL137:
 1357 05ee 211C     		mov	r1, r4
 1358 05f0 FFF7FEFF 		bl	tcp_pcb_remove
 1359              		.loc 1 229 0
 1360 05f4 0220     		mov	r0, #2
 1361 05f6 211C     		mov	r1, r4
 1362 05f8 FFF7FEFF 		bl	memp_free
 1363 05fc 41E0     		b	.L140
 1364              	.LVL138:
 1365              	.L130:
 1366              		.loc 1 231 0
 1367 05fe C36D     		ldr	r3, [r0, #92]
 1368 0600 9B46     		mov	fp, r3
 1369              	.LVL139:
 1370              		.loc 1 232 0
 1371 0602 836A     		ldr	r3, [r0, #40]
 1372 0604 9946     		mov	r9, r3
 1373              	.LVL140:
 1374              		.loc 1 233 0
 1375 0606 0028     		cmp	r0, #0
 1376 0608 01D1     		bne	.L132
 1377 060a 0023     		mov	r3, #0
 1378 060c 00E0     		b	.L133
 1379              	.L132:
 1380 060e 0368     		ldr	r3, [r0]
 1381              	.L133:
 1382 0610 0293     		str	r3, [sp, #8]
 1383              		.loc 1 234 0
 1384 0612 231D     		add	r3, r4, #4
 1385 0614 01D1     		bne	.L134
 1386              	.LVL141:
 1387 0616 0023     		mov	r3, #0
 1388 0618 00E0     		b	.L135
 1389              	.L134:
 1390 061a 6368     		ldr	r3, [r4, #4]
 1391              	.L135:
 1392 061c 0393     		str	r3, [sp, #12]
 1393              		.loc 1 235 0
 1394 061e A38B     		ldrh	r3, [r4, #28]
 1395 0620 9846     		mov	r8, r3
 1396              	.LVL142:
 1397              		.loc 1 236 0
 1398 0622 A38C     		ldrh	r3, [r4, #36]
 1399 0624 9A46     		mov	sl, r3
 1400              	.LVL143:
 1401              		.loc 1 238 0
 1402 0626 9823     		mov	r3, #152
 1403 0628 E558     		ldr	r5, [r4, r3]
 1404              	.LVL144:
 1405              		.loc 1 240 0
 1406 062a A669     		ldr	r6, [r4, #24]
 1407              	.LVL145:
 1408              		.loc 1 241 0
 1409 062c 1A48     		ldr	r0, .L141+4
 1410 062e 211C     		mov	r1, r4
 1411 0630 FFF7FEFF 		bl	tcp_pcb_remove
 1412              		.loc 1 242 0
 1413 0634 E06F     		ldr	r0, [r4, #124]
 1414 0636 0028     		cmp	r0, #0
 1415 0638 01D0     		beq	.L136
 1416              		.loc 1 243 0
 1417 063a FFF7FEFF 		bl	tcp_segs_free
 1418              	.L136:
 1419              		.loc 1 245 0
 1420 063e A06F     		ldr	r0, [r4, #120]
 1421 0640 0028     		cmp	r0, #0
 1422 0642 01D0     		beq	.L137
 1423              		.loc 1 246 0
 1424 0644 FFF7FEFF 		bl	tcp_segs_free
 1425              	.L137:
 1426              		.loc 1 249 0
 1427 0648 8023     		mov	r3, #128
 1428 064a E058     		ldr	r0, [r4, r3]
 1429 064c 0028     		cmp	r0, #0
 1430 064e 01D0     		beq	.L138
 1431              		.loc 1 250 0
 1432 0650 FFF7FEFF 		bl	tcp_segs_free
 1433              	.L138:
 1434              		.loc 1 253 0
 1435 0654 0220     		mov	r0, #2
 1436 0656 211C     		mov	r1, r4
 1437 0658 FFF7FEFF 		bl	memp_free
 1438              		.loc 1 254 0
 1439 065c 002D     		cmp	r5, #0
 1440 065e 04D0     		beq	.L139
 1441 0660 0521     		mov	r1, #5
 1442 0662 4942     		neg	r1, r1
 1443 0664 301C     		mov	r0, r6
 1444 0666 00F0FAFA 		bl	.L143
 1445              	.L139:
 1446              		.loc 1 255 0
 1447 066a 002F     		cmp	r7, #0
 1448 066c 09D0     		beq	.L140
 1449              		.loc 1 257 0
 1450 066e 4346     		mov	r3, r8
 1451 0670 0093     		str	r3, [sp]
 1452 0672 5346     		mov	r3, sl
 1453 0674 0193     		str	r3, [sp, #4]
 1454 0676 5846     		mov	r0, fp
 1455 0678 4946     		mov	r1, r9
 1456 067a 02AA     		add	r2, sp, #8
 1457 067c 03AB     		add	r3, sp, #12
 1458 067e FFF7FEFF 		bl	tcp_rst
 1459              	.L140:
 1460              		.loc 1 260 0
 1461 0682 04B0     		add	sp, sp, #16
 1462              		@ sp needed for prologue
 1463              	.LVL146:
 1464              	.LVL147:
 1465              	.LVL148:
 1466              	.LVL149:
 1467              	.LVL150:
 1468              	.LVL151:
 1469              	.LVL152:
 1470              	.LVL153:
 1471 0684 3CBC     		pop	{r2, r3, r4, r5}
 1472 0686 9046     		mov	r8, r2
 1473 0688 9946     		mov	r9, r3
 1474 068a A246     		mov	sl, r4
 1475 068c AB46     		mov	fp, r5
 1476 068e F0BC     		pop	{r4, r5, r6, r7}
 1477 0690 01BC     		pop	{r0}
 1478 0692 0047     		bx	r0
 1479              	.L142:
 1480              		.align	2
 1481              	.L141:
 1482 0694 00000000 		.word	tcp_tw_pcbs
 1483 0698 00000000 		.word	tcp_active_pcbs
 1484              	.LFE292:
 1486              		.align	2
 1487              		.global	tcp_alloc
 1488              		.code	16
 1489              		.thumb_func
 1491              	tcp_alloc:
 1492              	.LFB309:
 1493              		.loc 1 1006 0
 1494 069c F0B5     		push	{r4, r5, r6, r7, lr}
 1495              	.LCFI16:
 1496              	.LVL154:
 1497 069e 0006     		lsl	r0, r0, #24
 1498              	.LVL155:
 1499 06a0 060E     		lsr	r6, r0, #24
 1500              	.LVL156:
 1501              		.loc 1 1010 0
 1502 06a2 0220     		mov	r0, #2
 1503 06a4 FFF7FEFF 		bl	memp_malloc
 1504 06a8 051C     		mov	r5, r0
 1505              	.LVL157:
 1506              		.loc 1 1011 0
 1507 06aa 0028     		cmp	r0, #0
 1508 06ac 4ED1     		bne	.L145
 1509              	.LVL158:
 1510              	.LBB6:
 1511              	.LBB7:
 1512              		.loc 1 985 0
 1513 06ae 434B     		ldr	r3, .L159
 1514 06b0 1968     		ldr	r1, [r3]
 1515              	.LVL159:
 1516 06b2 0029     		cmp	r1, #0
 1517 06b4 14D0     		beq	.L146
 1518              		.loc 1 986 0
 1519 06b6 424B     		ldr	r3, .L159+4
 1520 06b8 1C68     		ldr	r4, [r3]
 1521 06ba 0022     		mov	r2, #0
 1522              	.LVL160:
 1523 06bc 0020     		mov	r0, #0
 1524              	.LVL161:
 1525              	.L150:
 1526 06be 4B6B     		ldr	r3, [r1, #52]
 1527 06c0 E31A     		sub	r3, r4, r3
 1528              	.LVL162:
 1529 06c2 9342     		cmp	r3, r2
 1530 06c4 01D3     		bcc	.L147
 1531              	.LVL163:
 1532 06c6 081C     		mov	r0, r1
 1533 06c8 00E0     		b	.L148
 1534              	.L147:
 1535 06ca 131C     		mov	r3, r2
 1536              	.LVL164:
 1537              	.L148:
 1538              		.loc 1 985 0
 1539 06cc C968     		ldr	r1, [r1, #12]
 1540 06ce 0029     		cmp	r1, #0
 1541 06d0 01D0     		beq	.L149
 1542 06d2 1A1C     		mov	r2, r3
 1543 06d4 F3E7     		b	.L150
 1544              	.L149:
 1545              		.loc 1 991 0
 1546 06d6 0028     		cmp	r0, #0
 1547 06d8 02D0     		beq	.L146
 1548              	.LVL165:
 1549              		.loc 1 994 0
 1550 06da 0121     		mov	r1, #1
 1551 06dc FFF7FEFF 		bl	tcp_abandon
 1552              	.LVL166:
 1553              	.L146:
 1554              	.LBE7:
 1555              	.LBE6:
 1556              		.loc 1 1016 0
 1557 06e0 0220     		mov	r0, #2
 1558 06e2 FFF7FEFF 		bl	memp_malloc
 1559              	.LVL167:
 1560 06e6 051C     		mov	r5, r0
 1561              		.loc 1 1017 0
 1562 06e8 0028     		cmp	r0, #0
 1563 06ea 2AD1     		bne	.L151
 1564              	.LVL168:
 1565              	.LBB8:
 1566              	.LBB9:
 1567              		.loc 1 956 0
 1568 06ec 354B     		ldr	r3, .L159+8
 1569 06ee 1968     		ldr	r1, [r3]
 1570              	.LVL169:
 1571 06f0 0029     		cmp	r1, #0
 1572 06f2 1BD0     		beq	.L152
 1573              		.loc 1 957 0
 1574 06f4 324B     		ldr	r3, .L159+4
 1575 06f6 1F68     		ldr	r7, [r3]
 1576 06f8 7F24     		mov	r4, #127
 1577              	.LVL170:
 1578 06fa 0020     		mov	r0, #0
 1579              	.LVL171:
 1580              	.L156:
 1581 06fc 0A7D     		ldrb	r2, [r1, #20]
 1582              	.LVL172:
 1583 06fe 9642     		cmp	r6, r2
 1584 0700 07D3     		bcc	.L153
 1585              	.LVL173:
 1586 0702 A242     		cmp	r2, r4
 1587 0704 05D8     		bhi	.L153
 1588              	.LVL174:
 1589 0706 4B6B     		ldr	r3, [r1, #52]
 1590 0708 FB1A     		sub	r3, r7, r3
 1591              	.LVL175:
 1592 070a 9D42     		cmp	r5, r3
 1593 070c 01D8     		bhi	.L153
 1594 070e 081C     		mov	r0, r1
 1595 0710 01E0     		b	.L154
 1596              	.LVL176:
 1597              	.L153:
 1598 0712 221C     		mov	r2, r4
 1599 0714 2B1C     		mov	r3, r5
 1600              	.LVL177:
 1601              	.L154:
 1602              		.loc 1 956 0
 1603 0716 C968     		ldr	r1, [r1, #12]
 1604 0718 0029     		cmp	r1, #0
 1605 071a 02D0     		beq	.L155
 1606 071c 141C     		mov	r4, r2
 1607 071e 1D1C     		mov	r5, r3
 1608              	.LVL178:
 1609 0720 ECE7     		b	.L156
 1610              	.LVL179:
 1611              	.L155:
 1612              		.loc 1 965 0
 1613 0722 0028     		cmp	r0, #0
 1614 0724 02D0     		beq	.L152
 1615              	.LVL180:
 1616              		.loc 1 968 0
 1617 0726 0121     		mov	r1, #1
 1618 0728 FFF7FEFF 		bl	tcp_abandon
 1619              	.LVL181:
 1620              	.L152:
 1621              	.LBE9:
 1622              	.LBE8:
 1623              		.loc 1 1022 0
 1624 072c 0220     		mov	r0, #2
 1625 072e FFF7FEFF 		bl	memp_malloc
 1626              	.LVL182:
 1627 0732 051C     		mov	r5, r0
 1628              	.LVL183:
 1629              		.loc 1 1023 0
 1630 0734 0028     		cmp	r0, #0
 1631 0736 3CD0     		beq	.L157
 1632              	.LVL184:
 1633              		.loc 1 1025 0
 1634 0738 2349     		ldr	r1, .L159+12
 1635 073a D222     		mov	r2, #210
 1636 073c 8B5A     		ldrh	r3, [r1, r2]
 1637 073e 013B     		sub	r3, r3, #1
 1638 0740 8B52     		strh	r3, [r1, r2]
 1639              	.L151:
 1640              		.loc 1 1030 0
 1641 0742 2149     		ldr	r1, .L159+12
 1642 0744 D222     		mov	r2, #210
 1643 0746 8B5A     		ldrh	r3, [r1, r2]
 1644 0748 013B     		sub	r3, r3, #1
 1645 074a 8B52     		strh	r3, [r1, r2]
 1646              	.L145:
 1647              		.loc 1 1034 0
 1648 074c 281C     		mov	r0, r5
 1649              	.LVL185:
 1650 074e 0021     		mov	r1, #0
 1651 0750 A822     		mov	r2, #168
 1652 0752 FFF7FEFF 		bl	memset
 1653              		.loc 1 1035 0
 1654 0756 4023     		mov	r3, #64
 1655 0758 2B75     		strb	r3, [r5, #20]
 1656              		.loc 1 1036 0
 1657 075a 8022     		mov	r2, #128
 1658 075c 9200     		lsl	r2, r2, #2
 1659 075e 7223     		mov	r3, #114
 1660 0760 EA52     		strh	r2, [r5, r3]
 1661              		.loc 1 1037 0
 1662 0762 0024     		mov	r4, #0
 1663              	.LVL186:
 1664 0764 7423     		mov	r3, #116
 1665 0766 EC52     		strh	r4, [r5, r3]
 1666              		.loc 1 1038 0
 1667 0768 AA85     		strh	r2, [r5, #44]
 1668              		.loc 1 1039 0
 1669 076a EA85     		strh	r2, [r5, #46]
 1670              		.loc 1 1040 0
 1671 076c AC72     		strb	r4, [r5, #10]
 1672              		.loc 1 1041 0
 1673 076e 0121     		mov	r1, #1
 1674 0770 4942     		neg	r1, r1
 1675 0772 E972     		strb	r1, [r5, #11]
 1676              		.loc 1 1044 0
 1677 0774 AA87     		strh	r2, [r5, #60]
 1678              		.loc 1 1045 0
 1679 0776 0622     		mov	r2, #6
 1680 0778 4C23     		mov	r3, #76
 1681 077a EA52     		strh	r2, [r5, r3]
 1682              		.loc 1 1046 0
 1683 077c 4823     		mov	r3, #72
 1684 077e EC52     		strh	r4, [r5, r3]
 1685              		.loc 1 1047 0
 1686 0780 4A23     		mov	r3, #74
 1687 0782 EA52     		strh	r2, [r5, r3]
 1688              		.loc 1 1048 0
 1689 0784 6987     		strh	r1, [r5, #58]
 1690              		.loc 1 1049 0
 1691 0786 0122     		mov	r2, #1
 1692 0788 5623     		mov	r3, #86
 1693 078a EA52     		strh	r2, [r5, r3]
 1694              		.loc 1 1050 0
 1695 078c FFF7FEFF 		bl	tcp_next_iss
 1696              		.loc 1 1051 0
 1697 0790 A866     		str	r0, [r5, #104]
 1698              	.LVL187:
 1699              		.loc 1 1052 0
 1700 0792 E865     		str	r0, [r5, #92]
 1701              		.loc 1 1053 0
 1702 0794 2865     		str	r0, [r5, #80]
 1703              		.loc 1 1054 0
 1704 0796 E866     		str	r0, [r5, #108]
 1705              		.loc 1 1055 0
 1706 0798 094B     		ldr	r3, .L159+4
 1707 079a 1B68     		ldr	r3, [r3]
 1708 079c 6B63     		str	r3, [r5, #52]
 1709              		.loc 1 1057 0
 1710 079e 3823     		mov	r3, #56
 1711 07a0 EC54     		strb	r4, [r5, r3]
 1712              		.loc 1 1060 0
 1713 07a2 0A4A     		ldr	r2, .L159+16
 1714 07a4 8C23     		mov	r3, #140
 1715 07a6 EA50     		str	r2, [r5, r3]
 1716              		.loc 1 1064 0
 1717 07a8 094A     		ldr	r2, .L159+20
 1718 07aa 9C23     		mov	r3, #156
 1719 07ac EA50     		str	r2, [r5, r3]
 1720              		.loc 1 1071 0
 1721 07ae A523     		mov	r3, #165
 1722 07b0 EC54     		strb	r4, [r5, r3]
 1723              	.LVL188:
 1724              	.L157:
 1725              		.loc 1 1074 0
 1726 07b2 281C     		mov	r0, r5
 1727              	.LVL189:
 1728              		@ sp needed for prologue
 1729              	.LVL190:
 1730              	.LVL191:
 1731              	.LVL192:
 1732 07b4 F0BC     		pop	{r4, r5, r6, r7}
 1733 07b6 02BC     		pop	{r1}
 1734 07b8 0847     		bx	r1
 1735              	.L160:
 1736 07ba C046     		.align	2
 1737              	.L159:
 1738 07bc 00000000 		.word	tcp_tw_pcbs
 1739 07c0 00000000 		.word	tcp_ticks
 1740 07c4 00000000 		.word	tcp_active_pcbs
 1741 07c8 00000000 		.word	lwip_stats
 1742 07cc 00000000 		.word	tcp_recv_null
 1743 07d0 00DD6D00 		.word	7200000
 1744              	.LFE309:
 1746              		.align	2
 1747              		.global	tcp_new
 1748              		.code	16
 1749              		.thumb_func
 1751              	tcp_new:
 1752              	.LFB310:
 1753              		.loc 1 1090 0
 1754 07d4 00B5     		push	{lr}
 1755              	.LCFI17:
 1756              		.loc 1 1091 0
 1757 07d6 4020     		mov	r0, #64
 1758 07d8 FFF7FEFF 		bl	tcp_alloc
 1759              		.loc 1 1092 0
 1760              		@ sp needed for prologue
 1761 07dc 02BC     		pop	{r1}
 1762 07de 0847     		bx	r1
 1763              	.LFE310:
 1765              		.align	2
 1766              		.global	tcp_listen_with_backlog
 1767              		.code	16
 1768              		.thumb_func
 1770              	tcp_listen_with_backlog:
 1771              	.LFB295:
 1772              		.loc 1 367 0
 1773 07e0 30B5     		push	{r4, r5, lr}
 1774              	.LCFI18:
 1775              	.LVL193:
 1776 07e2 041C     		mov	r4, r0
 1777              		.loc 1 371 0
 1778 07e4 0369     		ldr	r3, [r0, #16]
 1779 07e6 002B     		cmp	r3, #0
 1780 07e8 45D1     		bne	.L164
 1781              		.loc 1 377 0
 1782 07ea 0320     		mov	r0, #3
 1783              	.LVL194:
 1784 07ec FFF7FEFF 		bl	memp_malloc
 1785              	.LVL195:
 1786 07f0 051C     		mov	r5, r0
 1787              	.LVL196:
 1788              		.loc 1 378 0
 1789 07f2 0028     		cmp	r0, #0
 1790 07f4 3FD0     		beq	.L164
 1791              	.LVL197:
 1792              		.loc 1 381 0
 1793 07f6 A369     		ldr	r3, [r4, #24]
 1794 07f8 8361     		str	r3, [r0, #24]
 1795              		.loc 1 382 0
 1796 07fa A38B     		ldrh	r3, [r4, #28]
 1797 07fc 8383     		strh	r3, [r0, #28]
 1798              		.loc 1 383 0
 1799 07fe 0123     		mov	r3, #1
 1800 0800 0361     		str	r3, [r0, #16]
 1801              		.loc 1 385 0
 1802 0802 2389     		ldrh	r3, [r4, #8]
 1803 0804 0222     		mov	r2, #2
 1804 0806 1343     		orr	r3, r3, r2
 1805 0808 0381     		strh	r3, [r0, #8]
 1806              		.loc 1 386 0
 1807 080a E37A     		ldrb	r3, [r4, #11]
 1808 080c C372     		strb	r3, [r0, #11]
 1809              		.loc 1 387 0
 1810 080e A37A     		ldrb	r3, [r4, #10]
 1811 0810 8372     		strb	r3, [r0, #10]
 1812              		.loc 1 388 0
 1813 0812 002C     		cmp	r4, #0
 1814 0814 01D1     		bne	.L165
 1815 0816 0023     		mov	r3, #0
 1816 0818 00E0     		b	.L166
 1817              	.L165:
 1818 081a 2368     		ldr	r3, [r4]
 1819              	.L166:
 1820 081c 2B60     		str	r3, [r5]
 1821              		.loc 1 389 0
 1822 081e 184B     		ldr	r3, .L175
 1823 0820 1968     		ldr	r1, [r3]
 1824 0822 A142     		cmp	r1, r4
 1825 0824 03D1     		bne	.L167
 1826              	.LVL198:
 1827 0826 1A1C     		mov	r2, r3
 1828 0828 CB68     		ldr	r3, [r1, #12]
 1829 082a 1360     		str	r3, [r2]
 1830 082c 13E0     		b	.L168
 1831              	.L167:
 1832 082e 154B     		ldr	r3, .L175+4
 1833 0830 1960     		str	r1, [r3]
 1834 0832 0029     		cmp	r1, #0
 1835 0834 0FD0     		beq	.L168
 1836 0836 CB68     		ldr	r3, [r1, #12]
 1837 0838 A342     		cmp	r3, r4
 1838 083a 05D0     		beq	.L169
 1839 083c 191C     		mov	r1, r3
 1840 083e 114A     		ldr	r2, .L175+4
 1841 0840 06E0     		b	.L170
 1842              	.L172:
 1843 0842 CB68     		ldr	r3, [r1, #12]
 1844 0844 A342     		cmp	r3, r4
 1845 0846 02D1     		bne	.L171
 1846              	.L169:
 1847 0848 E368     		ldr	r3, [r4, #12]
 1848 084a CB60     		str	r3, [r1, #12]
 1849 084c 03E0     		b	.L168
 1850              	.L171:
 1851 084e 191C     		mov	r1, r3
 1852              	.L170:
 1853 0850 1160     		str	r1, [r2]
 1854 0852 0029     		cmp	r1, #0
 1855 0854 F5D1     		bne	.L172
 1856              	.L168:
 1857 0856 0023     		mov	r3, #0
 1858 0858 E360     		str	r3, [r4, #12]
 1859              		.loc 1 390 0
 1860 085a 0220     		mov	r0, #2
 1861 085c 211C     		mov	r1, r4
 1862 085e FFF7FEFF 		bl	memp_free
 1863              		.loc 1 392 0
 1864 0862 094B     		ldr	r3, .L175+8
 1865 0864 2B62     		str	r3, [r5, #32]
 1866              		.loc 1 398 0
 1867 0866 094A     		ldr	r2, .L175+12
 1868 0868 1368     		ldr	r3, [r2]
 1869 086a EB60     		str	r3, [r5, #12]
 1870 086c 1560     		str	r5, [r2]
 1871 086e FFF7FEFF 		bl	tcp_timer_needed
 1872              		.loc 1 399 0
 1873 0872 281C     		mov	r0, r5
 1874              	.LVL199:
 1875 0874 00E0     		b	.L173
 1876              	.LVL200:
 1877              	.L164:
 1878 0876 0020     		mov	r0, #0
 1879              	.LVL201:
 1880              	.L173:
 1881              	.LVL202:
 1882              		.loc 1 400 0
 1883              		@ sp needed for prologue
 1884              	.LVL203:
 1885 0878 30BC     		pop	{r4, r5}
 1886 087a 02BC     		pop	{r1}
 1887 087c 0847     		bx	r1
 1888              	.L176:
 1889 087e C046     		.align	2
 1890              	.L175:
 1891 0880 00000000 		.word	tcp_bound_pcbs
 1892 0884 00000000 		.word	tcp_tmp_pcb
 1893 0888 00000000 		.word	tcp_accept_null
 1894 088c 00000000 		.word	tcp_listen_pcbs
 1895              	.LFE295:
 1897              		.align	2
 1898              		.global	tcp_bind
 1899              		.code	16
 1900              		.thumb_func
 1902              	tcp_bind:
 1903              	.LFB293:
 1904              		.loc 1 277 0
 1905 0890 30B5     		push	{r4, r5, lr}
 1906              	.LCFI19:
 1907              	.LVL204:
 1908 0892 051C     		mov	r5, r0
 1909 0894 0C1C     		mov	r4, r1
 1910 0896 1204     		lsl	r2, r2, #16
 1911              	.LVL205:
 1912 0898 100C     		lsr	r0, r2, #16
 1913              	.LVL206:
 1914              		.loc 1 280 0
 1915 089a 2B69     		ldr	r3, [r5, #16]
 1916 089c 002B     		cmp	r3, #0
 1917 089e 01D0     		beq	.L178
 1918              	.LVL207:
 1919 08a0 F320     		mov	r0, #243
 1920              	.LVL208:
 1921 08a2 63E0     		b	.L179
 1922              	.LVL209:
 1923              	.L178:
 1924              		.loc 1 282 0
 1925 08a4 0028     		cmp	r0, #0
 1926 08a6 01D1     		bne	.L180
 1927              		.loc 1 283 0
 1928 08a8 FFF7CEFB 		bl	tcp_new_port
 1929              	.LVL210:
 1930              	.L180:
 1931              		.loc 1 287 0
 1932 08ac 324B     		ldr	r3, .L204
 1933 08ae 1A68     		ldr	r2, [r3]
 1934              	.LVL211:
 1935              		.loc 1 288 0
 1936 08b0 002A     		cmp	r2, #0
 1937 08b2 11D0     		beq	.L181
 1938              	.L199:
 1939              		.loc 1 289 0
 1940 08b4 938B     		ldrh	r3, [r2, #28]
 1941 08b6 8342     		cmp	r3, r0
 1942 08b8 0BD1     		bne	.L182
 1943              		.loc 1 290 0
 1944 08ba 002A     		cmp	r2, #0
 1945 08bc 55D0     		beq	.L183
 1946 08be 1168     		ldr	r1, [r2]
 1947 08c0 0029     		cmp	r1, #0
 1948 08c2 52D0     		beq	.L183
 1949 08c4 002C     		cmp	r4, #0
 1950 08c6 50D0     		beq	.L183
 1951 08c8 2368     		ldr	r3, [r4]
 1952 08ca 002B     		cmp	r3, #0
 1953 08cc 4DD0     		beq	.L183
 1954 08ce 9942     		cmp	r1, r3
 1955 08d0 4BD0     		beq	.L183
 1956              	.LVL212:
 1957              	.L182:
 1958              		.loc 1 288 0
 1959 08d2 D268     		ldr	r2, [r2, #12]
 1960 08d4 002A     		cmp	r2, #0
 1961 08d6 EDD1     		bne	.L199
 1962              	.L181:
 1963              		.loc 1 298 0
 1964 08d8 284B     		ldr	r3, .L204+4
 1965 08da 1A68     		ldr	r2, [r3]
 1966              	.LVL213:
 1967              		.loc 1 299 0
 1968 08dc 002A     		cmp	r2, #0
 1969 08de 11D0     		beq	.L185
 1970              	.L198:
 1971              		.loc 1 300 0
 1972 08e0 938B     		ldrh	r3, [r2, #28]
 1973 08e2 8342     		cmp	r3, r0
 1974 08e4 0BD1     		bne	.L186
 1975              		.loc 1 301 0
 1976 08e6 002A     		cmp	r2, #0
 1977 08e8 3FD0     		beq	.L183
 1978 08ea 1168     		ldr	r1, [r2]
 1979 08ec 0029     		cmp	r1, #0
 1980 08ee 3CD0     		beq	.L183
 1981 08f0 002C     		cmp	r4, #0
 1982 08f2 3AD0     		beq	.L183
 1983 08f4 2368     		ldr	r3, [r4]
 1984 08f6 002B     		cmp	r3, #0
 1985 08f8 37D0     		beq	.L183
 1986 08fa 9942     		cmp	r1, r3
 1987 08fc 35D0     		beq	.L183
 1988              	.LVL214:
 1989              	.L186:
 1990              		.loc 1 299 0
 1991 08fe D268     		ldr	r2, [r2, #12]
 1992 0900 002A     		cmp	r2, #0
 1993 0902 EDD1     		bne	.L198
 1994              	.L185:
 1995              		.loc 1 309 0
 1996 0904 1E4B     		ldr	r3, .L204+8
 1997 0906 1A68     		ldr	r2, [r3]
 1998              	.LVL215:
 1999 0908 002A     		cmp	r2, #0
 2000 090a 11D0     		beq	.L188
 2001              	.L197:
 2002              		.loc 1 310 0
 2003 090c 938B     		ldrh	r3, [r2, #28]
 2004 090e 8342     		cmp	r3, r0
 2005 0910 0BD1     		bne	.L189
 2006              		.loc 1 311 0
 2007 0912 002A     		cmp	r2, #0
 2008 0914 29D0     		beq	.L183
 2009 0916 1168     		ldr	r1, [r2]
 2010 0918 0029     		cmp	r1, #0
 2011 091a 26D0     		beq	.L183
 2012 091c 002C     		cmp	r4, #0
 2013 091e 24D0     		beq	.L183
 2014 0920 2368     		ldr	r3, [r4]
 2015 0922 002B     		cmp	r3, #0
 2016 0924 21D0     		beq	.L183
 2017 0926 9942     		cmp	r1, r3
 2018 0928 1FD0     		beq	.L183
 2019              	.LVL216:
 2020              	.L189:
 2021              		.loc 1 309 0
 2022 092a D268     		ldr	r2, [r2, #12]
 2023 092c 002A     		cmp	r2, #0
 2024 092e EDD1     		bne	.L197
 2025              	.L188:
 2026              		.loc 1 320 0
 2027 0930 144B     		ldr	r3, .L204+12
 2028 0932 1968     		ldr	r1, [r3]
 2029              	.LVL217:
 2030 0934 0029     		cmp	r1, #0
 2031 0936 09D0     		beq	.L191
 2032              	.L196:
 2033              		.loc 1 321 0
 2034 0938 8B8B     		ldrh	r3, [r1, #28]
 2035 093a 8342     		cmp	r3, r0
 2036 093c 03D1     		bne	.L192
 2037              		.loc 1 322 0
 2038 093e 0A68     		ldr	r2, [r1]
 2039 0940 2368     		ldr	r3, [r4]
 2040 0942 9A42     		cmp	r2, r3
 2041 0944 11D0     		beq	.L183
 2042              	.L192:
 2043              		.loc 1 320 0
 2044 0946 C968     		ldr	r1, [r1, #12]
 2045 0948 0029     		cmp	r1, #0
 2046 094a F5D1     		bne	.L196
 2047              	.L191:
 2048              		.loc 1 328 0
 2049 094c 002C     		cmp	r4, #0
 2050 094e 03D0     		beq	.L194
 2051 0950 2168     		ldr	r1, [r4]
 2052              	.LVL218:
 2053 0952 0029     		cmp	r1, #0
 2054 0954 00D0     		beq	.L194
 2055              		.loc 1 329 0
 2056 0956 2960     		str	r1, [r5]
 2057              	.LVL219:
 2058              	.L194:
 2059              		.loc 1 331 0
 2060 0958 A883     		strh	r0, [r5, #28]
 2061              		.loc 1 332 0
 2062 095a 094A     		ldr	r2, .L204+8
 2063 095c 1368     		ldr	r3, [r2]
 2064 095e EB60     		str	r3, [r5, #12]
 2065 0960 1560     		str	r5, [r2]
 2066 0962 FFF7FEFF 		bl	tcp_timer_needed
 2067              	.LVL220:
 2068 0966 0020     		mov	r0, #0
 2069 0968 00E0     		b	.L179
 2070              	.LVL221:
 2071              	.L183:
 2072              		.loc 1 334 0
 2073 096a F520     		mov	r0, #245
 2074              	.LVL222:
 2075              	.L179:
 2076 096c 0006     		lsl	r0, r0, #24
 2077 096e 0016     		asr	r0, r0, #24
 2078              		.loc 1 335 0
 2079              		@ sp needed for prologue
 2080              	.LVL223:
 2081              	.LVL224:
 2082 0970 30BC     		pop	{r4, r5}
 2083 0972 02BC     		pop	{r1}
 2084 0974 0847     		bx	r1
 2085              	.L205:
 2086 0976 C046     		.align	2
 2087              	.L204:
 2088 0978 00000000 		.word	tcp_listen_pcbs
 2089 097c 00000000 		.word	tcp_active_pcbs
 2090 0980 00000000 		.word	tcp_bound_pcbs
 2091 0984 00000000 		.word	tcp_tw_pcbs
 2092              	.LFE293:
 2094              		.align	2
 2095              		.global	tcp_connect
 2096              		.code	16
 2097              		.thumb_func
 2099              	tcp_connect:
 2100              	.LFB299:
 2101              		.loc 1 516 0
 2102 0988 70B5     		push	{r4, r5, r6, lr}
 2103              	.LCFI20:
 2104              	.LVL225:
 2105 098a 82B0     		sub	sp, sp, #8
 2106              	.LCFI21:
 2107 098c 051C     		mov	r5, r0
 2108 098e 0C1C     		mov	r4, r1
 2109 0990 1E1C     		mov	r6, r3
 2110 0992 1204     		lsl	r2, r2, #16
 2111              	.LVL226:
 2112 0994 120C     		lsr	r2, r2, #16
 2113              	.LVL227:
 2114              		.loc 1 520 0
 2115 0996 0369     		ldr	r3, [r0, #16]
 2116              	.LVL228:
 2117 0998 002B     		cmp	r3, #0
 2118 099a 01D0     		beq	.L207
 2119              	.LVL229:
 2120 099c F324     		mov	r4, #243
 2121              	.LVL230:
 2122 099e 61E0     		b	.L208
 2123              	.LVL231:
 2124              	.L207:
 2125              		.loc 1 523 0
 2126 09a0 0029     		cmp	r1, #0
 2127 09a2 01D1     		bne	.L209
 2128              	.LVL232:
 2129 09a4 F724     		mov	r4, #247
 2130              	.LVL233:
 2131 09a6 5DE0     		b	.L208
 2132              	.LVL234:
 2133              	.L209:
 2134              		.loc 1 524 0
 2135 09a8 0B68     		ldr	r3, [r1]
 2136 09aa 4360     		str	r3, [r0, #4]
 2137              		.loc 1 528 0
 2138 09ac 8284     		strh	r2, [r0, #36]
 2139              		.loc 1 529 0
 2140 09ae 838B     		ldrh	r3, [r0, #28]
 2141 09b0 002B     		cmp	r3, #0
 2142 09b2 02D1     		bne	.L210
 2143              		.loc 1 530 0
 2144 09b4 FFF748FB 		bl	tcp_new_port
 2145              	.LVL235:
 2146 09b8 A883     		strh	r0, [r5, #28]
 2147              	.LVL236:
 2148              	.L210:
 2149              		.loc 1 532 0
 2150 09ba FFF7FEFF 		bl	tcp_next_iss
 2151              	.LVL237:
 2152              		.loc 1 533 0
 2153 09be 0023     		mov	r3, #0
 2154 09c0 AB62     		str	r3, [r5, #40]
 2155              		.loc 1 534 0
 2156 09c2 E865     		str	r0, [r5, #92]
 2157              	.LVL238:
 2158              		.loc 1 535 0
 2159 09c4 0138     		sub	r0, r0, #1
 2160              	.LVL239:
 2161 09c6 2865     		str	r0, [r5, #80]
 2162              		.loc 1 536 0
 2163 09c8 E866     		str	r0, [r5, #108]
 2164              		.loc 1 537 0
 2165 09ca 8020     		mov	r0, #128
 2166 09cc 8000     		lsl	r0, r0, #2
 2167 09ce A885     		strh	r0, [r5, #44]
 2168              		.loc 1 538 0
 2169 09d0 E885     		strh	r0, [r5, #46]
 2170              		.loc 1 539 0
 2171 09d2 2B63     		str	r3, [r5, #48]
 2172              		.loc 1 540 0
 2173 09d4 6023     		mov	r3, #96
 2174 09d6 E852     		strh	r0, [r5, r3]
 2175              		.loc 1 543 0
 2176 09d8 A887     		strh	r0, [r5, #60]
 2177              		.loc 1 545 0
 2178 09da 211C     		mov	r1, r4
 2179 09dc FFF7FEFF 		bl	tcp_eff_send_mss
 2180 09e0 A887     		strh	r0, [r5, #60]
 2181              		.loc 1 547 0
 2182 09e2 0122     		mov	r2, #1
 2183 09e4 5623     		mov	r3, #86
 2184 09e6 EA52     		strh	r2, [r5, r3]
 2185              		.loc 1 548 0
 2186 09e8 AA8F     		ldrh	r2, [r5, #60]
 2187 09ea 9300     		lsl	r3, r2, #2
 2188 09ec 9B18     		add	r3, r3, r2
 2189 09ee 5B00     		lsl	r3, r3, #1
 2190 09f0 5822     		mov	r2, #88
 2191 09f2 AB52     		strh	r3, [r5, r2]
 2192              		.loc 1 549 0
 2193 09f4 0223     		mov	r3, #2
 2194 09f6 2B61     		str	r3, [r5, #16]
 2195              		.loc 1 551 0
 2196 09f8 9023     		mov	r3, #144
 2197 09fa EE50     		str	r6, [r5, r3]
 2198              		.loc 1 553 0
 2199 09fc 1C4B     		ldr	r3, .L218
 2200 09fe 1968     		ldr	r1, [r3]
 2201 0a00 A942     		cmp	r1, r5
 2202 0a02 03D1     		bne	.L211
 2203 0a04 1A1C     		mov	r2, r3
 2204 0a06 CB68     		ldr	r3, [r1, #12]
 2205 0a08 1360     		str	r3, [r2]
 2206 0a0a 13E0     		b	.L212
 2207              	.L211:
 2208 0a0c 194B     		ldr	r3, .L218+4
 2209 0a0e 1960     		str	r1, [r3]
 2210 0a10 0029     		cmp	r1, #0
 2211 0a12 0FD0     		beq	.L212
 2212 0a14 CB68     		ldr	r3, [r1, #12]
 2213 0a16 AB42     		cmp	r3, r5
 2214 0a18 05D0     		beq	.L213
 2215 0a1a 191C     		mov	r1, r3
 2216 0a1c 154A     		ldr	r2, .L218+4
 2217 0a1e 06E0     		b	.L214
 2218              	.L216:
 2219 0a20 CB68     		ldr	r3, [r1, #12]
 2220 0a22 AB42     		cmp	r3, r5
 2221 0a24 02D1     		bne	.L215
 2222              	.L213:
 2223 0a26 EB68     		ldr	r3, [r5, #12]
 2224 0a28 CB60     		str	r3, [r1, #12]
 2225 0a2a 03E0     		b	.L212
 2226              	.L215:
 2227 0a2c 191C     		mov	r1, r3
 2228              	.L214:
 2229 0a2e 1160     		str	r1, [r2]
 2230 0a30 0029     		cmp	r1, #0
 2231 0a32 F5D1     		bne	.L216
 2232              	.L212:
 2233 0a34 0024     		mov	r4, #0
 2234              	.LVL240:
 2235 0a36 EC60     		str	r4, [r5, #12]
 2236              		.loc 1 554 0
 2237 0a38 0F4A     		ldr	r2, .L218+8
 2238 0a3a 1368     		ldr	r3, [r2]
 2239 0a3c EB60     		str	r3, [r5, #12]
 2240 0a3e 1560     		str	r5, [r2]
 2241 0a40 FFF7FEFF 		bl	tcp_timer_needed
 2242              		.loc 1 558 0
 2243 0a44 0094     		str	r4, [sp]
 2244 0a46 0123     		mov	r3, #1
 2245 0a48 0193     		str	r3, [sp, #4]
 2246 0a4a 281C     		mov	r0, r5
 2247 0a4c 0021     		mov	r1, #0
 2248 0a4e 0022     		mov	r2, #0
 2249 0a50 0223     		mov	r3, #2
 2250 0a52 FFF7FEFF 		bl	tcp_enqueue
 2251 0a56 0006     		lsl	r0, r0, #24
 2252 0a58 040E     		lsr	r4, r0, #24
 2253              	.LVL241:
 2254              		.loc 1 563 0
 2255 0a5a 002C     		cmp	r4, #0
 2256 0a5c 02D1     		bne	.L208
 2257              		.loc 1 564 0
 2258 0a5e 281C     		mov	r0, r5
 2259 0a60 FFF7FEFF 		bl	tcp_output
 2260              	.LVL242:
 2261              	.L208:
 2262 0a64 2006     		lsl	r0, r4, #24
 2263 0a66 0016     		asr	r0, r0, #24
 2264              		.loc 1 567 0
 2265 0a68 02B0     		add	sp, sp, #8
 2266              		@ sp needed for prologue
 2267              	.LVL243:
 2268              	.LVL244:
 2269              	.LVL245:
 2270 0a6a 70BC     		pop	{r4, r5, r6}
 2271 0a6c 02BC     		pop	{r1}
 2272 0a6e 0847     		bx	r1
 2273              	.L219:
 2274              		.align	2
 2275              	.L218:
 2276 0a70 00000000 		.word	tcp_bound_pcbs
 2277 0a74 00000000 		.word	tcp_tmp_pcb
 2278 0a78 00000000 		.word	tcp_active_pcbs
 2279              	.LFE299:
 2281              		.align	2
 2282              		.global	tcp_close
 2283              		.code	16
 2284              		.thumb_func
 2286              	tcp_close:
 2287              	.LFB291:
 2288              		.loc 1 128 0
 2289 0a7c 10B5     		push	{r4, lr}
 2290              	.LCFI22:
 2291              	.LVL246:
 2292 0a7e 041C     		mov	r4, r0
 2293              		.loc 1 136 0
 2294 0a80 0369     		ldr	r3, [r0, #16]
 2295 0a82 072B     		cmp	r3, #7
 2296 0a84 03D8     		bhi	.L221
 2297 0a86 9B00     		lsl	r3, r3, #2
 2298 0a88 334A     		ldr	r2, .L239
 2299 0a8a D358     		ldr	r3, [r2, r3]
 2300 0a8c 9F46     		mov	pc, r3
 2301              		.section	.rodata
 2302              		.align	2
 2303              	.L228:
 2304 0000 920A0000 		.word	.L222
 2305 0004 DA0A0000 		.word	.L223
 2306 0008 EE0A0000 		.word	.L224
 2307 000c 020B0000 		.word	.L225
 2308 0010 160B0000 		.word	.L226
 2309 0014 8E0A0000 		.word	.L221
 2310 0018 8E0A0000 		.word	.L221
 2311 001c 2A0B0000 		.word	.L227
 2312              		.text
 2313              	.L221:
 2314 0a8e 0024     		mov	r4, #0
 2315              	.LVL247:
 2316 0a90 54E0     		b	.L229
 2317              	.LVL248:
 2318              	.L222:
 2319              		.loc 1 146 0
 2320 0a92 324B     		ldr	r3, .L239+4
 2321 0a94 1968     		ldr	r1, [r3]
 2322 0a96 A142     		cmp	r1, r4
 2323 0a98 03D1     		bne	.L230
 2324              	.LVL249:
 2325 0a9a 1A1C     		mov	r2, r3
 2326 0a9c CB68     		ldr	r3, [r1, #12]
 2327 0a9e 1360     		str	r3, [r2]
 2328 0aa0 13E0     		b	.L231
 2329              	.L230:
 2330 0aa2 2F4B     		ldr	r3, .L239+8
 2331 0aa4 1960     		str	r1, [r3]
 2332 0aa6 0029     		cmp	r1, #0
 2333 0aa8 0FD0     		beq	.L231
 2334 0aaa CB68     		ldr	r3, [r1, #12]
 2335 0aac A342     		cmp	r3, r4
 2336 0aae 05D0     		beq	.L232
 2337 0ab0 191C     		mov	r1, r3
 2338 0ab2 2B4A     		ldr	r2, .L239+8
 2339 0ab4 06E0     		b	.L233
 2340              	.L235:
 2341 0ab6 CB68     		ldr	r3, [r1, #12]
 2342 0ab8 A342     		cmp	r3, r4
 2343 0aba 02D1     		bne	.L234
 2344              	.L232:
 2345 0abc E368     		ldr	r3, [r4, #12]
 2346 0abe CB60     		str	r3, [r1, #12]
 2347 0ac0 03E0     		b	.L231
 2348              	.L234:
 2349 0ac2 191C     		mov	r1, r3
 2350              	.L233:
 2351 0ac4 1160     		str	r1, [r2]
 2352 0ac6 0029     		cmp	r1, #0
 2353 0ac8 F5D1     		bne	.L235
 2354              	.L231:
 2355 0aca 0023     		mov	r3, #0
 2356 0acc E360     		str	r3, [r4, #12]
 2357              		.loc 1 147 0
 2358 0ace 0220     		mov	r0, #2
 2359 0ad0 211C     		mov	r1, r4
 2360 0ad2 FFF7FEFF 		bl	memp_free
 2361 0ad6 0020     		mov	r0, #0
 2362              	.LVL250:
 2363 0ad8 38E0     		b	.L236
 2364              	.LVL251:
 2365              	.L223:
 2366              		.loc 1 152 0
 2367 0ada 2248     		ldr	r0, .L239+12
 2368              	.LVL252:
 2369 0adc 211C     		mov	r1, r4
 2370 0ade FFF7FEFF 		bl	tcp_pcb_remove
 2371              		.loc 1 153 0
 2372 0ae2 0320     		mov	r0, #3
 2373 0ae4 211C     		mov	r1, r4
 2374 0ae6 FFF7FEFF 		bl	memp_free
 2375 0aea 0020     		mov	r0, #0
 2376              	.LVL253:
 2377 0aec 2EE0     		b	.L236
 2378              	.LVL254:
 2379              	.L224:
 2380              		.loc 1 158 0
 2381 0aee 1E48     		ldr	r0, .L239+16
 2382              	.LVL255:
 2383 0af0 211C     		mov	r1, r4
 2384 0af2 FFF7FEFF 		bl	tcp_pcb_remove
 2385              		.loc 1 159 0
 2386 0af6 0220     		mov	r0, #2
 2387 0af8 211C     		mov	r1, r4
 2388 0afa FFF7FEFF 		bl	memp_free
 2389 0afe 0020     		mov	r0, #0
 2390              	.LVL256:
 2391 0b00 24E0     		b	.L236
 2392              	.LVL257:
 2393              	.L225:
 2394              		.loc 1 164 0
 2395 0b02 0121     		mov	r1, #1
 2396 0b04 FFF7FEFF 		bl	tcp_send_ctrl
 2397              	.LVL258:
 2398 0b08 0006     		lsl	r0, r0, #24
 2399 0b0a 000E     		lsr	r0, r0, #24
 2400              	.LVL259:
 2401              		.loc 1 165 0
 2402 0b0c 0028     		cmp	r0, #0
 2403 0b0e 1DD1     		bne	.L236
 2404              		.loc 1 167 0
 2405 0b10 0523     		mov	r3, #5
 2406 0b12 2361     		str	r3, [r4, #16]
 2407 0b14 12E0     		b	.L229
 2408              	.LVL260:
 2409              	.L226:
 2410              		.loc 1 171 0
 2411 0b16 0121     		mov	r1, #1
 2412 0b18 FFF7FEFF 		bl	tcp_send_ctrl
 2413              	.LVL261:
 2414 0b1c 0006     		lsl	r0, r0, #24
 2415 0b1e 000E     		lsr	r0, r0, #24
 2416              	.LVL262:
 2417              		.loc 1 172 0
 2418 0b20 0028     		cmp	r0, #0
 2419 0b22 13D1     		bne	.L236
 2420              		.loc 1 174 0
 2421 0b24 0523     		mov	r3, #5
 2422 0b26 2361     		str	r3, [r4, #16]
 2423 0b28 08E0     		b	.L229
 2424              	.LVL263:
 2425              	.L227:
 2426              		.loc 1 178 0
 2427 0b2a 0121     		mov	r1, #1
 2428 0b2c FFF7FEFF 		bl	tcp_send_ctrl
 2429              	.LVL264:
 2430 0b30 0006     		lsl	r0, r0, #24
 2431 0b32 000E     		lsr	r0, r0, #24
 2432              	.LVL265:
 2433              		.loc 1 179 0
 2434 0b34 0028     		cmp	r0, #0
 2435 0b36 09D1     		bne	.L236
 2436              		.loc 1 181 0
 2437 0b38 0923     		mov	r3, #9
 2438 0b3a 2361     		str	r3, [r4, #16]
 2439              	.L229:
 2440              		.loc 1 191 0
 2441 0b3c 002C     		cmp	r4, #0
 2442 0b3e 01D1     		bne	.L237
 2443 0b40 0020     		mov	r0, #0
 2444              	.LVL266:
 2445 0b42 03E0     		b	.L236
 2446              	.L237:
 2447              		.loc 1 199 0
 2448 0b44 201C     		mov	r0, r4
 2449              	.LVL267:
 2450 0b46 FFF7FEFF 		bl	tcp_output
 2451 0b4a 0020     		mov	r0, #0
 2452              	.LVL268:
 2453              	.L236:
 2454 0b4c 0006     		lsl	r0, r0, #24
 2455              	.LVL269:
 2456 0b4e 0016     		asr	r0, r0, #24
 2457              		.loc 1 202 0
 2458              		@ sp needed for prologue
 2459              	.LVL270:
 2460 0b50 10BC     		pop	{r4}
 2461 0b52 02BC     		pop	{r1}
 2462 0b54 0847     		bx	r1
 2463              	.L240:
 2464 0b56 C046     		.align	2
 2465              	.L239:
 2466 0b58 00000000 		.word	.L228
 2467 0b5c 00000000 		.word	tcp_bound_pcbs
 2468 0b60 00000000 		.word	tcp_tmp_pcb
 2469 0b64 00000000 		.word	tcp_listen_pcbs
 2470 0b68 00000000 		.word	tcp_active_pcbs
 2471              	.LFE291:
 2473              		.align	2
 2474              		.global	tcp_recv_null
 2475              		.code	16
 2476              		.thumb_func
 2478              	tcp_recv_null:
 2479              	.LFB306:
 2480              		.loc 1 926 0
 2481 0b6c 10B5     		push	{r4, lr}
 2482              	.LCFI23:
 2483              	.LVL271:
 2484 0b6e 081C     		mov	r0, r1
 2485              	.LVL272:
 2486 0b70 141C     		mov	r4, r2
 2487 0b72 1B06     		lsl	r3, r3, #24
 2488              	.LVL273:
 2489 0b74 1B16     		asr	r3, r3, #24
 2490              	.LVL274:
 2491              		.loc 1 928 0
 2492 0b76 002A     		cmp	r2, #0
 2493 0b78 07D0     		beq	.L242
 2494              	.LVL275:
 2495              		.loc 1 929 0
 2496 0b7a 1189     		ldrh	r1, [r2, #8]
 2497 0b7c FFF7FEFF 		bl	tcp_recved
 2498              	.LVL276:
 2499              		.loc 1 930 0
 2500 0b80 201C     		mov	r0, r4
 2501 0b82 FFF7FEFF 		bl	pbuf_free
 2502 0b86 0020     		mov	r0, #0
 2503 0b88 07E0     		b	.L243
 2504              	.LVL277:
 2505              	.L242:
 2506              		.loc 1 931 0
 2507 0b8a 002B     		cmp	r3, #0
 2508 0b8c 01D0     		beq	.L244
 2509 0b8e 0020     		mov	r0, #0
 2510              	.LVL278:
 2511 0b90 03E0     		b	.L243
 2512              	.LVL279:
 2513              	.L244:
 2514              		.loc 1 932 0
 2515 0b92 FFF7FEFF 		bl	tcp_close
 2516              	.LVL280:
 2517 0b96 0006     		lsl	r0, r0, #24
 2518 0b98 000E     		lsr	r0, r0, #24
 2519              	.LVL281:
 2520              	.L243:
 2521 0b9a 0006     		lsl	r0, r0, #24
 2522 0b9c 0016     		asr	r0, r0, #24
 2523              		.loc 1 935 0
 2524              		@ sp needed for prologue
 2525              	.LVL282:
 2526 0b9e 10BC     		pop	{r4}
 2527 0ba0 02BC     		pop	{r1}
 2528 0ba2 0847     		bx	r1
 2529              	.LFE306:
 2531              		.align	2
 2532              		.global	tcp_fasttmr
 2533              		.code	16
 2534              		.thumb_func
 2536              	tcp_fasttmr:
 2537              	.LFB301:
 2538              		.loc 1 818 0
 2539 0ba4 F0B5     		push	{r4, r5, r6, r7, lr}
 2540              	.LCFI24:
 2541 0ba6 5F46     		mov	r7, fp
 2542 0ba8 5646     		mov	r6, sl
 2543 0baa 4D46     		mov	r5, r9
 2544 0bac 4446     		mov	r4, r8
 2545 0bae F0B4     		push	{r4, r5, r6, r7}
 2546              	.LCFI25:
 2547              		.loc 1 821 0
 2548 0bb0 204B     		ldr	r3, .L256
 2549 0bb2 1C68     		ldr	r4, [r3]
 2550              	.LVL283:
 2551 0bb4 002C     		cmp	r4, #0
 2552 0bb6 35D0     		beq	.L253
 2553              		.loc 1 823 0
 2554 0bb8 8422     		mov	r2, #132
 2555 0bba 9046     		mov	r8, r2
 2556              	.LBB10:
 2557              		.loc 1 827 0
 2558 0bbc 8C23     		mov	r3, #140
 2559 0bbe 9946     		mov	r9, r3
 2560              		.loc 1 829 0
 2561 0bc0 0027     		mov	r7, #0
 2562              	.LBE10:
 2563              		.loc 1 834 0
 2564 0bc2 2626     		mov	r6, #38
 2565 0bc4 0122     		mov	r2, #1
 2566 0bc6 9246     		mov	sl, r2
 2567              		.loc 1 837 0
 2568 0bc8 0323     		mov	r3, #3
 2569 0bca 9B46     		mov	fp, r3
 2570              	.LVL284:
 2571              	.L254:
 2572              		.loc 1 823 0
 2573 0bcc 4346     		mov	r3, r8
 2574 0bce E258     		ldr	r2, [r4, r3]
 2575 0bd0 002A     		cmp	r2, #0
 2576 0bd2 16D0     		beq	.L248
 2577              	.LBB11:
 2578              		.loc 1 827 0
 2579 0bd4 4B46     		mov	r3, r9
 2580 0bd6 E558     		ldr	r5, [r4, r3]
 2581 0bd8 002D     		cmp	r5, #0
 2582 0bda 07D0     		beq	.L249
 2583 0bdc A069     		ldr	r0, [r4, #24]
 2584              	.LVL285:
 2585 0bde 211C     		mov	r1, r4
 2586 0be0 3B1C     		mov	r3, r7
 2587 0be2 00F03CF8 		bl	.L143
 2588 0be6 0006     		lsl	r0, r0, #24
 2589 0be8 000E     		lsr	r0, r0, #24
 2590              	.LVL286:
 2591 0bea 06E0     		b	.L250
 2592              	.L249:
 2593 0bec 381C     		mov	r0, r7
 2594              	.LVL287:
 2595 0bee 211C     		mov	r1, r4
 2596 0bf0 3B1C     		mov	r3, r7
 2597 0bf2 FFF7FEFF 		bl	tcp_recv_null
 2598 0bf6 0006     		lsl	r0, r0, #24
 2599 0bf8 000E     		lsr	r0, r0, #24
 2600              	.LVL288:
 2601              	.L250:
 2602              		.loc 1 828 0
 2603 0bfa 0028     		cmp	r0, #0
 2604 0bfc 01D1     		bne	.L248
 2605              		.loc 1 829 0
 2606 0bfe 4246     		mov	r2, r8
 2607 0c00 A750     		str	r7, [r4, r2]
 2608              	.L248:
 2609              	.LBE11:
 2610              		.loc 1 834 0
 2611 0c02 A35D     		ldrb	r3, [r4, r6]
 2612 0c04 5246     		mov	r2, sl
 2613 0c06 1342     		tst	r3, r2
 2614 0c08 09D0     		beq	.L251
 2615              		.loc 1 836 0
 2616 0c0a 0222     		mov	r2, #2
 2617 0c0c 1343     		orr	r3, r3, r2
 2618 0c0e A355     		strb	r3, [r4, r6]
 2619 0c10 201C     		mov	r0, r4
 2620              	.LVL289:
 2621 0c12 FFF7FEFF 		bl	tcp_output
 2622              		.loc 1 837 0
 2623 0c16 A35D     		ldrb	r3, [r4, r6]
 2624 0c18 5A46     		mov	r2, fp
 2625 0c1a 9343     		bic	r3, r3, r2
 2626 0c1c A355     		strb	r3, [r4, r6]
 2627              	.LVL290:
 2628              	.L251:
 2629              		.loc 1 821 0
 2630 0c1e E468     		ldr	r4, [r4, #12]
 2631 0c20 002C     		cmp	r4, #0
 2632 0c22 D3D1     		bne	.L254
 2633              	.L253:
 2634              		.loc 1 840 0
 2635              		@ sp needed for prologue
 2636              	.LVL291:
 2637 0c24 3CBC     		pop	{r2, r3, r4, r5}
 2638 0c26 9046     		mov	r8, r2
 2639 0c28 9946     		mov	r9, r3
 2640 0c2a A246     		mov	sl, r4
 2641 0c2c AB46     		mov	fp, r5
 2642 0c2e F0BC     		pop	{r4, r5, r6, r7}
 2643 0c30 01BC     		pop	{r0}
 2644 0c32 0047     		bx	r0
 2645              	.L257:
 2646              		.align	2
 2647              	.L256:
 2648 0c34 00000000 		.word	tcp_active_pcbs
 2649              	.LFE301:
 2651              		.align	2
 2652              		.global	tcp_tmr
 2653              		.code	16
 2654              		.thumb_func
 2656              	tcp_tmr:
 2657              	.LFB290:
 2658              		.loc 1 101 0
 2659 0c38 00B5     		push	{lr}
 2660              	.LCFI26:
 2661              		.loc 1 103 0
 2662 0c3a FFF7FEFF 		bl	tcp_fasttmr
 2663              		.loc 1 105 0
 2664 0c3e 064A     		ldr	r2, .L261
 2665 0c40 1378     		ldrb	r3, [r2]
 2666 0c42 0133     		add	r3, r3, #1
 2667 0c44 1B06     		lsl	r3, r3, #24
 2668 0c46 1B0E     		lsr	r3, r3, #24
 2669 0c48 1370     		strb	r3, [r2]
 2670 0c4a DA07     		lsl	r2, r3, #31
 2671 0c4c 01D5     		bpl	.L260
 2672              		.loc 1 108 0
 2673 0c4e FFF7FEFF 		bl	tcp_slowtmr
 2674              	.L260:
 2675              		.loc 1 110 0
 2676              		@ sp needed for prologue
 2677 0c52 01BC     		pop	{r0}
 2678 0c54 0047     		bx	r0
 2679              	.L262:
 2680 0c56 C046     		.align	2
 2681              	.L261:
 2682 0c58 00000000 		.word	tcp_timer
 2683              	.LFE290:
 2685              		.global	tcp_state_str
 2686              		.section	.rodata.str1.4,"aMS",%progbits,1
 2687              		.align	2
 2688              	.LC38:
 2689 0000 434C4F53 		.ascii	"CLOSED\000"
 2689      454400
 2690 0007 00       		.align	2
 2691              	.LC39:
 2692 0008 4C495354 		.ascii	"LISTEN\000"
 2692      454E00
 2693 000f 00       		.align	2
 2694              	.LC40:
 2695 0010 53594E5F 		.ascii	"SYN_SENT\000"
 2695      53454E54 
 2695      00
 2696 0019 000000   		.align	2
 2697              	.LC41:
 2698 001c 53594E5F 		.ascii	"SYN_RCVD\000"
 2698      52435644 
 2698      00
 2699 0025 000000   		.align	2
 2700              	.LC42:
 2701 0028 45535441 		.ascii	"ESTABLISHED\000"
 2701      424C4953 
 2701      48454400 
 2702              		.align	2
 2703              	.LC43:
 2704 0034 46494E5F 		.ascii	"FIN_WAIT_1\000"
 2704      57414954 
 2704      5F3100
 2705 003f 00       		.align	2
 2706              	.LC44:
 2707 0040 46494E5F 		.ascii	"FIN_WAIT_2\000"
 2707      57414954 
 2707      5F3200
 2708 004b 00       		.align	2
 2709              	.LC45:
 2710 004c 434C4F53 		.ascii	"CLOSE_WAIT\000"
 2710      455F5741 
 2710      495400
 2711 0057 00       		.align	2
 2712              	.LC46:
 2713 0058 434C4F53 		.ascii	"CLOSING\000"
 2713      494E4700 
 2714              		.align	2
 2715              	.LC47:
 2716 0060 4C415354 		.ascii	"LAST_ACK\000"
 2716      5F41434B 
 2716      00
 2717 0069 000000   		.align	2
 2718              	.LC48:
 2719 006c 54494D45 		.ascii	"TIME_WAIT\000"
 2719      5F574149 
 2719      5400
 2720 0076 0000     		.data
 2721              		.align	2
 2724              	tcp_state_str:
 2725 0000 00000000 		.word	.LC38
 2726 0004 08000000 		.word	.LC39
 2727 0008 10000000 		.word	.LC40
 2728 000c 1C000000 		.word	.LC41
 2729 0010 28000000 		.word	.LC42
 2730 0014 34000000 		.word	.LC43
 2731 0018 40000000 		.word	.LC44
 2732 001c 4C000000 		.word	.LC45
 2733 0020 58000000 		.word	.LC46
 2734 0024 60000000 		.word	.LC47
 2735 0028 6C000000 		.word	.LC48
 2736              		.global	tcp_backoff
 2737              		.section	.rodata
 2740              	tcp_backoff:
 2741 0020 01       		.byte	1
 2742 0021 02       		.byte	2
 2743 0022 03       		.byte	3
 2744 0023 04       		.byte	4
 2745 0024 05       		.byte	5
 2746 0025 06       		.byte	6
 2747 0026 07       		.byte	7
 2748 0027 07       		.byte	7
 2749 0028 07       		.byte	7
 2750 0029 07       		.byte	7
 2751 002a 07       		.byte	7
 2752 002b 07       		.byte	7
 2753 002c 07       		.byte	7
 2754              		.global	tcp_persist_backoff
 2757              	tcp_persist_backoff:
 2758 002d 03       		.byte	3
 2759 002e 06       		.byte	6
 2760 002f 0C       		.byte	12
 2761 0030 18       		.byte	24
 2762 0031 30       		.byte	48
 2763 0032 60       		.byte	96
 2764 0033 78       		.byte	120
 2765              		.data
 2766              		.align	2
 2769              	iss.6001:
 2770 002c 6E190000 		.word	6510
 2771              		.align	1
 2774              	port.5683:
 2775 0030 0010     		.short	4096
 2776 0032 0000     		.bss
 2777              	tcp_timer:
 2778 0000 00       		.space	1
 2779              		.comm	tcp_ticks,4,4
 2780              		.comm	tcp_listen_pcbs,4,4
 2781              		.comm	tcp_active_pcbs,4,4
 2782              		.comm	tcp_tw_pcbs,4,4
 2783              		.comm	tcp_tmp_pcb,4,4
 2784              		.comm	tcp_bound_pcbs,4,4
 3305              	.Letext0:
 8720              		.code 16
 8721              		.align	1
 8722              	.L128:
 8723 0c5c 1847     		bx	r3
 8724              	.L143:
 8725 0c5e 2847     		bx	r5
DEFINED SYMBOLS
                            *ABS*:00000000 tcp.c
     /tmp/ccQRkz1D.s:1      .text:00000000 $t
     /tmp/ccQRkz1D.s:15     .text:00000000 tcp_accept_null
     /tmp/ccQRkz1D.s:34     .text:00000008 tcp_update_rcv_ann_wnd
     /tmp/ccQRkz1D.s:96     .text:00000048 tcp_new_port
     /tmp/ccQRkz1D.s:226    .text:000000e0 $d
                            *COM*:00000004 tcp_active_pcbs
                            *COM*:00000004 tcp_tw_pcbs
                            *COM*:00000004 tcp_listen_pcbs
     /tmp/ccQRkz1D.s:2774   .data:00000030 port.5683
     /tmp/ccQRkz1D.s:237    .text:000000f0 tcp_setprio
     /tmp/ccQRkz1D.s:234    .text:000000f0 $t
     /tmp/ccQRkz1D.s:253    .text:000000f4 tcp_arg
     /tmp/ccQRkz1D.s:269    .text:000000f8 tcp_recv
     /tmp/ccQRkz1D.s:286    .text:00000100 tcp_sent
     /tmp/ccQRkz1D.s:303    .text:00000108 tcp_err
     /tmp/ccQRkz1D.s:320    .text:00000110 tcp_accept
     /tmp/ccQRkz1D.s:336    .text:00000114 tcp_poll
     /tmp/ccQRkz1D.s:356    .text:00000120 tcp_next_iss
     /tmp/ccQRkz1D.s:372    .text:00000130 $d
                            *COM*:00000004 tcp_ticks
     /tmp/ccQRkz1D.s:2769   .data:0000002c iss.6001
     /tmp/ccQRkz1D.s:381    .text:00000138 tcp_debug_state_str
     /tmp/ccQRkz1D.s:378    .text:00000138 $t
     /tmp/ccQRkz1D.s:396    .text:00000140 $d
     /tmp/ccQRkz1D.s:2724   .data:00000000 tcp_state_str
     /tmp/ccQRkz1D.s:404    .text:00000144 tcp_eff_send_mss
     /tmp/ccQRkz1D.s:401    .text:00000144 $t
     /tmp/ccQRkz1D.s:456    .text:00000178 tcp_recved
     /tmp/ccQRkz1D.s:513    .text:000001b8 tcp_seg_copy
     /tmp/ccQRkz1D.s:558    .text:000001e4 tcp_seg_free
     /tmp/ccQRkz1D.s:609    .text:00000210 tcp_segs_free
     /tmp/ccQRkz1D.s:657    .text:00000238 tcp_pcb_purge
     /tmp/ccQRkz1D.s:720    .text:00000284 tcp_pcb_remove
     /tmp/ccQRkz1D.s:801    .text:000002f0 $d
                            *COM*:00000004 tcp_tmp_pcb
     /tmp/ccQRkz1D.s:810    .text:000002f4 tcp_slowtmr
     /tmp/ccQRkz1D.s:807    .text:000002f4 $t
     /tmp/ccQRkz1D.s:1319   .text:000005b8 $d
     /tmp/ccQRkz1D.s:2757   .rodata:0000002d tcp_persist_backoff
     /tmp/ccQRkz1D.s:2740   .rodata:00000020 tcp_backoff
     /tmp/ccQRkz1D.s:1333   .text:000005d4 tcp_abandon
     /tmp/ccQRkz1D.s:1330   .text:000005d4 $t
     /tmp/ccQRkz1D.s:1482   .text:00000694 $d
     /tmp/ccQRkz1D.s:1491   .text:0000069c tcp_alloc
     /tmp/ccQRkz1D.s:1488   .text:0000069c $t
     /tmp/ccQRkz1D.s:1738   .text:000007bc $d
     /tmp/ccQRkz1D.s:2478   .text:00000b6c tcp_recv_null
     /tmp/ccQRkz1D.s:1751   .text:000007d4 tcp_new
     /tmp/ccQRkz1D.s:1748   .text:000007d4 $t
     /tmp/ccQRkz1D.s:1770   .text:000007e0 tcp_listen_with_backlog
     /tmp/ccQRkz1D.s:1891   .text:00000880 $d
                            *COM*:00000004 tcp_bound_pcbs
     /tmp/ccQRkz1D.s:1902   .text:00000890 tcp_bind
     /tmp/ccQRkz1D.s:1899   .text:00000890 $t
     /tmp/ccQRkz1D.s:2088   .text:00000978 $d
     /tmp/ccQRkz1D.s:2099   .text:00000988 tcp_connect
     /tmp/ccQRkz1D.s:2096   .text:00000988 $t
     /tmp/ccQRkz1D.s:2276   .text:00000a70 $d
     /tmp/ccQRkz1D.s:2286   .text:00000a7c tcp_close
     /tmp/ccQRkz1D.s:2283   .text:00000a7c $t
     /tmp/ccQRkz1D.s:2304   .rodata:00000000 $d
     /tmp/ccQRkz1D.s:2466   .text:00000b58 $d
     /tmp/ccQRkz1D.s:2475   .text:00000b6c $t
     /tmp/ccQRkz1D.s:2536   .text:00000ba4 tcp_fasttmr
     /tmp/ccQRkz1D.s:2648   .text:00000c34 $d
     /tmp/ccQRkz1D.s:2656   .text:00000c38 tcp_tmr
     /tmp/ccQRkz1D.s:2653   .text:00000c38 $t
     /tmp/ccQRkz1D.s:2682   .text:00000c58 $d
     /tmp/ccQRkz1D.s:2777   .bss:00000000 tcp_timer
     /tmp/ccQRkz1D.s:2725   .data:00000000 $d
     /tmp/ccQRkz1D.s:8720   .text:00000c5c $t

UNDEFINED SYMBOLS
ip_route
tcp_output
memp_malloc
pbuf_ref
pbuf_free
memp_free
__udivsi3
tcp_zero_window_probe
tcp_rexmit_rto
tcp_keepalive
tcp_rst
memset
lwip_stats
tcp_timer_needed
tcp_enqueue
tcp_send_ctrl
