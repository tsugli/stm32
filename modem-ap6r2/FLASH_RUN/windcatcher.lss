
FLASH_RUN/windcatcher.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001c10  08000000  08000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000110  20000000  08001c10  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000031d0  20000110  08001d20  00010110  2**3
                  ALLOC
  3 ._usrstack    00000100  200032e0  200032e0  00010110  2**0
                  CONTENTS
  4 .comment      0000002a  00000000  00000000  00010210  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00001018  00000000  00000000  0001023a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000026d8  00000000  00000000  00011252  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000b889  00000000  00000000  0001392a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000218c  00000000  00000000  0001f1b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00004718  00000000  00000000  0002133f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000033b8  00000000  00000000  00025a58  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00004966  00000000  00000000  00028e10  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00005bc0  00000000  00000000  0002d776  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000fbd  00000000  00000000  00033336  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000e78  00000000  00000000  000342f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .ARM.attributes 00000031  00000000  00000000  0003516b  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08000000 <g_pfnVectorsStartup>:
 8000000:	00 c0 00 20 35 01 00 08                             ... 5...

08000008 <memset>:
 8000008:	2a03      	cmp	r2, #3
 800000a:	b2c9      	uxtb	r1, r1
 800000c:	b470      	push	{r4, r5, r6}
 800000e:	d808      	bhi.n	8000022 <memset+0x1a>
 8000010:	b12a      	cbz	r2, 800001e <memset+0x16>
 8000012:	4603      	mov	r3, r0
 8000014:	1812      	adds	r2, r2, r0
 8000016:	f803 1b01 	strb.w	r1, [r3], #1
 800001a:	4293      	cmp	r3, r2
 800001c:	d1fb      	bne.n	8000016 <memset+0xe>
 800001e:	bc70      	pop	{r4, r5, r6}
 8000020:	4770      	bx	lr
 8000022:	1882      	adds	r2, r0, r2
 8000024:	4604      	mov	r4, r0
 8000026:	e001      	b.n	800002c <memset+0x24>
 8000028:	f804 1b01 	strb.w	r1, [r4], #1
 800002c:	f014 0f03 	tst.w	r4, #3
 8000030:	d1fa      	bne.n	8000028 <memset+0x20>
 8000032:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 8000036:	fb03 f301 	mul.w	r3, r3, r1
 800003a:	e01f      	b.n	800007c <memset+0x74>
 800003c:	f844 3c40 	str.w	r3, [r4, #-64]
 8000040:	f844 3c3c 	str.w	r3, [r4, #-60]
 8000044:	f844 3c38 	str.w	r3, [r4, #-56]
 8000048:	f844 3c34 	str.w	r3, [r4, #-52]
 800004c:	f844 3c30 	str.w	r3, [r4, #-48]
 8000050:	f844 3c2c 	str.w	r3, [r4, #-44]
 8000054:	f844 3c28 	str.w	r3, [r4, #-40]
 8000058:	f844 3c24 	str.w	r3, [r4, #-36]
 800005c:	f844 3c20 	str.w	r3, [r4, #-32]
 8000060:	f844 3c1c 	str.w	r3, [r4, #-28]
 8000064:	f844 3c18 	str.w	r3, [r4, #-24]
 8000068:	f844 3c14 	str.w	r3, [r4, #-20]
 800006c:	f844 3c10 	str.w	r3, [r4, #-16]
 8000070:	f844 3c0c 	str.w	r3, [r4, #-12]
 8000074:	f844 3c08 	str.w	r3, [r4, #-8]
 8000078:	f844 3c04 	str.w	r3, [r4, #-4]
 800007c:	1b16      	subs	r6, r2, r4
 800007e:	4625      	mov	r5, r4
 8000080:	3440      	adds	r4, #64	; 0x40
 8000082:	2e3f      	cmp	r6, #63	; 0x3f
 8000084:	dcda      	bgt.n	800003c <memset+0x34>
 8000086:	462c      	mov	r4, r5
 8000088:	e007      	b.n	800009a <memset+0x92>
 800008a:	f844 3c10 	str.w	r3, [r4, #-16]
 800008e:	f844 3c0c 	str.w	r3, [r4, #-12]
 8000092:	f844 3c08 	str.w	r3, [r4, #-8]
 8000096:	f844 3c04 	str.w	r3, [r4, #-4]
 800009a:	1b16      	subs	r6, r2, r4
 800009c:	4625      	mov	r5, r4
 800009e:	3410      	adds	r4, #16
 80000a0:	2e0f      	cmp	r6, #15
 80000a2:	dcf2      	bgt.n	800008a <memset+0x82>
 80000a4:	e001      	b.n	80000aa <memset+0xa2>
 80000a6:	f845 3b04 	str.w	r3, [r5], #4
 80000aa:	1b54      	subs	r4, r2, r5
 80000ac:	2c03      	cmp	r4, #3
 80000ae:	dcfa      	bgt.n	80000a6 <memset+0x9e>
 80000b0:	e001      	b.n	80000b6 <memset+0xae>
 80000b2:	f805 1b01 	strb.w	r1, [r5], #1
 80000b6:	4295      	cmp	r5, r2
 80000b8:	d3fb      	bcc.n	80000b2 <memset+0xaa>
 80000ba:	e7b0      	b.n	800001e <memset+0x16>

080000bc <strncpy>:
 80000bc:	ea41 0300 	orr.w	r3, r1, r0
 80000c0:	f013 0f03 	tst.w	r3, #3
 80000c4:	460b      	mov	r3, r1
 80000c6:	b470      	push	{r4, r5, r6}
 80000c8:	bf14      	ite	ne
 80000ca:	2400      	movne	r4, #0
 80000cc:	2401      	moveq	r4, #1
 80000ce:	2a03      	cmp	r2, #3
 80000d0:	bf94      	ite	ls
 80000d2:	2400      	movls	r4, #0
 80000d4:	f004 0401 	andhi.w	r4, r4, #1
 80000d8:	4605      	mov	r5, r0
 80000da:	b9d4      	cbnz	r4, 8000112 <strncpy+0x56>
 80000dc:	b1ba      	cbz	r2, 800010e <strncpy+0x52>
 80000de:	780e      	ldrb	r6, [r1, #0]
 80000e0:	462b      	mov	r3, r5
 80000e2:	3a01      	subs	r2, #1
 80000e4:	f803 6b01 	strb.w	r6, [r3], #1
 80000e8:	b156      	cbz	r6, 8000100 <strncpy+0x44>
 80000ea:	1cac      	adds	r4, r5, #2
 80000ec:	b17a      	cbz	r2, 800010e <strncpy+0x52>
 80000ee:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 80000f2:	4623      	mov	r3, r4
 80000f4:	3a01      	subs	r2, #1
 80000f6:	f804 5c01 	strb.w	r5, [r4, #-1]
 80000fa:	3401      	adds	r4, #1
 80000fc:	2d00      	cmp	r5, #0
 80000fe:	d1f5      	bne.n	80000ec <strncpy+0x30>
 8000100:	b12a      	cbz	r2, 800010e <strncpy+0x52>
 8000102:	189a      	adds	r2, r3, r2
 8000104:	2100      	movs	r1, #0
 8000106:	f803 1b01 	strb.w	r1, [r3], #1
 800010a:	4293      	cmp	r3, r2
 800010c:	d1fb      	bne.n	8000106 <strncpy+0x4a>
 800010e:	bc70      	pop	{r4, r5, r6}
 8000110:	4770      	bx	lr
 8000112:	4619      	mov	r1, r3
 8000114:	f853 4b04 	ldr.w	r4, [r3], #4
 8000118:	f1a4 3601 	sub.w	r6, r4, #16843009	; 0x1010101
 800011c:	ea26 0604 	bic.w	r6, r6, r4
 8000120:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
 8000124:	d1da      	bne.n	80000dc <strncpy+0x20>
 8000126:	3a04      	subs	r2, #4
 8000128:	f845 4b04 	str.w	r4, [r5], #4
 800012c:	2a03      	cmp	r2, #3
 800012e:	4619      	mov	r1, r3
 8000130:	d8ef      	bhi.n	8000112 <strncpy+0x56>
 8000132:	e7d3      	b.n	80000dc <strncpy+0x20>

08000134 <Reset_Handler>:
 * @param  None
 * @retval : None
*/

void Reset_Handler(void)
{
 8000134:	4668      	mov	r0, sp
 8000136:	f020 0107 	bic.w	r1, r0, #7
 800013a:	468d      	mov	sp, r1
 800013c:	b581      	push	{r0, r7, lr}
 800013e:	b083      	sub	sp, #12
 8000140:	af00      	add	r7, sp, #0

#ifdef STARTUP_DELAY
  volatile unsigned long i;
  for (i=0;i<500000;i++) { ; }
 8000142:	f04f 0300 	mov.w	r3, #0
 8000146:	607b      	str	r3, [r7, #4]
 8000148:	e003      	b.n	8000152 <Reset_Handler+0x1e>
 800014a:	687b      	ldr	r3, [r7, #4]
 800014c:	f103 0301 	add.w	r3, r3, #1
 8000150:	607b      	str	r3, [r7, #4]
 8000152:	687a      	ldr	r2, [r7, #4]
 8000154:	4b03      	ldr	r3, [pc, #12]	; (8000164 <Reset_Handler+0x30>)
 8000156:	429a      	cmp	r2, r3
 8000158:	d9f7      	bls.n	800014a <Reset_Handler+0x16>
#endif

  /* Initialize data and bss */
  __Init_Data();
 800015a:	4b03      	ldr	r3, [pc, #12]	; (8000168 <Reset_Handler+0x34>)
 800015c:	4798      	blx	r3

  /* Call the application's entry point.*/
  main();
 800015e:	4b03      	ldr	r3, [pc, #12]	; (800016c <Reset_Handler+0x38>)
 8000160:	4798      	blx	r3

  while(1) { ; }
 8000162:	e7fe      	b.n	8000162 <Reset_Handler+0x2e>
 8000164:	0007a11f 	.word	0x0007a11f
 8000168:	08000171 	.word	0x08000171
 800016c:	08001ad5 	.word	0x08001ad5

08000170 <__Init_Data>:
 * @param  None
 * @retval : None
*/

void __Init_Data(void)
{
 8000170:	b480      	push	{r7}
 8000172:	b083      	sub	sp, #12
 8000174:	af00      	add	r7, sp, #0
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc  = &_sidata;
 8000176:	4b16      	ldr	r3, [pc, #88]	; (80001d0 <__Init_Data+0x60>)
 8000178:	607b      	str	r3, [r7, #4]
  pulDest = &_sdata;
 800017a:	4b16      	ldr	r3, [pc, #88]	; (80001d4 <__Init_Data+0x64>)
 800017c:	603b      	str	r3, [r7, #0]
  if ( pulSrc != pulDest )
 800017e:	687a      	ldr	r2, [r7, #4]
 8000180:	683b      	ldr	r3, [r7, #0]
 8000182:	429a      	cmp	r2, r3
 8000184:	d010      	beq.n	80001a8 <__Init_Data+0x38>
  {
    for(; pulDest < &_edata; )
 8000186:	e00b      	b.n	80001a0 <__Init_Data+0x30>
    {
      *(pulDest++) = *(pulSrc++);
 8000188:	687b      	ldr	r3, [r7, #4]
 800018a:	681a      	ldr	r2, [r3, #0]
 800018c:	683b      	ldr	r3, [r7, #0]
 800018e:	601a      	str	r2, [r3, #0]
 8000190:	683b      	ldr	r3, [r7, #0]
 8000192:	f103 0304 	add.w	r3, r3, #4
 8000196:	603b      	str	r3, [r7, #0]
 8000198:	687b      	ldr	r3, [r7, #4]
 800019a:	f103 0304 	add.w	r3, r3, #4
 800019e:	607b      	str	r3, [r7, #4]
  /* Copy the data segment initializers from flash to SRAM */
  pulSrc  = &_sidata;
  pulDest = &_sdata;
  if ( pulSrc != pulDest )
  {
    for(; pulDest < &_edata; )
 80001a0:	683a      	ldr	r2, [r7, #0]
 80001a2:	4b0d      	ldr	r3, [pc, #52]	; (80001d8 <__Init_Data+0x68>)
 80001a4:	429a      	cmp	r2, r3
 80001a6:	d3ef      	bcc.n	8000188 <__Init_Data+0x18>
    {
      *(pulDest++) = *(pulSrc++);
    }
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 80001a8:	4b0c      	ldr	r3, [pc, #48]	; (80001dc <__Init_Data+0x6c>)
 80001aa:	603b      	str	r3, [r7, #0]
 80001ac:	e007      	b.n	80001be <__Init_Data+0x4e>
  {
    *(pulDest++) = 0;
 80001ae:	683b      	ldr	r3, [r7, #0]
 80001b0:	f04f 0200 	mov.w	r2, #0
 80001b4:	601a      	str	r2, [r3, #0]
 80001b6:	683b      	ldr	r3, [r7, #0]
 80001b8:	f103 0304 	add.w	r3, r3, #4
 80001bc:	603b      	str	r3, [r7, #0]
    {
      *(pulDest++) = *(pulSrc++);
    }
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 80001be:	683a      	ldr	r2, [r7, #0]
 80001c0:	4b07      	ldr	r3, [pc, #28]	; (80001e0 <__Init_Data+0x70>)
 80001c2:	429a      	cmp	r2, r3
 80001c4:	d3f3      	bcc.n	80001ae <__Init_Data+0x3e>
  {
    *(pulDest++) = 0;
  }
}
 80001c6:	f107 070c 	add.w	r7, r7, #12
 80001ca:	46bd      	mov	sp, r7
 80001cc:	bc80      	pop	{r7}
 80001ce:	4770      	bx	lr
 80001d0:	08001c10 	.word	0x08001c10
 80001d4:	20000000 	.word	0x20000000
 80001d8:	20000110 	.word	0x20000110
 80001dc:	20000110 	.word	0x20000110
 80001e0:	200032e0 	.word	0x200032e0

080001e4 <Default_Handler>:
 * @param  None
 * @retval : None
*/

void Default_Handler(void)
{
 80001e4:	b480      	push	{r7}
 80001e6:	af00      	add	r7, sp, #0
  /* Go into an infinite loop. */
  while (1)
  {
  }
 80001e8:	e7fe      	b.n	80001e8 <Default_Handler+0x4>
 80001ea:	bf00      	nop

080001ec <RCC_Configuration>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void RCC_Configuration(void)
{
 80001ec:	b580      	push	{r7, lr}
 80001ee:	af00      	add	r7, sp, #0
	/* RCC system reset(for debug purpose) */
	RCC_DeInit();
 80001f0:	4b20      	ldr	r3, [pc, #128]	; (8000274 <RCC_Configuration+0x88>)
 80001f2:	4798      	blx	r3

	/* Enable HSE */
	RCC_HSEConfig(RCC_HSE_ON);
 80001f4:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80001f8:	4b1f      	ldr	r3, [pc, #124]	; (8000278 <RCC_Configuration+0x8c>)
 80001fa:	4798      	blx	r3

	/* Wait till HSE is ready */
	HSEStartUpStatus = RCC_WaitForHSEStartUp();
 80001fc:	4b1f      	ldr	r3, [pc, #124]	; (800027c <RCC_Configuration+0x90>)
 80001fe:	4798      	blx	r3
 8000200:	4603      	mov	r3, r0
 8000202:	461a      	mov	r2, r3
 8000204:	4b1e      	ldr	r3, [pc, #120]	; (8000280 <RCC_Configuration+0x94>)
 8000206:	701a      	strb	r2, [r3, #0]

	if (HSEStartUpStatus == SUCCESS)
 8000208:	4b1d      	ldr	r3, [pc, #116]	; (8000280 <RCC_Configuration+0x94>)
 800020a:	781b      	ldrb	r3, [r3, #0]
 800020c:	2b01      	cmp	r3, #1
 800020e:	d12f      	bne.n	8000270 <RCC_Configuration+0x84>
	{
		/* Enable Prefetch Buffer */
		FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 8000210:	f04f 0010 	mov.w	r0, #16
 8000214:	4b1b      	ldr	r3, [pc, #108]	; (8000284 <RCC_Configuration+0x98>)
 8000216:	4798      	blx	r3

		/* Flash 2 wait state */
		FLASH_SetLatency(FLASH_Latency_2);
 8000218:	f04f 0002 	mov.w	r0, #2
 800021c:	4b1a      	ldr	r3, [pc, #104]	; (8000288 <RCC_Configuration+0x9c>)
 800021e:	4798      	blx	r3

		/* HCLK = SYSCLK */
		RCC_HCLKConfig(RCC_SYSCLK_Div1);
 8000220:	f04f 0000 	mov.w	r0, #0
 8000224:	4b19      	ldr	r3, [pc, #100]	; (800028c <RCC_Configuration+0xa0>)
 8000226:	4798      	blx	r3

		/* PCLK2 = HCLK */
		RCC_PCLK2Config(RCC_HCLK_Div1);
 8000228:	f04f 0000 	mov.w	r0, #0
 800022c:	4b18      	ldr	r3, [pc, #96]	; (8000290 <RCC_Configuration+0xa4>)
 800022e:	4798      	blx	r3

		/* PCLK1 = HCLK/2 */
		RCC_PCLK1Config(RCC_HCLK_Div2);
 8000230:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000234:	4b17      	ldr	r3, [pc, #92]	; (8000294 <RCC_Configuration+0xa8>)
 8000236:	4798      	blx	r3

		/* PLLCLK = 8MHz * 9 = 72 MHz */
		RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
 8000238:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800023c:	f44f 11e0 	mov.w	r1, #1835008	; 0x1c0000
 8000240:	4b15      	ldr	r3, [pc, #84]	; (8000298 <RCC_Configuration+0xac>)
 8000242:	4798      	blx	r3

		/* Enable PLL */
		RCC_PLLCmd(ENABLE);
 8000244:	f04f 0001 	mov.w	r0, #1
 8000248:	4b14      	ldr	r3, [pc, #80]	; (800029c <RCC_Configuration+0xb0>)
 800024a:	4798      	blx	r3

		/* Wait till PLL is ready */
		while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
 800024c:	bf00      	nop
 800024e:	f04f 0039 	mov.w	r0, #57	; 0x39
 8000252:	4b13      	ldr	r3, [pc, #76]	; (80002a0 <RCC_Configuration+0xb4>)
 8000254:	4798      	blx	r3
 8000256:	4603      	mov	r3, r0
 8000258:	2b00      	cmp	r3, #0
 800025a:	d0f8      	beq.n	800024e <RCC_Configuration+0x62>
		{
		}

		/* Select PLL as system clock source */
		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 800025c:	f04f 0002 	mov.w	r0, #2
 8000260:	4b10      	ldr	r3, [pc, #64]	; (80002a4 <RCC_Configuration+0xb8>)
 8000262:	4798      	blx	r3

		/* Wait till PLL is used as system clock source */
		while (RCC_GetSYSCLKSource() != 0x08)
 8000264:	bf00      	nop
 8000266:	4b10      	ldr	r3, [pc, #64]	; (80002a8 <RCC_Configuration+0xbc>)
 8000268:	4798      	blx	r3
 800026a:	4603      	mov	r3, r0
 800026c:	2b08      	cmp	r3, #8
 800026e:	d1fa      	bne.n	8000266 <RCC_Configuration+0x7a>
		{
		}
	}
}
 8000270:	bd80      	pop	{r7, pc}
 8000272:	bf00      	nop
 8000274:	08001295 	.word	0x08001295
 8000278:	080012f1 	.word	0x080012f1
 800027c:	0800134d 	.word	0x0800134d
 8000280:	20002a90 	.word	0x20002a90
 8000284:	0800106d 	.word	0x0800106d
 8000288:	08001031 	.word	0x08001031
 800028c:	08001471 	.word	0x08001471
 8000290:	080014e9 	.word	0x080014e9
 8000294:	080014ad 	.word	0x080014ad
 8000298:	080013b5 	.word	0x080013b5
 800029c:	080013f9 	.word	0x080013f9
 80002a0:	0800156d 	.word	0x0800156d
 80002a4:	08001419 	.word	0x08001419
 80002a8:	08001455 	.word	0x08001455

080002ac <NVIC_Configuration>:
 *******************************************************************************/
#ifdef VECT_TAB_RAM
/* vector-offset (TBLOFF) from bottom of SRAM. defined in linker script */
extern uint32_t _isr_vectorsram_offs;
void NVIC_Configuration(void)
{
 80002ac:	b580      	push	{r7, lr}
 80002ae:	af00      	add	r7, sp, #0
	/* Set the Vector Table base location at 0x20000000+_isr_vectorsram_offs */
	NVIC_SetVectorTable(NVIC_VectTab_RAM, (uint32_t) &_isr_vectorsram_offs);
 80002b0:	4b03      	ldr	r3, [pc, #12]	; (80002c0 <NVIC_Configuration+0x14>)
 80002b2:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 80002b6:	4619      	mov	r1, r3
 80002b8:	4b02      	ldr	r3, [pc, #8]	; (80002c4 <NVIC_Configuration+0x18>)
 80002ba:	4798      	blx	r3
}
 80002bc:	bd80      	pop	{r7, pc}
 80002be:	bf00      	nop
 80002c0:	00000000 	.word	0x00000000
 80002c4:	08001899 	.word	0x08001899

080002c8 <hwInit>:
}
#endif


void hwInit()
{
 80002c8:	b580      	push	{r7, lr}
 80002ca:	af00      	add	r7, sp, #0
	/* System Clocks Configuration */
	RCC_Configuration();
 80002cc:	4b02      	ldr	r3, [pc, #8]	; (80002d8 <hwInit+0x10>)
 80002ce:	4798      	blx	r3

	/* NVIC configuration */
	NVIC_Configuration();
 80002d0:	4b02      	ldr	r3, [pc, #8]	; (80002dc <hwInit+0x14>)
 80002d2:	4798      	blx	r3


}
 80002d4:	bd80      	pop	{r7, pc}
 80002d6:	bf00      	nop
 80002d8:	080001ed 	.word	0x080001ed
 80002dc:	080002ad 	.word	0x080002ad

080002e0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 80002e0:	b590      	push	{r4, r7, lr}
 80002e2:	b08b      	sub	sp, #44	; 0x2c
 80002e4:	af02      	add	r7, sp, #8
 80002e6:	60f8      	str	r0, [r7, #12]
 80002e8:	60b9      	str	r1, [r7, #8]
 80002ea:	603b      	str	r3, [r7, #0]
 80002ec:	4613      	mov	r3, r2
 80002ee:	80fb      	strh	r3, [r7, #6]
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 80002f0:	88fb      	ldrh	r3, [r7, #6]
 80002f2:	4618      	mov	r0, r3
 80002f4:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80002f6:	4b49      	ldr	r3, [pc, #292]	; (800041c <xTaskGenericCreate+0x13c>)
 80002f8:	4798      	blx	r3
 80002fa:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
 80002fc:	69bb      	ldr	r3, [r7, #24]
 80002fe:	2b00      	cmp	r3, #0
 8000300:	d06e      	beq.n	80003e0 <xTaskGenericCreate+0x100>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 8000302:	69bb      	ldr	r3, [r7, #24]
 8000304:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000306:	88fb      	ldrh	r3, [r7, #6]
 8000308:	f103 33ff 	add.w	r3, r3, #4294967295
 800030c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000310:	18d3      	adds	r3, r2, r3
 8000312:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
 8000314:	697b      	ldr	r3, [r7, #20]
 8000316:	f023 0307 	bic.w	r3, r3, #7
 800031a:	617b      	str	r3, [r7, #20]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 800031c:	88fb      	ldrh	r3, [r7, #6]
 800031e:	9300      	str	r3, [sp, #0]
 8000320:	69b8      	ldr	r0, [r7, #24]
 8000322:	68b9      	ldr	r1, [r7, #8]
 8000324:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8000326:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8000328:	4c3d      	ldr	r4, [pc, #244]	; (8000420 <xTaskGenericCreate+0x140>)
 800032a:	47a0      	blx	r4
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800032c:	6978      	ldr	r0, [r7, #20]
 800032e:	68f9      	ldr	r1, [r7, #12]
 8000330:	683a      	ldr	r2, [r7, #0]
 8000332:	4b3c      	ldr	r3, [pc, #240]	; (8000424 <xTaskGenericCreate+0x144>)
 8000334:	4798      	blx	r3
 8000336:	4603      	mov	r3, r0
 8000338:	461a      	mov	r2, r3
 800033a:	69bb      	ldr	r3, [r7, #24]
 800033c:	601a      	str	r2, [r3, #0]
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
 800033e:	4b3a      	ldr	r3, [pc, #232]	; (8000428 <xTaskGenericCreate+0x148>)
 8000340:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
 8000342:	4b3a      	ldr	r3, [pc, #232]	; (800042c <xTaskGenericCreate+0x14c>)
 8000344:	681b      	ldr	r3, [r3, #0]
 8000346:	f103 0201 	add.w	r2, r3, #1
 800034a:	4b38      	ldr	r3, [pc, #224]	; (800042c <xTaskGenericCreate+0x14c>)
 800034c:	601a      	str	r2, [r3, #0]
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 800034e:	4b37      	ldr	r3, [pc, #220]	; (800042c <xTaskGenericCreate+0x14c>)
 8000350:	681b      	ldr	r3, [r3, #0]
 8000352:	2b01      	cmp	r3, #1
 8000354:	d105      	bne.n	8000362 <xTaskGenericCreate+0x82>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 8000356:	4b36      	ldr	r3, [pc, #216]	; (8000430 <xTaskGenericCreate+0x150>)
 8000358:	69ba      	ldr	r2, [r7, #24]
 800035a:	601a      	str	r2, [r3, #0]

				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 800035c:	4b35      	ldr	r3, [pc, #212]	; (8000434 <xTaskGenericCreate+0x154>)
 800035e:	4798      	blx	r3
 8000360:	e00c      	b.n	800037c <xTaskGenericCreate+0x9c>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8000362:	4b35      	ldr	r3, [pc, #212]	; (8000438 <xTaskGenericCreate+0x158>)
 8000364:	681b      	ldr	r3, [r3, #0]
 8000366:	2b00      	cmp	r3, #0
 8000368:	d108      	bne.n	800037c <xTaskGenericCreate+0x9c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 800036a:	4b31      	ldr	r3, [pc, #196]	; (8000430 <xTaskGenericCreate+0x150>)
 800036c:	681b      	ldr	r3, [r3, #0]
 800036e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000370:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8000372:	429a      	cmp	r2, r3
 8000374:	d802      	bhi.n	800037c <xTaskGenericCreate+0x9c>
					{
						pxCurrentTCB = pxNewTCB;
 8000376:	4b2e      	ldr	r3, [pc, #184]	; (8000430 <xTaskGenericCreate+0x150>)
 8000378:	69ba      	ldr	r2, [r7, #24]
 800037a:	601a      	str	r2, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 800037c:	69bb      	ldr	r3, [r7, #24]
 800037e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000380:	4b2e      	ldr	r3, [pc, #184]	; (800043c <xTaskGenericCreate+0x15c>)
 8000382:	681b      	ldr	r3, [r3, #0]
 8000384:	429a      	cmp	r2, r3
 8000386:	d903      	bls.n	8000390 <xTaskGenericCreate+0xb0>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 8000388:	69bb      	ldr	r3, [r7, #24]
 800038a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800038c:	4b2b      	ldr	r3, [pc, #172]	; (800043c <xTaskGenericCreate+0x15c>)
 800038e:	601a      	str	r2, [r3, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 8000390:	4b2b      	ldr	r3, [pc, #172]	; (8000440 <xTaskGenericCreate+0x160>)
 8000392:	681b      	ldr	r3, [r3, #0]
 8000394:	f103 0201 	add.w	r2, r3, #1
 8000398:	4b29      	ldr	r3, [pc, #164]	; (8000440 <xTaskGenericCreate+0x160>)
 800039a:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 800039c:	69bb      	ldr	r3, [r7, #24]
 800039e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80003a0:	4b28      	ldr	r3, [pc, #160]	; (8000444 <xTaskGenericCreate+0x164>)
 80003a2:	681b      	ldr	r3, [r3, #0]
 80003a4:	429a      	cmp	r2, r3
 80003a6:	d903      	bls.n	80003b0 <xTaskGenericCreate+0xd0>
 80003a8:	69bb      	ldr	r3, [r7, #24]
 80003aa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80003ac:	4b25      	ldr	r3, [pc, #148]	; (8000444 <xTaskGenericCreate+0x164>)
 80003ae:	601a      	str	r2, [r3, #0]
 80003b0:	69bb      	ldr	r3, [r7, #24]
 80003b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80003b4:	4613      	mov	r3, r2
 80003b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80003ba:	189b      	adds	r3, r3, r2
 80003bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80003c0:	461a      	mov	r2, r3
 80003c2:	4b21      	ldr	r3, [pc, #132]	; (8000448 <xTaskGenericCreate+0x168>)
 80003c4:	18d2      	adds	r2, r2, r3
 80003c6:	69bb      	ldr	r3, [r7, #24]
 80003c8:	f103 0304 	add.w	r3, r3, #4
 80003cc:	4610      	mov	r0, r2
 80003ce:	4619      	mov	r1, r3
 80003d0:	4b1e      	ldr	r3, [pc, #120]	; (800044c <xTaskGenericCreate+0x16c>)
 80003d2:	4798      	blx	r3

			xReturn = pdPASS;
 80003d4:	f04f 0301 	mov.w	r3, #1
 80003d8:	61fb      	str	r3, [r7, #28]
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
 80003da:	4b1d      	ldr	r3, [pc, #116]	; (8000450 <xTaskGenericCreate+0x170>)
 80003dc:	4798      	blx	r3
 80003de:	e002      	b.n	80003e6 <xTaskGenericCreate+0x106>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80003e0:	f04f 33ff 	mov.w	r3, #4294967295
 80003e4:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
 80003e6:	69fb      	ldr	r3, [r7, #28]
 80003e8:	2b01      	cmp	r3, #1
 80003ea:	d111      	bne.n	8000410 <xTaskGenericCreate+0x130>
	{
		if( ( void * ) pxCreatedTask != NULL )
 80003ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80003ee:	2b00      	cmp	r3, #0
 80003f0:	d002      	beq.n	80003f8 <xTaskGenericCreate+0x118>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 80003f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80003f4:	69ba      	ldr	r2, [r7, #24]
 80003f6:	601a      	str	r2, [r3, #0]
		}

		if( xSchedulerRunning != pdFALSE )
 80003f8:	4b0f      	ldr	r3, [pc, #60]	; (8000438 <xTaskGenericCreate+0x158>)
 80003fa:	681b      	ldr	r3, [r3, #0]
 80003fc:	2b00      	cmp	r3, #0
 80003fe:	d007      	beq.n	8000410 <xTaskGenericCreate+0x130>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8000400:	4b0b      	ldr	r3, [pc, #44]	; (8000430 <xTaskGenericCreate+0x150>)
 8000402:	681b      	ldr	r3, [r3, #0]
 8000404:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000406:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8000408:	429a      	cmp	r2, r3
 800040a:	d201      	bcs.n	8000410 <xTaskGenericCreate+0x130>
			{
				portYIELD_WITHIN_API();
 800040c:	4b11      	ldr	r3, [pc, #68]	; (8000454 <xTaskGenericCreate+0x174>)
 800040e:	4798      	blx	r3
			}
		}
	}

	return xReturn;
 8000410:	69fb      	ldr	r3, [r7, #28]
}
 8000412:	4618      	mov	r0, r3
 8000414:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8000418:	46bd      	mov	sp, r7
 800041a:	bd90      	pop	{r4, r7, pc}
 800041c:	08000a55 	.word	0x08000a55
 8000420:	080008a1 	.word	0x080008a1
 8000424:	08000c6d 	.word	0x08000c6d
 8000428:	08000d59 	.word	0x08000d59
 800042c:	2000024c 	.word	0x2000024c
 8000430:	20000110 	.word	0x20000110
 8000434:	08000925 	.word	0x08000925
 8000438:	2000025c 	.word	0x2000025c
 800043c:	20000254 	.word	0x20000254
 8000440:	20000270 	.word	0x20000270
 8000444:	20000258 	.word	0x20000258
 8000448:	20000114 	.word	0x20000114
 800044c:	08000b55 	.word	0x08000b55
 8000450:	08000d7d 	.word	0x08000d7d
 8000454:	08000d41 	.word	0x08000d41

08000458 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8000458:	b580      	push	{r7, lr}
 800045a:	b084      	sub	sp, #16
 800045c:	af00      	add	r7, sp, #0
 800045e:	6078      	str	r0, [r7, #4]
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8000460:	f04f 0300 	mov.w	r3, #0
 8000464:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
 8000466:	687b      	ldr	r3, [r7, #4]
 8000468:	2b00      	cmp	r3, #0
 800046a:	d02e      	beq.n	80004ca <vTaskDelay+0x72>
		{
			vTaskSuspendAll();
 800046c:	4b1b      	ldr	r3, [pc, #108]	; (80004dc <vTaskDelay+0x84>)
 800046e:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8000470:	4b1b      	ldr	r3, [pc, #108]	; (80004e0 <vTaskDelay+0x88>)
 8000472:	681a      	ldr	r2, [r3, #0]
 8000474:	687b      	ldr	r3, [r7, #4]
 8000476:	18d3      	adds	r3, r2, r3
 8000478:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800047a:	4b1a      	ldr	r3, [pc, #104]	; (80004e4 <vTaskDelay+0x8c>)
 800047c:	681b      	ldr	r3, [r3, #0]
 800047e:	f103 0304 	add.w	r3, r3, #4
 8000482:	4618      	mov	r0, r3
 8000484:	4b18      	ldr	r3, [pc, #96]	; (80004e8 <vTaskDelay+0x90>)
 8000486:	4798      	blx	r3

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8000488:	4b16      	ldr	r3, [pc, #88]	; (80004e4 <vTaskDelay+0x8c>)
 800048a:	681b      	ldr	r3, [r3, #0]
 800048c:	68ba      	ldr	r2, [r7, #8]
 800048e:	605a      	str	r2, [r3, #4]

				if( xTimeToWake < xTickCount )
 8000490:	4b13      	ldr	r3, [pc, #76]	; (80004e0 <vTaskDelay+0x88>)
 8000492:	681b      	ldr	r3, [r3, #0]
 8000494:	68ba      	ldr	r2, [r7, #8]
 8000496:	429a      	cmp	r2, r3
 8000498:	d20a      	bcs.n	80004b0 <vTaskDelay+0x58>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800049a:	4b14      	ldr	r3, [pc, #80]	; (80004ec <vTaskDelay+0x94>)
 800049c:	681a      	ldr	r2, [r3, #0]
 800049e:	4b11      	ldr	r3, [pc, #68]	; (80004e4 <vTaskDelay+0x8c>)
 80004a0:	681b      	ldr	r3, [r3, #0]
 80004a2:	f103 0304 	add.w	r3, r3, #4
 80004a6:	4610      	mov	r0, r2
 80004a8:	4619      	mov	r1, r3
 80004aa:	4b11      	ldr	r3, [pc, #68]	; (80004f0 <vTaskDelay+0x98>)
 80004ac:	4798      	blx	r3
 80004ae:	e009      	b.n	80004c4 <vTaskDelay+0x6c>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 80004b0:	4b10      	ldr	r3, [pc, #64]	; (80004f4 <vTaskDelay+0x9c>)
 80004b2:	681a      	ldr	r2, [r3, #0]
 80004b4:	4b0b      	ldr	r3, [pc, #44]	; (80004e4 <vTaskDelay+0x8c>)
 80004b6:	681b      	ldr	r3, [r3, #0]
 80004b8:	f103 0304 	add.w	r3, r3, #4
 80004bc:	4610      	mov	r0, r2
 80004be:	4619      	mov	r1, r3
 80004c0:	4b0b      	ldr	r3, [pc, #44]	; (80004f0 <vTaskDelay+0x98>)
 80004c2:	4798      	blx	r3
				}
			}
			xAlreadyYielded = xTaskResumeAll();
 80004c4:	4b0c      	ldr	r3, [pc, #48]	; (80004f8 <vTaskDelay+0xa0>)
 80004c6:	4798      	blx	r3
 80004c8:	60f8      	str	r0, [r7, #12]
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 80004ca:	68fb      	ldr	r3, [r7, #12]
 80004cc:	2b00      	cmp	r3, #0
 80004ce:	d101      	bne.n	80004d4 <vTaskDelay+0x7c>
		{
			portYIELD_WITHIN_API();
 80004d0:	4b0a      	ldr	r3, [pc, #40]	; (80004fc <vTaskDelay+0xa4>)
 80004d2:	4798      	blx	r3
		}
	}
 80004d4:	f107 0710 	add.w	r7, r7, #16
 80004d8:	46bd      	mov	sp, r7
 80004da:	bd80      	pop	{r7, pc}
 80004dc:	08000575 	.word	0x08000575
 80004e0:	20000250 	.word	0x20000250
 80004e4:	20000110 	.word	0x20000110
 80004e8:	08000c19 	.word	0x08000c19
 80004ec:	20000208 	.word	0x20000208
 80004f0:	08000ba5 	.word	0x08000ba5
 80004f4:	20000204 	.word	0x20000204
 80004f8:	08000591 	.word	0x08000591
 80004fc:	08000d41 	.word	0x08000d41

08000500 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 8000500:	b590      	push	{r4, r7, lr}
 8000502:	b087      	sub	sp, #28
 8000504:	af04      	add	r7, sp, #16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 8000506:	4b15      	ldr	r3, [pc, #84]	; (800055c <vTaskStartScheduler+0x5c>)
 8000508:	f04f 0200 	mov.w	r2, #0
 800050c:	9200      	str	r2, [sp, #0]
 800050e:	f04f 0200 	mov.w	r2, #0
 8000512:	9201      	str	r2, [sp, #4]
 8000514:	f04f 0200 	mov.w	r2, #0
 8000518:	9202      	str	r2, [sp, #8]
 800051a:	f04f 0200 	mov.w	r2, #0
 800051e:	9203      	str	r2, [sp, #12]
 8000520:	480f      	ldr	r0, [pc, #60]	; (8000560 <vTaskStartScheduler+0x60>)
 8000522:	4619      	mov	r1, r3
 8000524:	f04f 0280 	mov.w	r2, #128	; 0x80
 8000528:	f04f 0300 	mov.w	r3, #0
 800052c:	4c0d      	ldr	r4, [pc, #52]	; (8000564 <vTaskStartScheduler+0x64>)
 800052e:	47a0      	blx	r4
 8000530:	6078      	str	r0, [r7, #4]

	if( xReturn == pdPASS )
 8000532:	687b      	ldr	r3, [r7, #4]
 8000534:	2b01      	cmp	r3, #1
 8000536:	d10d      	bne.n	8000554 <vTaskStartScheduler+0x54>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 8000538:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 800053c:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 8000540:	4b09      	ldr	r3, [pc, #36]	; (8000568 <vTaskStartScheduler+0x68>)
 8000542:	f04f 0201 	mov.w	r2, #1
 8000546:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0;
 8000548:	4b08      	ldr	r3, [pc, #32]	; (800056c <vTaskStartScheduler+0x6c>)
 800054a:	f04f 0200 	mov.w	r2, #0
 800054e:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
 8000550:	4b07      	ldr	r3, [pc, #28]	; (8000570 <vTaskStartScheduler+0x70>)
 8000552:	4798      	blx	r3
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
 8000554:	f107 070c 	add.w	r7, r7, #12
 8000558:	46bd      	mov	sp, r7
 800055a:	bd90      	pop	{r4, r7, pc}
 800055c:	08001bfc 	.word	0x08001bfc
 8000560:	08000875 	.word	0x08000875
 8000564:	080002e1 	.word	0x080002e1
 8000568:	2000025c 	.word	0x2000025c
 800056c:	20000250 	.word	0x20000250
 8000570:	08000cfd 	.word	0x08000cfd

08000574 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 8000574:	b480      	push	{r7}
 8000576:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8000578:	4b04      	ldr	r3, [pc, #16]	; (800058c <vTaskSuspendAll+0x18>)
 800057a:	681b      	ldr	r3, [r3, #0]
 800057c:	f103 0201 	add.w	r2, r3, #1
 8000580:	4b02      	ldr	r3, [pc, #8]	; (800058c <vTaskSuspendAll+0x18>)
 8000582:	601a      	str	r2, [r3, #0]
}
 8000584:	46bd      	mov	sp, r7
 8000586:	bc80      	pop	{r7}
 8000588:	4770      	bx	lr
 800058a:	bf00      	nop
 800058c:	20000260 	.word	0x20000260

08000590 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 8000590:	b590      	push	{r4, r7, lr}
 8000592:	b083      	sub	sp, #12
 8000594:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8000596:	f04f 0300 	mov.w	r3, #0
 800059a:	607b      	str	r3, [r7, #4]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
 800059c:	4b3b      	ldr	r3, [pc, #236]	; (800068c <xTaskResumeAll+0xfc>)
 800059e:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
 80005a0:	4b3b      	ldr	r3, [pc, #236]	; (8000690 <xTaskResumeAll+0x100>)
 80005a2:	681b      	ldr	r3, [r3, #0]
 80005a4:	f103 32ff 	add.w	r2, r3, #4294967295
 80005a8:	4b39      	ldr	r3, [pc, #228]	; (8000690 <xTaskResumeAll+0x100>)
 80005aa:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80005ac:	4b38      	ldr	r3, [pc, #224]	; (8000690 <xTaskResumeAll+0x100>)
 80005ae:	681b      	ldr	r3, [r3, #0]
 80005b0:	2b00      	cmp	r3, #0
 80005b2:	d163      	bne.n	800067c <xTaskResumeAll+0xec>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 80005b4:	4b37      	ldr	r3, [pc, #220]	; (8000694 <xTaskResumeAll+0x104>)
 80005b6:	681b      	ldr	r3, [r3, #0]
 80005b8:	2b00      	cmp	r3, #0
 80005ba:	d05f      	beq.n	800067c <xTaskResumeAll+0xec>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 80005bc:	f04f 0300 	mov.w	r3, #0
 80005c0:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 80005c2:	e02a      	b.n	800061a <xTaskResumeAll+0x8a>
				{
					vListRemove( &( pxTCB->xEventListItem ) );
 80005c4:	f104 0318 	add.w	r3, r4, #24
 80005c8:	4618      	mov	r0, r3
 80005ca:	4b33      	ldr	r3, [pc, #204]	; (8000698 <xTaskResumeAll+0x108>)
 80005cc:	4798      	blx	r3
					vListRemove( &( pxTCB->xGenericListItem ) );
 80005ce:	f104 0304 	add.w	r3, r4, #4
 80005d2:	4618      	mov	r0, r3
 80005d4:	4b30      	ldr	r3, [pc, #192]	; (8000698 <xTaskResumeAll+0x108>)
 80005d6:	4798      	blx	r3
					prvAddTaskToReadyQueue( pxTCB );
 80005d8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80005da:	4b30      	ldr	r3, [pc, #192]	; (800069c <xTaskResumeAll+0x10c>)
 80005dc:	681b      	ldr	r3, [r3, #0]
 80005de:	429a      	cmp	r2, r3
 80005e0:	d902      	bls.n	80005e8 <xTaskResumeAll+0x58>
 80005e2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80005e4:	4b2d      	ldr	r3, [pc, #180]	; (800069c <xTaskResumeAll+0x10c>)
 80005e6:	601a      	str	r2, [r3, #0]
 80005e8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80005ea:	4613      	mov	r3, r2
 80005ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80005f0:	189b      	adds	r3, r3, r2
 80005f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80005f6:	461a      	mov	r2, r3
 80005f8:	4b29      	ldr	r3, [pc, #164]	; (80006a0 <xTaskResumeAll+0x110>)
 80005fa:	18d2      	adds	r2, r2, r3
 80005fc:	f104 0304 	add.w	r3, r4, #4
 8000600:	4610      	mov	r0, r2
 8000602:	4619      	mov	r1, r3
 8000604:	4b27      	ldr	r3, [pc, #156]	; (80006a4 <xTaskResumeAll+0x114>)
 8000606:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000608:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800060a:	4b27      	ldr	r3, [pc, #156]	; (80006a8 <xTaskResumeAll+0x118>)
 800060c:	681b      	ldr	r3, [r3, #0]
 800060e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000610:	429a      	cmp	r2, r3
 8000612:	d302      	bcc.n	800061a <xTaskResumeAll+0x8a>
					{
						xYieldRequired = pdTRUE;
 8000614:	f04f 0301 	mov.w	r3, #1
 8000618:	603b      	str	r3, [r7, #0]
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 800061a:	4b24      	ldr	r3, [pc, #144]	; (80006ac <xTaskResumeAll+0x11c>)
 800061c:	681b      	ldr	r3, [r3, #0]
 800061e:	2b00      	cmp	r3, #0
 8000620:	d003      	beq.n	800062a <xTaskResumeAll+0x9a>
 8000622:	4b22      	ldr	r3, [pc, #136]	; (80006ac <xTaskResumeAll+0x11c>)
 8000624:	68db      	ldr	r3, [r3, #12]
 8000626:	68db      	ldr	r3, [r3, #12]
 8000628:	e001      	b.n	800062e <xTaskResumeAll+0x9e>
 800062a:	f04f 0300 	mov.w	r3, #0
 800062e:	461c      	mov	r4, r3
 8000630:	2c00      	cmp	r4, #0
 8000632:	d1c7      	bne.n	80005c4 <xTaskResumeAll+0x34>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 8000634:	4b1e      	ldr	r3, [pc, #120]	; (80006b0 <xTaskResumeAll+0x120>)
 8000636:	681b      	ldr	r3, [r3, #0]
 8000638:	2b00      	cmp	r3, #0
 800063a:	d00f      	beq.n	800065c <xTaskResumeAll+0xcc>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 800063c:	e007      	b.n	800064e <xTaskResumeAll+0xbe>
					{
						vTaskIncrementTick();
 800063e:	4b1d      	ldr	r3, [pc, #116]	; (80006b4 <xTaskResumeAll+0x124>)
 8000640:	4798      	blx	r3
						--uxMissedTicks;
 8000642:	4b1b      	ldr	r3, [pc, #108]	; (80006b0 <xTaskResumeAll+0x120>)
 8000644:	681b      	ldr	r3, [r3, #0]
 8000646:	f103 32ff 	add.w	r2, r3, #4294967295
 800064a:	4b19      	ldr	r3, [pc, #100]	; (80006b0 <xTaskResumeAll+0x120>)
 800064c:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 800064e:	4b18      	ldr	r3, [pc, #96]	; (80006b0 <xTaskResumeAll+0x120>)
 8000650:	681b      	ldr	r3, [r3, #0]
 8000652:	2b00      	cmp	r3, #0
 8000654:	d1f3      	bne.n	800063e <xTaskResumeAll+0xae>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 8000656:	f04f 0301 	mov.w	r3, #1
 800065a:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 800065c:	683b      	ldr	r3, [r7, #0]
 800065e:	2b01      	cmp	r3, #1
 8000660:	d003      	beq.n	800066a <xTaskResumeAll+0xda>
 8000662:	4b15      	ldr	r3, [pc, #84]	; (80006b8 <xTaskResumeAll+0x128>)
 8000664:	681b      	ldr	r3, [r3, #0]
 8000666:	2b01      	cmp	r3, #1
 8000668:	d108      	bne.n	800067c <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
 800066a:	f04f 0301 	mov.w	r3, #1
 800066e:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
 8000670:	4b11      	ldr	r3, [pc, #68]	; (80006b8 <xTaskResumeAll+0x128>)
 8000672:	f04f 0200 	mov.w	r2, #0
 8000676:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 8000678:	4b10      	ldr	r3, [pc, #64]	; (80006bc <xTaskResumeAll+0x12c>)
 800067a:	4798      	blx	r3
				}
			}
		}
	}
	portEXIT_CRITICAL();
 800067c:	4b10      	ldr	r3, [pc, #64]	; (80006c0 <xTaskResumeAll+0x130>)
 800067e:	4798      	blx	r3

	return xAlreadyYielded;
 8000680:	687b      	ldr	r3, [r7, #4]
}
 8000682:	4618      	mov	r0, r3
 8000684:	f107 070c 	add.w	r7, r7, #12
 8000688:	46bd      	mov	sp, r7
 800068a:	bd90      	pop	{r4, r7, pc}
 800068c:	08000d59 	.word	0x08000d59
 8000690:	20000260 	.word	0x20000260
 8000694:	2000024c 	.word	0x2000024c
 8000698:	08000c19 	.word	0x08000c19
 800069c:	20000258 	.word	0x20000258
 80006a0:	20000114 	.word	0x20000114
 80006a4:	08000b55 	.word	0x08000b55
 80006a8:	20000110 	.word	0x20000110
 80006ac:	2000020c 	.word	0x2000020c
 80006b0:	20000264 	.word	0x20000264
 80006b4:	080006c5 	.word	0x080006c5
 80006b8:	20000268 	.word	0x20000268
 80006bc:	08000d41 	.word	0x08000d41
 80006c0:	08000d7d 	.word	0x08000d7d

080006c4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
 80006c4:	b590      	push	{r4, r7, lr}
 80006c6:	b083      	sub	sp, #12
 80006c8:	af00      	add	r7, sp, #0
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80006ca:	4b35      	ldr	r3, [pc, #212]	; (80007a0 <vTaskIncrementTick+0xdc>)
 80006cc:	681b      	ldr	r3, [r3, #0]
 80006ce:	2b00      	cmp	r3, #0
 80006d0:	d154      	bne.n	800077c <vTaskIncrementTick+0xb8>
	{
		++xTickCount;
 80006d2:	4b34      	ldr	r3, [pc, #208]	; (80007a4 <vTaskIncrementTick+0xe0>)
 80006d4:	681b      	ldr	r3, [r3, #0]
 80006d6:	f103 0201 	add.w	r2, r3, #1
 80006da:	4b32      	ldr	r3, [pc, #200]	; (80007a4 <vTaskIncrementTick+0xe0>)
 80006dc:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0 )
 80006de:	4b31      	ldr	r3, [pc, #196]	; (80007a4 <vTaskIncrementTick+0xe0>)
 80006e0:	681b      	ldr	r3, [r3, #0]
 80006e2:	2b00      	cmp	r3, #0
 80006e4:	d13a      	bne.n	800075c <vTaskIncrementTick+0x98>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 80006e6:	4b30      	ldr	r3, [pc, #192]	; (80007a8 <vTaskIncrementTick+0xe4>)
 80006e8:	681b      	ldr	r3, [r3, #0]
 80006ea:	607b      	str	r3, [r7, #4]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 80006ec:	4b2f      	ldr	r3, [pc, #188]	; (80007ac <vTaskIncrementTick+0xe8>)
 80006ee:	681a      	ldr	r2, [r3, #0]
 80006f0:	4b2d      	ldr	r3, [pc, #180]	; (80007a8 <vTaskIncrementTick+0xe4>)
 80006f2:	601a      	str	r2, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
 80006f4:	4b2d      	ldr	r3, [pc, #180]	; (80007ac <vTaskIncrementTick+0xe8>)
 80006f6:	687a      	ldr	r2, [r7, #4]
 80006f8:	601a      	str	r2, [r3, #0]
			xNumOfOverflows++;
 80006fa:	4b2d      	ldr	r3, [pc, #180]	; (80007b0 <vTaskIncrementTick+0xec>)
 80006fc:	681b      	ldr	r3, [r3, #0]
 80006fe:	f103 0201 	add.w	r2, r3, #1
 8000702:	4b2b      	ldr	r3, [pc, #172]	; (80007b0 <vTaskIncrementTick+0xec>)
 8000704:	601a      	str	r2, [r3, #0]
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8000706:	e029      	b.n	800075c <vTaskIncrementTick+0x98>
 8000708:	6862      	ldr	r2, [r4, #4]
 800070a:	4b26      	ldr	r3, [pc, #152]	; (80007a4 <vTaskIncrementTick+0xe0>)
 800070c:	681b      	ldr	r3, [r3, #0]
 800070e:	429a      	cmp	r2, r3
 8000710:	d83c      	bhi.n	800078c <vTaskIncrementTick+0xc8>
 8000712:	f104 0304 	add.w	r3, r4, #4
 8000716:	4618      	mov	r0, r3
 8000718:	4b26      	ldr	r3, [pc, #152]	; (80007b4 <vTaskIncrementTick+0xf0>)
 800071a:	4798      	blx	r3
 800071c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800071e:	2b00      	cmp	r3, #0
 8000720:	d004      	beq.n	800072c <vTaskIncrementTick+0x68>
 8000722:	f104 0318 	add.w	r3, r4, #24
 8000726:	4618      	mov	r0, r3
 8000728:	4b22      	ldr	r3, [pc, #136]	; (80007b4 <vTaskIncrementTick+0xf0>)
 800072a:	4798      	blx	r3
 800072c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800072e:	4b22      	ldr	r3, [pc, #136]	; (80007b8 <vTaskIncrementTick+0xf4>)
 8000730:	681b      	ldr	r3, [r3, #0]
 8000732:	429a      	cmp	r2, r3
 8000734:	d902      	bls.n	800073c <vTaskIncrementTick+0x78>
 8000736:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000738:	4b1f      	ldr	r3, [pc, #124]	; (80007b8 <vTaskIncrementTick+0xf4>)
 800073a:	601a      	str	r2, [r3, #0]
 800073c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800073e:	4613      	mov	r3, r2
 8000740:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000744:	189b      	adds	r3, r3, r2
 8000746:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800074a:	461a      	mov	r2, r3
 800074c:	4b1b      	ldr	r3, [pc, #108]	; (80007bc <vTaskIncrementTick+0xf8>)
 800074e:	18d2      	adds	r2, r2, r3
 8000750:	f104 0304 	add.w	r3, r4, #4
 8000754:	4610      	mov	r0, r2
 8000756:	4619      	mov	r1, r3
 8000758:	4b19      	ldr	r3, [pc, #100]	; (80007c0 <vTaskIncrementTick+0xfc>)
 800075a:	4798      	blx	r3
 800075c:	4b12      	ldr	r3, [pc, #72]	; (80007a8 <vTaskIncrementTick+0xe4>)
 800075e:	681b      	ldr	r3, [r3, #0]
 8000760:	681b      	ldr	r3, [r3, #0]
 8000762:	2b00      	cmp	r3, #0
 8000764:	d004      	beq.n	8000770 <vTaskIncrementTick+0xac>
 8000766:	4b10      	ldr	r3, [pc, #64]	; (80007a8 <vTaskIncrementTick+0xe4>)
 8000768:	681b      	ldr	r3, [r3, #0]
 800076a:	68db      	ldr	r3, [r3, #12]
 800076c:	68db      	ldr	r3, [r3, #12]
 800076e:	e001      	b.n	8000774 <vTaskIncrementTick+0xb0>
 8000770:	f04f 0300 	mov.w	r3, #0
 8000774:	461c      	mov	r4, r3
 8000776:	2c00      	cmp	r4, #0
 8000778:	d1c6      	bne.n	8000708 <vTaskIncrementTick+0x44>
 800077a:	e007      	b.n	800078c <vTaskIncrementTick+0xc8>
	}
	else
	{
		++uxMissedTicks;
 800077c:	4b11      	ldr	r3, [pc, #68]	; (80007c4 <vTaskIncrementTick+0x100>)
 800077e:	681b      	ldr	r3, [r3, #0]
 8000780:	f103 0201 	add.w	r2, r3, #1
 8000784:	4b0f      	ldr	r3, [pc, #60]	; (80007c4 <vTaskIncrementTick+0x100>)
 8000786:	601a      	str	r2, [r3, #0]
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
 8000788:	4b0f      	ldr	r3, [pc, #60]	; (80007c8 <vTaskIncrementTick+0x104>)
 800078a:	4798      	blx	r3
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
 800078c:	4b0d      	ldr	r3, [pc, #52]	; (80007c4 <vTaskIncrementTick+0x100>)
 800078e:	681b      	ldr	r3, [r3, #0]
 8000790:	2b00      	cmp	r3, #0
 8000792:	d101      	bne.n	8000798 <vTaskIncrementTick+0xd4>
		{
			vApplicationTickHook();
 8000794:	4b0c      	ldr	r3, [pc, #48]	; (80007c8 <vTaskIncrementTick+0x104>)
 8000796:	4798      	blx	r3
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 8000798:	f107 070c 	add.w	r7, r7, #12
 800079c:	46bd      	mov	sp, r7
 800079e:	bd90      	pop	{r4, r7, pc}
 80007a0:	20000260 	.word	0x20000260
 80007a4:	20000250 	.word	0x20000250
 80007a8:	20000204 	.word	0x20000204
 80007ac:	20000208 	.word	0x20000208
 80007b0:	2000026c 	.word	0x2000026c
 80007b4:	08000c19 	.word	0x08000c19
 80007b8:	20000258 	.word	0x20000258
 80007bc:	20000114 	.word	0x20000114
 80007c0:	08000b55 	.word	0x08000b55
 80007c4:	20000264 	.word	0x20000264
 80007c8:	08001b2d 	.word	0x08001b2d

080007cc <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 80007cc:	b480      	push	{r7}
 80007ce:	b083      	sub	sp, #12
 80007d0:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 80007d2:	4b23      	ldr	r3, [pc, #140]	; (8000860 <vTaskSwitchContext+0x94>)
 80007d4:	681b      	ldr	r3, [r3, #0]
 80007d6:	2b00      	cmp	r3, #0
 80007d8:	d00b      	beq.n	80007f2 <vTaskSwitchContext+0x26>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 80007da:	4b22      	ldr	r3, [pc, #136]	; (8000864 <vTaskSwitchContext+0x98>)
 80007dc:	f04f 0201 	mov.w	r2, #1
 80007e0:	601a      	str	r2, [r3, #0]
		return;
 80007e2:	e038      	b.n	8000856 <vTaskSwitchContext+0x8a>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
 80007e4:	4b20      	ldr	r3, [pc, #128]	; (8000868 <vTaskSwitchContext+0x9c>)
 80007e6:	681b      	ldr	r3, [r3, #0]
 80007e8:	f103 32ff 	add.w	r2, r3, #4294967295
 80007ec:	4b1e      	ldr	r3, [pc, #120]	; (8000868 <vTaskSwitchContext+0x9c>)
 80007ee:	601a      	str	r2, [r3, #0]
 80007f0:	e000      	b.n	80007f4 <vTaskSwitchContext+0x28>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 80007f2:	bf00      	nop
 80007f4:	4b1c      	ldr	r3, [pc, #112]	; (8000868 <vTaskSwitchContext+0x9c>)
 80007f6:	681a      	ldr	r2, [r3, #0]
 80007f8:	4613      	mov	r3, r2
 80007fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80007fe:	189b      	adds	r3, r3, r2
 8000800:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000804:	461a      	mov	r2, r3
 8000806:	4b19      	ldr	r3, [pc, #100]	; (800086c <vTaskSwitchContext+0xa0>)
 8000808:	18d3      	adds	r3, r2, r3
 800080a:	681b      	ldr	r3, [r3, #0]
 800080c:	2b00      	cmp	r3, #0
 800080e:	d0e9      	beq.n	80007e4 <vTaskSwitchContext+0x18>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 8000810:	4b15      	ldr	r3, [pc, #84]	; (8000868 <vTaskSwitchContext+0x9c>)
 8000812:	681a      	ldr	r2, [r3, #0]
 8000814:	4613      	mov	r3, r2
 8000816:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800081a:	189b      	adds	r3, r3, r2
 800081c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000820:	461a      	mov	r2, r3
 8000822:	4b12      	ldr	r3, [pc, #72]	; (800086c <vTaskSwitchContext+0xa0>)
 8000824:	18d3      	adds	r3, r2, r3
 8000826:	607b      	str	r3, [r7, #4]
 8000828:	687b      	ldr	r3, [r7, #4]
 800082a:	685b      	ldr	r3, [r3, #4]
 800082c:	685a      	ldr	r2, [r3, #4]
 800082e:	687b      	ldr	r3, [r7, #4]
 8000830:	605a      	str	r2, [r3, #4]
 8000832:	687b      	ldr	r3, [r7, #4]
 8000834:	685a      	ldr	r2, [r3, #4]
 8000836:	687b      	ldr	r3, [r7, #4]
 8000838:	f103 0308 	add.w	r3, r3, #8
 800083c:	429a      	cmp	r2, r3
 800083e:	d104      	bne.n	800084a <vTaskSwitchContext+0x7e>
 8000840:	687b      	ldr	r3, [r7, #4]
 8000842:	685b      	ldr	r3, [r3, #4]
 8000844:	685a      	ldr	r2, [r3, #4]
 8000846:	687b      	ldr	r3, [r7, #4]
 8000848:	605a      	str	r2, [r3, #4]
 800084a:	687b      	ldr	r3, [r7, #4]
 800084c:	685b      	ldr	r3, [r3, #4]
 800084e:	68db      	ldr	r3, [r3, #12]
 8000850:	461a      	mov	r2, r3
 8000852:	4b07      	ldr	r3, [pc, #28]	; (8000870 <vTaskSwitchContext+0xa4>)
 8000854:	601a      	str	r2, [r3, #0]

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
 8000856:	f107 070c 	add.w	r7, r7, #12
 800085a:	46bd      	mov	sp, r7
 800085c:	bc80      	pop	{r7}
 800085e:	4770      	bx	lr
 8000860:	20000260 	.word	0x20000260
 8000864:	20000268 	.word	0x20000268
 8000868:	20000258 	.word	0x20000258
 800086c:	20000114 	.word	0x20000114
 8000870:	20000110 	.word	0x20000110

08000874 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8000874:	b580      	push	{r7, lr}
 8000876:	b082      	sub	sp, #8
 8000878:	af00      	add	r7, sp, #0
 800087a:	6078      	str	r0, [r7, #4]
 800087c:	e000      	b.n	8000880 <prvIdleTask+0xc>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 800087e:	bf00      	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 8000880:	4b04      	ldr	r3, [pc, #16]	; (8000894 <prvIdleTask+0x20>)
 8000882:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8000884:	4b04      	ldr	r3, [pc, #16]	; (8000898 <prvIdleTask+0x24>)
 8000886:	681b      	ldr	r3, [r3, #0]
 8000888:	2b01      	cmp	r3, #1
 800088a:	d9f8      	bls.n	800087e <prvIdleTask+0xa>
			{
				taskYIELD();
 800088c:	4b03      	ldr	r3, [pc, #12]	; (800089c <prvIdleTask+0x28>)
 800088e:	4798      	blx	r3
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 8000890:	e7f6      	b.n	8000880 <prvIdleTask+0xc>
 8000892:	bf00      	nop
 8000894:	080009b1 	.word	0x080009b1
 8000898:	20000114 	.word	0x20000114
 800089c:	08000d41 	.word	0x08000d41

080008a0 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 80008a0:	b580      	push	{r7, lr}
 80008a2:	b084      	sub	sp, #16
 80008a4:	af00      	add	r7, sp, #0
 80008a6:	60f8      	str	r0, [r7, #12]
 80008a8:	60b9      	str	r1, [r7, #8]
 80008aa:	607a      	str	r2, [r7, #4]
 80008ac:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 80008ae:	68fb      	ldr	r3, [r7, #12]
 80008b0:	f103 0334 	add.w	r3, r3, #52	; 0x34
 80008b4:	461a      	mov	r2, r3
 80008b6:	68bb      	ldr	r3, [r7, #8]
 80008b8:	4610      	mov	r0, r2
 80008ba:	4619      	mov	r1, r3
 80008bc:	f04f 0210 	mov.w	r2, #16
 80008c0:	4b16      	ldr	r3, [pc, #88]	; (800091c <prvInitialiseTCBVariables+0x7c>)
 80008c2:	4798      	blx	r3
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 80008c4:	68fb      	ldr	r3, [r7, #12]
 80008c6:	f04f 0200 	mov.w	r2, #0
 80008ca:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 80008ce:	687b      	ldr	r3, [r7, #4]
 80008d0:	2b09      	cmp	r3, #9
 80008d2:	d902      	bls.n	80008da <prvInitialiseTCBVariables+0x3a>
	{
		uxPriority = configMAX_PRIORITIES - 1;
 80008d4:	f04f 0309 	mov.w	r3, #9
 80008d8:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
 80008da:	68fb      	ldr	r3, [r7, #12]
 80008dc:	687a      	ldr	r2, [r7, #4]
 80008de:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 80008e0:	68fb      	ldr	r3, [r7, #12]
 80008e2:	687a      	ldr	r2, [r7, #4]
 80008e4:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80008e6:	68fb      	ldr	r3, [r7, #12]
 80008e8:	f103 0304 	add.w	r3, r3, #4
 80008ec:	4618      	mov	r0, r3
 80008ee:	4b0c      	ldr	r3, [pc, #48]	; (8000920 <prvInitialiseTCBVariables+0x80>)
 80008f0:	4798      	blx	r3
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 80008f2:	68fb      	ldr	r3, [r7, #12]
 80008f4:	f103 0318 	add.w	r3, r3, #24
 80008f8:	4618      	mov	r0, r3
 80008fa:	4b09      	ldr	r3, [pc, #36]	; (8000920 <prvInitialiseTCBVariables+0x80>)
 80008fc:	4798      	blx	r3

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 80008fe:	68fb      	ldr	r3, [r7, #12]
 8000900:	68fa      	ldr	r2, [r7, #12]
 8000902:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8000904:	687b      	ldr	r3, [r7, #4]
 8000906:	f1c3 020a 	rsb	r2, r3, #10
 800090a:	68fb      	ldr	r3, [r7, #12]
 800090c:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 800090e:	68fb      	ldr	r3, [r7, #12]
 8000910:	68fa      	ldr	r2, [r7, #12]
 8000912:	625a      	str	r2, [r3, #36]	; 0x24
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 8000914:	f107 0710 	add.w	r7, r7, #16
 8000918:	46bd      	mov	sp, r7
 800091a:	bd80      	pop	{r7, pc}
 800091c:	080000bd 	.word	0x080000bd
 8000920:	08000b39 	.word	0x08000b39

08000924 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 8000924:	b580      	push	{r7, lr}
 8000926:	b082      	sub	sp, #8
 8000928:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800092a:	f04f 0300 	mov.w	r3, #0
 800092e:	607b      	str	r3, [r7, #4]
 8000930:	e010      	b.n	8000954 <prvInitialiseTaskLists+0x30>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8000932:	687a      	ldr	r2, [r7, #4]
 8000934:	4613      	mov	r3, r2
 8000936:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800093a:	189b      	adds	r3, r3, r2
 800093c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000940:	461a      	mov	r2, r3
 8000942:	4b12      	ldr	r3, [pc, #72]	; (800098c <prvInitialiseTaskLists+0x68>)
 8000944:	18d3      	adds	r3, r2, r3
 8000946:	4618      	mov	r0, r3
 8000948:	4b11      	ldr	r3, [pc, #68]	; (8000990 <prvInitialiseTaskLists+0x6c>)
 800094a:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800094c:	687b      	ldr	r3, [r7, #4]
 800094e:	f103 0301 	add.w	r3, r3, #1
 8000952:	607b      	str	r3, [r7, #4]
 8000954:	687b      	ldr	r3, [r7, #4]
 8000956:	2b09      	cmp	r3, #9
 8000958:	d9eb      	bls.n	8000932 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 800095a:	480e      	ldr	r0, [pc, #56]	; (8000994 <prvInitialiseTaskLists+0x70>)
 800095c:	4b0c      	ldr	r3, [pc, #48]	; (8000990 <prvInitialiseTaskLists+0x6c>)
 800095e:	4798      	blx	r3
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8000960:	480d      	ldr	r0, [pc, #52]	; (8000998 <prvInitialiseTaskLists+0x74>)
 8000962:	4b0b      	ldr	r3, [pc, #44]	; (8000990 <prvInitialiseTaskLists+0x6c>)
 8000964:	4798      	blx	r3
	vListInitialise( ( xList * ) &xPendingReadyList );
 8000966:	480d      	ldr	r0, [pc, #52]	; (800099c <prvInitialiseTaskLists+0x78>)
 8000968:	4b09      	ldr	r3, [pc, #36]	; (8000990 <prvInitialiseTaskLists+0x6c>)
 800096a:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 800096c:	480c      	ldr	r0, [pc, #48]	; (80009a0 <prvInitialiseTaskLists+0x7c>)
 800096e:	4b08      	ldr	r3, [pc, #32]	; (8000990 <prvInitialiseTaskLists+0x6c>)
 8000970:	4798      	blx	r3
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 8000972:	480c      	ldr	r0, [pc, #48]	; (80009a4 <prvInitialiseTaskLists+0x80>)
 8000974:	4b06      	ldr	r3, [pc, #24]	; (8000990 <prvInitialiseTaskLists+0x6c>)
 8000976:	4798      	blx	r3
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8000978:	4b0b      	ldr	r3, [pc, #44]	; (80009a8 <prvInitialiseTaskLists+0x84>)
 800097a:	4a06      	ldr	r2, [pc, #24]	; (8000994 <prvInitialiseTaskLists+0x70>)
 800097c:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800097e:	4b0b      	ldr	r3, [pc, #44]	; (80009ac <prvInitialiseTaskLists+0x88>)
 8000980:	4a05      	ldr	r2, [pc, #20]	; (8000998 <prvInitialiseTaskLists+0x74>)
 8000982:	601a      	str	r2, [r3, #0]
}
 8000984:	f107 0708 	add.w	r7, r7, #8
 8000988:	46bd      	mov	sp, r7
 800098a:	bd80      	pop	{r7, pc}
 800098c:	20000114 	.word	0x20000114
 8000990:	08000af1 	.word	0x08000af1
 8000994:	200001dc 	.word	0x200001dc
 8000998:	200001f0 	.word	0x200001f0
 800099c:	2000020c 	.word	0x2000020c
 80009a0:	20000220 	.word	0x20000220
 80009a4:	20000238 	.word	0x20000238
 80009a8:	20000204 	.word	0x20000204
 80009ac:	20000208 	.word	0x20000208

080009b0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 80009b0:	b580      	push	{r7, lr}
 80009b2:	b082      	sub	sp, #8
 80009b4:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 80009b6:	4b1d      	ldr	r3, [pc, #116]	; (8000a2c <prvCheckTasksWaitingTermination+0x7c>)
 80009b8:	681b      	ldr	r3, [r3, #0]
 80009ba:	2b00      	cmp	r3, #0
 80009bc:	d031      	beq.n	8000a22 <prvCheckTasksWaitingTermination+0x72>
		{
			vTaskSuspendAll();
 80009be:	4b1c      	ldr	r3, [pc, #112]	; (8000a30 <prvCheckTasksWaitingTermination+0x80>)
 80009c0:	4798      	blx	r3
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80009c2:	4b1c      	ldr	r3, [pc, #112]	; (8000a34 <prvCheckTasksWaitingTermination+0x84>)
 80009c4:	681b      	ldr	r3, [r3, #0]
 80009c6:	2b00      	cmp	r3, #0
 80009c8:	bf14      	ite	ne
 80009ca:	2300      	movne	r3, #0
 80009cc:	2301      	moveq	r3, #1
 80009ce:	607b      	str	r3, [r7, #4]
			xTaskResumeAll();
 80009d0:	4b19      	ldr	r3, [pc, #100]	; (8000a38 <prvCheckTasksWaitingTermination+0x88>)
 80009d2:	4798      	blx	r3

			if( !xListIsEmpty )
 80009d4:	687b      	ldr	r3, [r7, #4]
 80009d6:	2b00      	cmp	r3, #0
 80009d8:	d123      	bne.n	8000a22 <prvCheckTasksWaitingTermination+0x72>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
 80009da:	4b18      	ldr	r3, [pc, #96]	; (8000a3c <prvCheckTasksWaitingTermination+0x8c>)
 80009dc:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 80009de:	4b15      	ldr	r3, [pc, #84]	; (8000a34 <prvCheckTasksWaitingTermination+0x84>)
 80009e0:	681b      	ldr	r3, [r3, #0]
 80009e2:	2b00      	cmp	r3, #0
 80009e4:	d003      	beq.n	80009ee <prvCheckTasksWaitingTermination+0x3e>
 80009e6:	4b16      	ldr	r3, [pc, #88]	; (8000a40 <prvCheckTasksWaitingTermination+0x90>)
 80009e8:	685b      	ldr	r3, [r3, #4]
 80009ea:	68db      	ldr	r3, [r3, #12]
 80009ec:	e001      	b.n	80009f2 <prvCheckTasksWaitingTermination+0x42>
 80009ee:	f04f 0300 	mov.w	r3, #0
 80009f2:	603b      	str	r3, [r7, #0]
					vListRemove( &( pxTCB->xGenericListItem ) );
 80009f4:	683b      	ldr	r3, [r7, #0]
 80009f6:	f103 0304 	add.w	r3, r3, #4
 80009fa:	4618      	mov	r0, r3
 80009fc:	4b11      	ldr	r3, [pc, #68]	; (8000a44 <prvCheckTasksWaitingTermination+0x94>)
 80009fe:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
 8000a00:	4b11      	ldr	r3, [pc, #68]	; (8000a48 <prvCheckTasksWaitingTermination+0x98>)
 8000a02:	681b      	ldr	r3, [r3, #0]
 8000a04:	f103 32ff 	add.w	r2, r3, #4294967295
 8000a08:	4b0f      	ldr	r3, [pc, #60]	; (8000a48 <prvCheckTasksWaitingTermination+0x98>)
 8000a0a:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
 8000a0c:	4b07      	ldr	r3, [pc, #28]	; (8000a2c <prvCheckTasksWaitingTermination+0x7c>)
 8000a0e:	681b      	ldr	r3, [r3, #0]
 8000a10:	f103 32ff 	add.w	r2, r3, #4294967295
 8000a14:	4b05      	ldr	r3, [pc, #20]	; (8000a2c <prvCheckTasksWaitingTermination+0x7c>)
 8000a16:	601a      	str	r2, [r3, #0]
				}
				portEXIT_CRITICAL();
 8000a18:	4b0c      	ldr	r3, [pc, #48]	; (8000a4c <prvCheckTasksWaitingTermination+0x9c>)
 8000a1a:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
 8000a1c:	6838      	ldr	r0, [r7, #0]
 8000a1e:	4b0c      	ldr	r3, [pc, #48]	; (8000a50 <prvCheckTasksWaitingTermination+0xa0>)
 8000a20:	4798      	blx	r3
			}
		}
	}
	#endif
}
 8000a22:	f107 0708 	add.w	r7, r7, #8
 8000a26:	46bd      	mov	sp, r7
 8000a28:	bd80      	pop	{r7, pc}
 8000a2a:	bf00      	nop
 8000a2c:	20000234 	.word	0x20000234
 8000a30:	08000575 	.word	0x08000575
 8000a34:	20000220 	.word	0x20000220
 8000a38:	08000591 	.word	0x08000591
 8000a3c:	08000d59 	.word	0x08000d59
 8000a40:	20000228 	.word	0x20000228
 8000a44:	08000c19 	.word	0x08000c19
 8000a48:	2000024c 	.word	0x2000024c
 8000a4c:	08000d7d 	.word	0x08000d7d
 8000a50:	08000acd 	.word	0x08000acd

08000a54 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 8000a54:	b580      	push	{r7, lr}
 8000a56:	b084      	sub	sp, #16
 8000a58:	af00      	add	r7, sp, #0
 8000a5a:	4603      	mov	r3, r0
 8000a5c:	6039      	str	r1, [r7, #0]
 8000a5e:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8000a60:	f04f 0048 	mov.w	r0, #72	; 0x48
 8000a64:	4b16      	ldr	r3, [pc, #88]	; (8000ac0 <prvAllocateTCBAndStack+0x6c>)
 8000a66:	4798      	blx	r3
 8000a68:	4603      	mov	r3, r0
 8000a6a:	60fb      	str	r3, [r7, #12]

	if( pxNewTCB != NULL )
 8000a6c:	68fb      	ldr	r3, [r7, #12]
 8000a6e:	2b00      	cmp	r3, #0
 8000a70:	d01f      	beq.n	8000ab2 <prvAllocateTCBAndStack+0x5e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 8000a72:	88fb      	ldrh	r3, [r7, #6]
 8000a74:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000a78:	4618      	mov	r0, r3
 8000a7a:	4b11      	ldr	r3, [pc, #68]	; (8000ac0 <prvAllocateTCBAndStack+0x6c>)
 8000a7c:	4798      	blx	r3
 8000a7e:	4603      	mov	r3, r0
 8000a80:	461a      	mov	r2, r3
 8000a82:	68fb      	ldr	r3, [r7, #12]
 8000a84:	631a      	str	r2, [r3, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8000a86:	68fb      	ldr	r3, [r7, #12]
 8000a88:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000a8a:	2b00      	cmp	r3, #0
 8000a8c:	d106      	bne.n	8000a9c <prvAllocateTCBAndStack+0x48>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8000a8e:	68f8      	ldr	r0, [r7, #12]
 8000a90:	4b0c      	ldr	r3, [pc, #48]	; (8000ac4 <prvAllocateTCBAndStack+0x70>)
 8000a92:	4798      	blx	r3
			pxNewTCB = NULL;
 8000a94:	f04f 0300 	mov.w	r3, #0
 8000a98:	60fb      	str	r3, [r7, #12]
 8000a9a:	e00a      	b.n	8000ab2 <prvAllocateTCBAndStack+0x5e>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 8000a9c:	68fb      	ldr	r3, [r7, #12]
 8000a9e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000aa0:	88fb      	ldrh	r3, [r7, #6]
 8000aa2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000aa6:	4610      	mov	r0, r2
 8000aa8:	f04f 01a5 	mov.w	r1, #165	; 0xa5
 8000aac:	461a      	mov	r2, r3
 8000aae:	4b06      	ldr	r3, [pc, #24]	; (8000ac8 <prvAllocateTCBAndStack+0x74>)
 8000ab0:	4798      	blx	r3
		}
	}

	return pxNewTCB;
 8000ab2:	68fb      	ldr	r3, [r7, #12]
}
 8000ab4:	4618      	mov	r0, r3
 8000ab6:	f107 0710 	add.w	r7, r7, #16
 8000aba:	46bd      	mov	sp, r7
 8000abc:	bd80      	pop	{r7, pc}
 8000abe:	bf00      	nop
 8000ac0:	08000e41 	.word	0x08000e41
 8000ac4:	08000fad 	.word	0x08000fad
 8000ac8:	08000009 	.word	0x08000009

08000acc <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
 8000acc:	b580      	push	{r7, lr}
 8000ace:	b082      	sub	sp, #8
 8000ad0:	af00      	add	r7, sp, #0
 8000ad2:	6078      	str	r0, [r7, #4]
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8000ad4:	687b      	ldr	r3, [r7, #4]
 8000ad6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000ad8:	4618      	mov	r0, r3
 8000ada:	4b04      	ldr	r3, [pc, #16]	; (8000aec <prvDeleteTCB+0x20>)
 8000adc:	4798      	blx	r3
		vPortFree( pxTCB );
 8000ade:	6878      	ldr	r0, [r7, #4]
 8000ae0:	4b02      	ldr	r3, [pc, #8]	; (8000aec <prvDeleteTCB+0x20>)
 8000ae2:	4798      	blx	r3
	}
 8000ae4:	f107 0708 	add.w	r7, r7, #8
 8000ae8:	46bd      	mov	sp, r7
 8000aea:	bd80      	pop	{r7, pc}
 8000aec:	08000fad 	.word	0x08000fad

08000af0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 8000af0:	b480      	push	{r7}
 8000af2:	b083      	sub	sp, #12
 8000af4:	af00      	add	r7, sp, #0
 8000af6:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8000af8:	687b      	ldr	r3, [r7, #4]
 8000afa:	f103 0308 	add.w	r3, r3, #8
 8000afe:	461a      	mov	r2, r3
 8000b00:	687b      	ldr	r3, [r7, #4]
 8000b02:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8000b04:	687b      	ldr	r3, [r7, #4]
 8000b06:	f04f 32ff 	mov.w	r2, #4294967295
 8000b0a:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8000b0c:	687b      	ldr	r3, [r7, #4]
 8000b0e:	f103 0308 	add.w	r3, r3, #8
 8000b12:	461a      	mov	r2, r3
 8000b14:	687b      	ldr	r3, [r7, #4]
 8000b16:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8000b18:	687b      	ldr	r3, [r7, #4]
 8000b1a:	f103 0308 	add.w	r3, r3, #8
 8000b1e:	461a      	mov	r2, r3
 8000b20:	687b      	ldr	r3, [r7, #4]
 8000b22:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = 0;
 8000b24:	687b      	ldr	r3, [r7, #4]
 8000b26:	f04f 0200 	mov.w	r2, #0
 8000b2a:	601a      	str	r2, [r3, #0]
}
 8000b2c:	f107 070c 	add.w	r7, r7, #12
 8000b30:	46bd      	mov	sp, r7
 8000b32:	bc80      	pop	{r7}
 8000b34:	4770      	bx	lr
 8000b36:	bf00      	nop

08000b38 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 8000b38:	b480      	push	{r7}
 8000b3a:	b083      	sub	sp, #12
 8000b3c:	af00      	add	r7, sp, #0
 8000b3e:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8000b40:	687b      	ldr	r3, [r7, #4]
 8000b42:	f04f 0200 	mov.w	r2, #0
 8000b46:	611a      	str	r2, [r3, #16]
}
 8000b48:	f107 070c 	add.w	r7, r7, #12
 8000b4c:	46bd      	mov	sp, r7
 8000b4e:	bc80      	pop	{r7}
 8000b50:	4770      	bx	lr
 8000b52:	bf00      	nop

08000b54 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 8000b54:	b480      	push	{r7}
 8000b56:	b085      	sub	sp, #20
 8000b58:	af00      	add	r7, sp, #0
 8000b5a:	6078      	str	r0, [r7, #4]
 8000b5c:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8000b5e:	687b      	ldr	r3, [r7, #4]
 8000b60:	685b      	ldr	r3, [r3, #4]
 8000b62:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8000b64:	68fb      	ldr	r3, [r7, #12]
 8000b66:	685a      	ldr	r2, [r3, #4]
 8000b68:	683b      	ldr	r3, [r7, #0]
 8000b6a:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8000b6c:	687b      	ldr	r3, [r7, #4]
 8000b6e:	685a      	ldr	r2, [r3, #4]
 8000b70:	683b      	ldr	r3, [r7, #0]
 8000b72:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8000b74:	68fb      	ldr	r3, [r7, #12]
 8000b76:	685b      	ldr	r3, [r3, #4]
 8000b78:	683a      	ldr	r2, [r7, #0]
 8000b7a:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8000b7c:	683a      	ldr	r2, [r7, #0]
 8000b7e:	68fb      	ldr	r3, [r7, #12]
 8000b80:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8000b82:	683a      	ldr	r2, [r7, #0]
 8000b84:	687b      	ldr	r3, [r7, #4]
 8000b86:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000b88:	683b      	ldr	r3, [r7, #0]
 8000b8a:	687a      	ldr	r2, [r7, #4]
 8000b8c:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8000b8e:	687b      	ldr	r3, [r7, #4]
 8000b90:	681b      	ldr	r3, [r3, #0]
 8000b92:	f103 0201 	add.w	r2, r3, #1
 8000b96:	687b      	ldr	r3, [r7, #4]
 8000b98:	601a      	str	r2, [r3, #0]
}
 8000b9a:	f107 0714 	add.w	r7, r7, #20
 8000b9e:	46bd      	mov	sp, r7
 8000ba0:	bc80      	pop	{r7}
 8000ba2:	4770      	bx	lr

08000ba4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 8000ba4:	b480      	push	{r7}
 8000ba6:	b085      	sub	sp, #20
 8000ba8:	af00      	add	r7, sp, #0
 8000baa:	6078      	str	r0, [r7, #4]
 8000bac:	6039      	str	r1, [r7, #0]
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8000bae:	683b      	ldr	r3, [r7, #0]
 8000bb0:	681b      	ldr	r3, [r3, #0]
 8000bb2:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8000bb4:	68bb      	ldr	r3, [r7, #8]
 8000bb6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000bba:	d103      	bne.n	8000bc4 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8000bbc:	687b      	ldr	r3, [r7, #4]
 8000bbe:	691b      	ldr	r3, [r3, #16]
 8000bc0:	60fb      	str	r3, [r7, #12]
 8000bc2:	e00d      	b.n	8000be0 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8000bc4:	687b      	ldr	r3, [r7, #4]
 8000bc6:	f103 0308 	add.w	r3, r3, #8
 8000bca:	60fb      	str	r3, [r7, #12]
 8000bcc:	e002      	b.n	8000bd4 <vListInsert+0x30>
 8000bce:	68fb      	ldr	r3, [r7, #12]
 8000bd0:	685b      	ldr	r3, [r3, #4]
 8000bd2:	60fb      	str	r3, [r7, #12]
 8000bd4:	68fb      	ldr	r3, [r7, #12]
 8000bd6:	685b      	ldr	r3, [r3, #4]
 8000bd8:	681a      	ldr	r2, [r3, #0]
 8000bda:	68bb      	ldr	r3, [r7, #8]
 8000bdc:	429a      	cmp	r2, r3
 8000bde:	d9f6      	bls.n	8000bce <vListInsert+0x2a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8000be0:	68fb      	ldr	r3, [r7, #12]
 8000be2:	685a      	ldr	r2, [r3, #4]
 8000be4:	683b      	ldr	r3, [r7, #0]
 8000be6:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8000be8:	683b      	ldr	r3, [r7, #0]
 8000bea:	685b      	ldr	r3, [r3, #4]
 8000bec:	683a      	ldr	r2, [r7, #0]
 8000bee:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8000bf0:	683b      	ldr	r3, [r7, #0]
 8000bf2:	68fa      	ldr	r2, [r7, #12]
 8000bf4:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8000bf6:	683a      	ldr	r2, [r7, #0]
 8000bf8:	68fb      	ldr	r3, [r7, #12]
 8000bfa:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000bfc:	683b      	ldr	r3, [r7, #0]
 8000bfe:	687a      	ldr	r2, [r7, #4]
 8000c00:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8000c02:	687b      	ldr	r3, [r7, #4]
 8000c04:	681b      	ldr	r3, [r3, #0]
 8000c06:	f103 0201 	add.w	r2, r3, #1
 8000c0a:	687b      	ldr	r3, [r7, #4]
 8000c0c:	601a      	str	r2, [r3, #0]
}
 8000c0e:	f107 0714 	add.w	r7, r7, #20
 8000c12:	46bd      	mov	sp, r7
 8000c14:	bc80      	pop	{r7}
 8000c16:	4770      	bx	lr

08000c18 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 8000c18:	b480      	push	{r7}
 8000c1a:	b085      	sub	sp, #20
 8000c1c:	af00      	add	r7, sp, #0
 8000c1e:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000c20:	687b      	ldr	r3, [r7, #4]
 8000c22:	685b      	ldr	r3, [r3, #4]
 8000c24:	687a      	ldr	r2, [r7, #4]
 8000c26:	6892      	ldr	r2, [r2, #8]
 8000c28:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000c2a:	687b      	ldr	r3, [r7, #4]
 8000c2c:	689b      	ldr	r3, [r3, #8]
 8000c2e:	687a      	ldr	r2, [r7, #4]
 8000c30:	6852      	ldr	r2, [r2, #4]
 8000c32:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8000c34:	687b      	ldr	r3, [r7, #4]
 8000c36:	691b      	ldr	r3, [r3, #16]
 8000c38:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000c3a:	68fb      	ldr	r3, [r7, #12]
 8000c3c:	685a      	ldr	r2, [r3, #4]
 8000c3e:	687b      	ldr	r3, [r7, #4]
 8000c40:	429a      	cmp	r2, r3
 8000c42:	d103      	bne.n	8000c4c <vListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000c44:	687b      	ldr	r3, [r7, #4]
 8000c46:	689a      	ldr	r2, [r3, #8]
 8000c48:	68fb      	ldr	r3, [r7, #12]
 8000c4a:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8000c4c:	687b      	ldr	r3, [r7, #4]
 8000c4e:	f04f 0200 	mov.w	r2, #0
 8000c52:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8000c54:	68fb      	ldr	r3, [r7, #12]
 8000c56:	681b      	ldr	r3, [r3, #0]
 8000c58:	f103 32ff 	add.w	r2, r3, #4294967295
 8000c5c:	68fb      	ldr	r3, [r7, #12]
 8000c5e:	601a      	str	r2, [r3, #0]
}
 8000c60:	f107 0714 	add.w	r7, r7, #20
 8000c64:	46bd      	mov	sp, r7
 8000c66:	bc80      	pop	{r7}
 8000c68:	4770      	bx	lr
 8000c6a:	bf00      	nop

08000c6c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 8000c6c:	b480      	push	{r7}
 8000c6e:	b085      	sub	sp, #20
 8000c70:	af00      	add	r7, sp, #0
 8000c72:	60f8      	str	r0, [r7, #12]
 8000c74:	60b9      	str	r1, [r7, #8]
 8000c76:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8000c78:	68fb      	ldr	r3, [r7, #12]
 8000c7a:	f1a3 0304 	sub.w	r3, r3, #4
 8000c7e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8000c80:	68fb      	ldr	r3, [r7, #12]
 8000c82:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000c86:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000c88:	68fb      	ldr	r3, [r7, #12]
 8000c8a:	f1a3 0304 	sub.w	r3, r3, #4
 8000c8e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8000c90:	68ba      	ldr	r2, [r7, #8]
 8000c92:	68fb      	ldr	r3, [r7, #12]
 8000c94:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000c96:	68fb      	ldr	r3, [r7, #12]
 8000c98:	f1a3 0304 	sub.w	r3, r3, #4
 8000c9c:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
 8000c9e:	68fb      	ldr	r3, [r7, #12]
 8000ca0:	f04f 0200 	mov.w	r2, #0
 8000ca4:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8000ca6:	68fb      	ldr	r3, [r7, #12]
 8000ca8:	f1a3 0314 	sub.w	r3, r3, #20
 8000cac:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8000cae:	687a      	ldr	r2, [r7, #4]
 8000cb0:	68fb      	ldr	r3, [r7, #12]
 8000cb2:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8000cb4:	68fb      	ldr	r3, [r7, #12]
 8000cb6:	f1a3 0320 	sub.w	r3, r3, #32
 8000cba:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8000cbc:	68fb      	ldr	r3, [r7, #12]
}
 8000cbe:	4618      	mov	r0, r3
 8000cc0:	f107 0714 	add.w	r7, r7, #20
 8000cc4:	46bd      	mov	sp, r7
 8000cc6:	bc80      	pop	{r7}
 8000cc8:	4770      	bx	lr
 8000cca:	bf00      	nop

08000ccc <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8000ccc:	4b06      	ldr	r3, [pc, #24]	; (8000ce8 <pxCurrentTCBConst2>)
 8000cce:	6819      	ldr	r1, [r3, #0]
 8000cd0:	6808      	ldr	r0, [r1, #0]
 8000cd2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8000cd6:	f380 8809 	msr	PSP, r0
 8000cda:	f04f 0000 	mov.w	r0, #0
 8000cde:	f380 8811 	msr	BASEPRI, r0
 8000ce2:	f04e 0e0d 	orr.w	lr, lr, #13
 8000ce6:	4770      	bx	lr

08000ce8 <pxCurrentTCBConst2>:
 8000ce8:	20000110 	.word	0x20000110

08000cec <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 8000cec:	4802      	ldr	r0, [pc, #8]	; (8000cf8 <vPortStartFirstTask+0xc>)
 8000cee:	6800      	ldr	r0, [r0, #0]
 8000cf0:	6800      	ldr	r0, [r0, #0]
 8000cf2:	f380 8808 	msr	MSP, r0
 8000cf6:	df00      	svc	0
 8000cf8:	e000ed08 	.word	0xe000ed08

08000cfc <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8000cfc:	b580      	push	{r7, lr}
 8000cfe:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8000d00:	4b0b      	ldr	r3, [pc, #44]	; (8000d30 <xPortStartScheduler+0x34>)
 8000d02:	4a0b      	ldr	r2, [pc, #44]	; (8000d30 <xPortStartScheduler+0x34>)
 8000d04:	6812      	ldr	r2, [r2, #0]
 8000d06:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8000d0a:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8000d0c:	4b08      	ldr	r3, [pc, #32]	; (8000d30 <xPortStartScheduler+0x34>)
 8000d0e:	4a08      	ldr	r2, [pc, #32]	; (8000d30 <xPortStartScheduler+0x34>)
 8000d10:	6812      	ldr	r2, [r2, #0]
 8000d12:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8000d16:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 8000d18:	4b06      	ldr	r3, [pc, #24]	; (8000d34 <xPortStartScheduler+0x38>)
 8000d1a:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8000d1c:	4b06      	ldr	r3, [pc, #24]	; (8000d38 <xPortStartScheduler+0x3c>)
 8000d1e:	f04f 0200 	mov.w	r2, #0
 8000d22:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8000d24:	4b05      	ldr	r3, [pc, #20]	; (8000d3c <xPortStartScheduler+0x40>)
 8000d26:	4798      	blx	r3

	/* Should not get here! */
	return 0;
 8000d28:	f04f 0300 	mov.w	r3, #0
}
 8000d2c:	4618      	mov	r0, r3
 8000d2e:	bd80      	pop	{r7, pc}
 8000d30:	e000ed20 	.word	0xe000ed20
 8000d34:	08000e1d 	.word	0x08000e1d
 8000d38:	2000010c 	.word	0x2000010c
 8000d3c:	08000ced 	.word	0x08000ced

08000d40 <vPortYieldFromISR>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 8000d40:	b480      	push	{r7}
 8000d42:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8000d44:	4b03      	ldr	r3, [pc, #12]	; (8000d54 <vPortYieldFromISR+0x14>)
 8000d46:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000d4a:	601a      	str	r2, [r3, #0]
}
 8000d4c:	46bd      	mov	sp, r7
 8000d4e:	bc80      	pop	{r7}
 8000d50:	4770      	bx	lr
 8000d52:	bf00      	nop
 8000d54:	e000ed04 	.word	0xe000ed04

08000d58 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8000d58:	b480      	push	{r7}
 8000d5a:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 8000d5c:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8000d60:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8000d64:	4b04      	ldr	r3, [pc, #16]	; (8000d78 <vPortEnterCritical+0x20>)
 8000d66:	681b      	ldr	r3, [r3, #0]
 8000d68:	f103 0201 	add.w	r2, r3, #1
 8000d6c:	4b02      	ldr	r3, [pc, #8]	; (8000d78 <vPortEnterCritical+0x20>)
 8000d6e:	601a      	str	r2, [r3, #0]
}
 8000d70:	46bd      	mov	sp, r7
 8000d72:	bc80      	pop	{r7}
 8000d74:	4770      	bx	lr
 8000d76:	bf00      	nop
 8000d78:	2000010c 	.word	0x2000010c

08000d7c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8000d7c:	b480      	push	{r7}
 8000d7e:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
 8000d80:	4b08      	ldr	r3, [pc, #32]	; (8000da4 <vPortExitCritical+0x28>)
 8000d82:	681b      	ldr	r3, [r3, #0]
 8000d84:	f103 32ff 	add.w	r2, r3, #4294967295
 8000d88:	4b06      	ldr	r3, [pc, #24]	; (8000da4 <vPortExitCritical+0x28>)
 8000d8a:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
 8000d8c:	4b05      	ldr	r3, [pc, #20]	; (8000da4 <vPortExitCritical+0x28>)
 8000d8e:	681b      	ldr	r3, [r3, #0]
 8000d90:	2b00      	cmp	r3, #0
 8000d92:	d103      	bne.n	8000d9c <vPortExitCritical+0x20>
	{
		portENABLE_INTERRUPTS();
 8000d94:	f04f 0000 	mov.w	r0, #0
 8000d98:	f380 8811 	msr	BASEPRI, r0
	}
}
 8000d9c:	46bd      	mov	sp, r7
 8000d9e:	bc80      	pop	{r7}
 8000da0:	4770      	bx	lr
 8000da2:	bf00      	nop
 8000da4:	2000010c 	.word	0x2000010c

08000da8 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8000da8:	f3ef 8009 	mrs	r0, PSP
 8000dac:	4b0c      	ldr	r3, [pc, #48]	; (8000de0 <pxCurrentTCBConst>)
 8000dae:	681a      	ldr	r2, [r3, #0]
 8000db0:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8000db4:	6010      	str	r0, [r2, #0]
 8000db6:	e92d 4008 	stmdb	sp!, {r3, lr}
 8000dba:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8000dbe:	f380 8811 	msr	BASEPRI, r0
 8000dc2:	f7ff fd03 	bl	80007cc <vTaskSwitchContext>
 8000dc6:	f04f 0000 	mov.w	r0, #0
 8000dca:	f380 8811 	msr	BASEPRI, r0
 8000dce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8000dd2:	6819      	ldr	r1, [r3, #0]
 8000dd4:	6808      	ldr	r0, [r1, #0]
 8000dd6:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8000dda:	f380 8809 	msr	PSP, r0
 8000dde:	4770      	bx	lr

08000de0 <pxCurrentTCBConst>:
 8000de0:	20000110 	.word	0x20000110

08000de4 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8000de4:	b580      	push	{r7, lr}
 8000de6:	b082      	sub	sp, #8
 8000de8:	af00      	add	r7, sp, #0
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8000dea:	4b0a      	ldr	r3, [pc, #40]	; (8000e14 <xPortSysTickHandler+0x30>)
 8000dec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000df0:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8000df2:	f04f 0300 	mov.w	r3, #0
 8000df6:	607b      	str	r3, [r7, #4]
 8000df8:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8000dfc:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 8000e00:	4b05      	ldr	r3, [pc, #20]	; (8000e18 <xPortSysTickHandler+0x34>)
 8000e02:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8000e04:	f04f 0000 	mov.w	r0, #0
 8000e08:	f380 8811 	msr	BASEPRI, r0
}
 8000e0c:	f107 0708 	add.w	r7, r7, #8
 8000e10:	46bd      	mov	sp, r7
 8000e12:	bd80      	pop	{r7, pc}
 8000e14:	e000ed04 	.word	0xe000ed04
 8000e18:	080006c5 	.word	0x080006c5

08000e1c <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 8000e1c:	b480      	push	{r7}
 8000e1e:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8000e20:	4b04      	ldr	r3, [pc, #16]	; (8000e34 <prvSetupTimerInterrupt+0x18>)
 8000e22:	4a05      	ldr	r2, [pc, #20]	; (8000e38 <prvSetupTimerInterrupt+0x1c>)
 8000e24:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8000e26:	4b05      	ldr	r3, [pc, #20]	; (8000e3c <prvSetupTimerInterrupt+0x20>)
 8000e28:	f04f 0207 	mov.w	r2, #7
 8000e2c:	601a      	str	r2, [r3, #0]
}
 8000e2e:	46bd      	mov	sp, r7
 8000e30:	bc80      	pop	{r7}
 8000e32:	4770      	bx	lr
 8000e34:	e000e014 	.word	0xe000e014
 8000e38:	0001193f 	.word	0x0001193f
 8000e3c:	e000e010 	.word	0xe000e010

08000e40 <pvPortMalloc>:
	xFreeBytesRemaining = configTOTAL_HEAP_SIZE;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8000e40:	b580      	push	{r7, lr}
 8000e42:	b08a      	sub	sp, #40	; 0x28
 8000e44:	af00      	add	r7, sp, #0
 8000e46:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 8000e48:	f04f 0300 	mov.w	r3, #0
 8000e4c:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
 8000e4e:	4b4f      	ldr	r3, [pc, #316]	; (8000f8c <pvPortMalloc+0x14c>)
 8000e50:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 8000e52:	4b4f      	ldr	r3, [pc, #316]	; (8000f90 <pvPortMalloc+0x150>)
 8000e54:	681b      	ldr	r3, [r3, #0]
 8000e56:	2b00      	cmp	r3, #0
 8000e58:	d11f      	bne.n	8000e9a <pvPortMalloc+0x5a>
		{
			prvHeapInit();
 8000e5a:	4a4e      	ldr	r2, [pc, #312]	; (8000f94 <pvPortMalloc+0x154>)
 8000e5c:	4b4e      	ldr	r3, [pc, #312]	; (8000f98 <pvPortMalloc+0x158>)
 8000e5e:	601a      	str	r2, [r3, #0]
 8000e60:	4b4d      	ldr	r3, [pc, #308]	; (8000f98 <pvPortMalloc+0x158>)
 8000e62:	f04f 0200 	mov.w	r2, #0
 8000e66:	605a      	str	r2, [r3, #4]
 8000e68:	4b4c      	ldr	r3, [pc, #304]	; (8000f9c <pvPortMalloc+0x15c>)
 8000e6a:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8000e6e:	605a      	str	r2, [r3, #4]
 8000e70:	4b4a      	ldr	r3, [pc, #296]	; (8000f9c <pvPortMalloc+0x15c>)
 8000e72:	f04f 0200 	mov.w	r2, #0
 8000e76:	601a      	str	r2, [r3, #0]
 8000e78:	4b46      	ldr	r3, [pc, #280]	; (8000f94 <pvPortMalloc+0x154>)
 8000e7a:	617b      	str	r3, [r7, #20]
 8000e7c:	697b      	ldr	r3, [r7, #20]
 8000e7e:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8000e82:	605a      	str	r2, [r3, #4]
 8000e84:	697b      	ldr	r3, [r7, #20]
 8000e86:	4a45      	ldr	r2, [pc, #276]	; (8000f9c <pvPortMalloc+0x15c>)
 8000e88:	601a      	str	r2, [r3, #0]
 8000e8a:	4b45      	ldr	r3, [pc, #276]	; (8000fa0 <pvPortMalloc+0x160>)
 8000e8c:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8000e90:	601a      	str	r2, [r3, #0]
			xHeapHasBeenInitialised = pdTRUE;
 8000e92:	4b3f      	ldr	r3, [pc, #252]	; (8000f90 <pvPortMalloc+0x150>)
 8000e94:	f04f 0201 	mov.w	r2, #1
 8000e98:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 8000e9a:	687b      	ldr	r3, [r7, #4]
 8000e9c:	2b00      	cmp	r3, #0
 8000e9e:	d00f      	beq.n	8000ec0 <pvPortMalloc+0x80>
		{
			xWantedSize += heapSTRUCT_SIZE;
 8000ea0:	4b40      	ldr	r3, [pc, #256]	; (8000fa4 <pvPortMalloc+0x164>)
 8000ea2:	881b      	ldrh	r3, [r3, #0]
 8000ea4:	687a      	ldr	r2, [r7, #4]
 8000ea6:	18d3      	adds	r3, r2, r3
 8000ea8:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8000eaa:	687b      	ldr	r3, [r7, #4]
 8000eac:	f003 0307 	and.w	r3, r3, #7
 8000eb0:	2b00      	cmp	r3, #0
 8000eb2:	d005      	beq.n	8000ec0 <pvPortMalloc+0x80>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8000eb4:	687b      	ldr	r3, [r7, #4]
 8000eb6:	f023 0307 	bic.w	r3, r3, #7
 8000eba:	f103 0308 	add.w	r3, r3, #8
 8000ebe:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
 8000ec0:	687b      	ldr	r3, [r7, #4]
 8000ec2:	2b00      	cmp	r3, #0
 8000ec4:	d059      	beq.n	8000f7a <pvPortMalloc+0x13a>
 8000ec6:	687a      	ldr	r2, [r7, #4]
 8000ec8:	f242 73ff 	movw	r3, #10239	; 0x27ff
 8000ecc:	429a      	cmp	r2, r3
 8000ece:	d854      	bhi.n	8000f7a <pvPortMalloc+0x13a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 8000ed0:	4b31      	ldr	r3, [pc, #196]	; (8000f98 <pvPortMalloc+0x158>)
 8000ed2:	623b      	str	r3, [r7, #32]
			pxBlock = xStart.pxNextFreeBlock;
 8000ed4:	4b30      	ldr	r3, [pc, #192]	; (8000f98 <pvPortMalloc+0x158>)
 8000ed6:	681b      	ldr	r3, [r3, #0]
 8000ed8:	627b      	str	r3, [r7, #36]	; 0x24
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
 8000eda:	e004      	b.n	8000ee6 <pvPortMalloc+0xa6>
			{
				pxPreviousBlock = pxBlock;
 8000edc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000ede:	623b      	str	r3, [r7, #32]
				pxBlock = pxBlock->pxNextFreeBlock;
 8000ee0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000ee2:	681b      	ldr	r3, [r3, #0]
 8000ee4:	627b      	str	r3, [r7, #36]	; 0x24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
 8000ee6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000ee8:	685a      	ldr	r2, [r3, #4]
 8000eea:	687b      	ldr	r3, [r7, #4]
 8000eec:	429a      	cmp	r2, r3
 8000eee:	d203      	bcs.n	8000ef8 <pvPortMalloc+0xb8>
 8000ef0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000ef2:	681b      	ldr	r3, [r3, #0]
 8000ef4:	2b00      	cmp	r3, #0
 8000ef6:	d1f1      	bne.n	8000edc <pvPortMalloc+0x9c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 8000ef8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8000efa:	4b28      	ldr	r3, [pc, #160]	; (8000f9c <pvPortMalloc+0x15c>)
 8000efc:	429a      	cmp	r2, r3
 8000efe:	d03c      	beq.n	8000f7a <pvPortMalloc+0x13a>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 8000f00:	6a3b      	ldr	r3, [r7, #32]
 8000f02:	681a      	ldr	r2, [r3, #0]
 8000f04:	4b27      	ldr	r3, [pc, #156]	; (8000fa4 <pvPortMalloc+0x164>)
 8000f06:	881b      	ldrh	r3, [r3, #0]
 8000f08:	18d3      	adds	r3, r2, r3
 8000f0a:	61fb      	str	r3, [r7, #28]

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8000f0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000f0e:	681a      	ldr	r2, [r3, #0]
 8000f10:	6a3b      	ldr	r3, [r7, #32]
 8000f12:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8000f14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000f16:	685a      	ldr	r2, [r3, #4]
 8000f18:	687b      	ldr	r3, [r7, #4]
 8000f1a:	1ad2      	subs	r2, r2, r3
 8000f1c:	4b21      	ldr	r3, [pc, #132]	; (8000fa4 <pvPortMalloc+0x164>)
 8000f1e:	881b      	ldrh	r3, [r3, #0]
 8000f20:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000f24:	429a      	cmp	r2, r3
 8000f26:	d922      	bls.n	8000f6e <pvPortMalloc+0x12e>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 8000f28:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8000f2a:	687b      	ldr	r3, [r7, #4]
 8000f2c:	18d3      	adds	r3, r2, r3
 8000f2e:	613b      	str	r3, [r7, #16]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8000f30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000f32:	685a      	ldr	r2, [r3, #4]
 8000f34:	687b      	ldr	r3, [r7, #4]
 8000f36:	1ad2      	subs	r2, r2, r3
 8000f38:	693b      	ldr	r3, [r7, #16]
 8000f3a:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
 8000f3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000f3e:	687a      	ldr	r2, [r7, #4]
 8000f40:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 8000f42:	693b      	ldr	r3, [r7, #16]
 8000f44:	685b      	ldr	r3, [r3, #4]
 8000f46:	60fb      	str	r3, [r7, #12]
 8000f48:	4b13      	ldr	r3, [pc, #76]	; (8000f98 <pvPortMalloc+0x158>)
 8000f4a:	61bb      	str	r3, [r7, #24]
 8000f4c:	e002      	b.n	8000f54 <pvPortMalloc+0x114>
 8000f4e:	69bb      	ldr	r3, [r7, #24]
 8000f50:	681b      	ldr	r3, [r3, #0]
 8000f52:	61bb      	str	r3, [r7, #24]
 8000f54:	69bb      	ldr	r3, [r7, #24]
 8000f56:	681b      	ldr	r3, [r3, #0]
 8000f58:	685a      	ldr	r2, [r3, #4]
 8000f5a:	68fb      	ldr	r3, [r7, #12]
 8000f5c:	429a      	cmp	r2, r3
 8000f5e:	d3f6      	bcc.n	8000f4e <pvPortMalloc+0x10e>
 8000f60:	69bb      	ldr	r3, [r7, #24]
 8000f62:	681a      	ldr	r2, [r3, #0]
 8000f64:	693b      	ldr	r3, [r7, #16]
 8000f66:	601a      	str	r2, [r3, #0]
 8000f68:	69bb      	ldr	r3, [r7, #24]
 8000f6a:	693a      	ldr	r2, [r7, #16]
 8000f6c:	601a      	str	r2, [r3, #0]
				}
				
				xFreeBytesRemaining -= xWantedSize;
 8000f6e:	4b0c      	ldr	r3, [pc, #48]	; (8000fa0 <pvPortMalloc+0x160>)
 8000f70:	681a      	ldr	r2, [r3, #0]
 8000f72:	687b      	ldr	r3, [r7, #4]
 8000f74:	1ad2      	subs	r2, r2, r3
 8000f76:	4b0a      	ldr	r3, [pc, #40]	; (8000fa0 <pvPortMalloc+0x160>)
 8000f78:	601a      	str	r2, [r3, #0]
			}
		}
	}
	xTaskResumeAll();
 8000f7a:	4b0b      	ldr	r3, [pc, #44]	; (8000fa8 <pvPortMalloc+0x168>)
 8000f7c:	4798      	blx	r3
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 8000f7e:	69fb      	ldr	r3, [r7, #28]
}
 8000f80:	4618      	mov	r0, r3
 8000f82:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8000f86:	46bd      	mov	sp, r7
 8000f88:	bd80      	pop	{r7, pc}
 8000f8a:	bf00      	nop
 8000f8c:	08000575 	.word	0x08000575
 8000f90:	20002a8c 	.word	0x20002a8c
 8000f94:	20000278 	.word	0x20000278
 8000f98:	20002a78 	.word	0x20002a78
 8000f9c:	20002a80 	.word	0x20002a80
 8000fa0:	20002a88 	.word	0x20002a88
 8000fa4:	08001c04 	.word	0x08001c04
 8000fa8:	08000591 	.word	0x08000591

08000fac <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8000fac:	b580      	push	{r7, lr}
 8000fae:	b086      	sub	sp, #24
 8000fb0:	af00      	add	r7, sp, #0
 8000fb2:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
 8000fb4:	687b      	ldr	r3, [r7, #4]
 8000fb6:	613b      	str	r3, [r7, #16]
xBlockLink *pxLink;

	if( pv )
 8000fb8:	687b      	ldr	r3, [r7, #4]
 8000fba:	2b00      	cmp	r3, #0
 8000fbc:	d029      	beq.n	8001012 <vPortFree+0x66>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 8000fbe:	4b17      	ldr	r3, [pc, #92]	; (800101c <vPortFree+0x70>)
 8000fc0:	881b      	ldrh	r3, [r3, #0]
 8000fc2:	f1c3 0300 	rsb	r3, r3, #0
 8000fc6:	693a      	ldr	r2, [r7, #16]
 8000fc8:	18d3      	adds	r3, r2, r3
 8000fca:	613b      	str	r3, [r7, #16]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 8000fcc:	693b      	ldr	r3, [r7, #16]
 8000fce:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
 8000fd0:	4b13      	ldr	r3, [pc, #76]	; (8001020 <vPortFree+0x74>)
 8000fd2:	4798      	blx	r3
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 8000fd4:	68fb      	ldr	r3, [r7, #12]
 8000fd6:	685b      	ldr	r3, [r3, #4]
 8000fd8:	60bb      	str	r3, [r7, #8]
 8000fda:	4b12      	ldr	r3, [pc, #72]	; (8001024 <vPortFree+0x78>)
 8000fdc:	617b      	str	r3, [r7, #20]
 8000fde:	e002      	b.n	8000fe6 <vPortFree+0x3a>
 8000fe0:	697b      	ldr	r3, [r7, #20]
 8000fe2:	681b      	ldr	r3, [r3, #0]
 8000fe4:	617b      	str	r3, [r7, #20]
 8000fe6:	697b      	ldr	r3, [r7, #20]
 8000fe8:	681b      	ldr	r3, [r3, #0]
 8000fea:	685a      	ldr	r2, [r3, #4]
 8000fec:	68bb      	ldr	r3, [r7, #8]
 8000fee:	429a      	cmp	r2, r3
 8000ff0:	d3f6      	bcc.n	8000fe0 <vPortFree+0x34>
 8000ff2:	697b      	ldr	r3, [r7, #20]
 8000ff4:	681a      	ldr	r2, [r3, #0]
 8000ff6:	68fb      	ldr	r3, [r7, #12]
 8000ff8:	601a      	str	r2, [r3, #0]
 8000ffa:	697b      	ldr	r3, [r7, #20]
 8000ffc:	68fa      	ldr	r2, [r7, #12]
 8000ffe:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
 8001000:	68fb      	ldr	r3, [r7, #12]
 8001002:	685a      	ldr	r2, [r3, #4]
 8001004:	4b08      	ldr	r3, [pc, #32]	; (8001028 <vPortFree+0x7c>)
 8001006:	681b      	ldr	r3, [r3, #0]
 8001008:	18d2      	adds	r2, r2, r3
 800100a:	4b07      	ldr	r3, [pc, #28]	; (8001028 <vPortFree+0x7c>)
 800100c:	601a      	str	r2, [r3, #0]
		}
		xTaskResumeAll();
 800100e:	4b07      	ldr	r3, [pc, #28]	; (800102c <vPortFree+0x80>)
 8001010:	4798      	blx	r3
	}
}
 8001012:	f107 0718 	add.w	r7, r7, #24
 8001016:	46bd      	mov	sp, r7
 8001018:	bd80      	pop	{r7, pc}
 800101a:	bf00      	nop
 800101c:	08001c04 	.word	0x08001c04
 8001020:	08000575 	.word	0x08000575
 8001024:	20002a78 	.word	0x20002a78
 8001028:	20002a88 	.word	0x20002a88
 800102c:	08000591 	.word	0x08000591

08001030 <FLASH_SetLatency>:
  *     @arg FLASH_Latency_1: FLASH One Latency cycle
  *     @arg FLASH_Latency_2: FLASH Two Latency cycles
  * @retval None
  */
void FLASH_SetLatency(uint32_t FLASH_Latency)
{
 8001030:	b480      	push	{r7}
 8001032:	b085      	sub	sp, #20
 8001034:	af00      	add	r7, sp, #0
 8001036:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8001038:	f04f 0300 	mov.w	r3, #0
 800103c:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));

  /* Read the ACR register */
  tmpreg = FLASH->ACR;
 800103e:	4b0a      	ldr	r3, [pc, #40]	; (8001068 <FLASH_SetLatency+0x38>)
 8001040:	681b      	ldr	r3, [r3, #0]
 8001042:	60fb      	str	r3, [r7, #12]

  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 8001044:	68fb      	ldr	r3, [r7, #12]
 8001046:	f003 0338 	and.w	r3, r3, #56	; 0x38
 800104a:	60fb      	str	r3, [r7, #12]
  tmpreg |= FLASH_Latency;
 800104c:	68fa      	ldr	r2, [r7, #12]
 800104e:	687b      	ldr	r3, [r7, #4]
 8001050:	ea42 0303 	orr.w	r3, r2, r3
 8001054:	60fb      	str	r3, [r7, #12]

  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 8001056:	4b04      	ldr	r3, [pc, #16]	; (8001068 <FLASH_SetLatency+0x38>)
 8001058:	68fa      	ldr	r2, [r7, #12]
 800105a:	601a      	str	r2, [r3, #0]
}
 800105c:	f107 0714 	add.w	r7, r7, #20
 8001060:	46bd      	mov	sp, r7
 8001062:	bc80      	pop	{r7}
 8001064:	4770      	bx	lr
 8001066:	bf00      	nop
 8001068:	40022000 	.word	0x40022000

0800106c <FLASH_PrefetchBufferCmd>:
  *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
  *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
  * @retval None
  */
void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
{
 800106c:	b480      	push	{r7}
 800106e:	b083      	sub	sp, #12
 8001070:	af00      	add	r7, sp, #0
 8001072:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));

  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 8001074:	4b08      	ldr	r3, [pc, #32]	; (8001098 <FLASH_PrefetchBufferCmd+0x2c>)
 8001076:	4a08      	ldr	r2, [pc, #32]	; (8001098 <FLASH_PrefetchBufferCmd+0x2c>)
 8001078:	6812      	ldr	r2, [r2, #0]
 800107a:	f022 0210 	bic.w	r2, r2, #16
 800107e:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 8001080:	4b05      	ldr	r3, [pc, #20]	; (8001098 <FLASH_PrefetchBufferCmd+0x2c>)
 8001082:	4a05      	ldr	r2, [pc, #20]	; (8001098 <FLASH_PrefetchBufferCmd+0x2c>)
 8001084:	6811      	ldr	r1, [r2, #0]
 8001086:	687a      	ldr	r2, [r7, #4]
 8001088:	ea41 0202 	orr.w	r2, r1, r2
 800108c:	601a      	str	r2, [r3, #0]
}
 800108e:	f107 070c 	add.w	r7, r7, #12
 8001092:	46bd      	mov	sp, r7
 8001094:	bc80      	pop	{r7}
 8001096:	4770      	bx	lr
 8001098:	40022000 	.word	0x40022000

0800109c <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 800109c:	b480      	push	{r7}
 800109e:	b089      	sub	sp, #36	; 0x24
 80010a0:	af00      	add	r7, sp, #0
 80010a2:	6078      	str	r0, [r7, #4]
 80010a4:	6039      	str	r1, [r7, #0]
  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
 80010a6:	f04f 0300 	mov.w	r3, #0
 80010aa:	61fb      	str	r3, [r7, #28]
 80010ac:	f04f 0300 	mov.w	r3, #0
 80010b0:	613b      	str	r3, [r7, #16]
 80010b2:	f04f 0300 	mov.w	r3, #0
 80010b6:	61bb      	str	r3, [r7, #24]
 80010b8:	f04f 0300 	mov.w	r3, #0
 80010bc:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg = 0x00, pinmask = 0x00;
 80010be:	f04f 0300 	mov.w	r3, #0
 80010c2:	617b      	str	r3, [r7, #20]
 80010c4:	f04f 0300 	mov.w	r3, #0
 80010c8:	60bb      	str	r3, [r7, #8]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 80010ca:	683b      	ldr	r3, [r7, #0]
 80010cc:	78db      	ldrb	r3, [r3, #3]
 80010ce:	f003 030f 	and.w	r3, r3, #15
 80010d2:	61fb      	str	r3, [r7, #28]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 80010d4:	683b      	ldr	r3, [r7, #0]
 80010d6:	78db      	ldrb	r3, [r3, #3]
 80010d8:	f003 0310 	and.w	r3, r3, #16
 80010dc:	2b00      	cmp	r3, #0
 80010de:	d005      	beq.n	80010ec <GPIO_Init+0x50>
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 80010e0:	683b      	ldr	r3, [r7, #0]
 80010e2:	789b      	ldrb	r3, [r3, #2]
 80010e4:	69fa      	ldr	r2, [r7, #28]
 80010e6:	ea42 0303 	orr.w	r3, r2, r3
 80010ea:	61fb      	str	r3, [r7, #28]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 80010ec:	683b      	ldr	r3, [r7, #0]
 80010ee:	881b      	ldrh	r3, [r3, #0]
 80010f0:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80010f4:	2b00      	cmp	r3, #0
 80010f6:	d051      	beq.n	800119c <GPIO_Init+0x100>
  {
    tmpreg = GPIOx->CRL;
 80010f8:	687b      	ldr	r3, [r7, #4]
 80010fa:	681b      	ldr	r3, [r3, #0]
 80010fc:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80010fe:	f04f 0300 	mov.w	r3, #0
 8001102:	61bb      	str	r3, [r7, #24]
 8001104:	e044      	b.n	8001190 <GPIO_Init+0xf4>
    {
      pos = ((uint32_t)0x01) << pinpos;
 8001106:	69bb      	ldr	r3, [r7, #24]
 8001108:	f04f 0201 	mov.w	r2, #1
 800110c:	fa02 f303 	lsl.w	r3, r2, r3
 8001110:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001112:	683b      	ldr	r3, [r7, #0]
 8001114:	881b      	ldrh	r3, [r3, #0]
 8001116:	461a      	mov	r2, r3
 8001118:	68fb      	ldr	r3, [r7, #12]
 800111a:	ea02 0303 	and.w	r3, r2, r3
 800111e:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
 8001120:	693a      	ldr	r2, [r7, #16]
 8001122:	68fb      	ldr	r3, [r7, #12]
 8001124:	429a      	cmp	r2, r3
 8001126:	d12f      	bne.n	8001188 <GPIO_Init+0xec>
      {
        pos = pinpos << 2;
 8001128:	69bb      	ldr	r3, [r7, #24]
 800112a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800112e:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8001130:	68fb      	ldr	r3, [r7, #12]
 8001132:	f04f 020f 	mov.w	r2, #15
 8001136:	fa02 f303 	lsl.w	r3, r2, r3
 800113a:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
 800113c:	68bb      	ldr	r3, [r7, #8]
 800113e:	ea6f 0303 	mvn.w	r3, r3
 8001142:	697a      	ldr	r2, [r7, #20]
 8001144:	ea02 0303 	and.w	r3, r2, r3
 8001148:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 800114a:	68fb      	ldr	r3, [r7, #12]
 800114c:	69fa      	ldr	r2, [r7, #28]
 800114e:	fa02 f303 	lsl.w	r3, r2, r3
 8001152:	697a      	ldr	r2, [r7, #20]
 8001154:	ea42 0303 	orr.w	r3, r2, r3
 8001158:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800115a:	683b      	ldr	r3, [r7, #0]
 800115c:	78db      	ldrb	r3, [r3, #3]
 800115e:	2b28      	cmp	r3, #40	; 0x28
 8001160:	d107      	bne.n	8001172 <GPIO_Init+0xd6>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8001162:	69bb      	ldr	r3, [r7, #24]
 8001164:	f04f 0201 	mov.w	r2, #1
 8001168:	fa02 f203 	lsl.w	r2, r2, r3
 800116c:	687b      	ldr	r3, [r7, #4]
 800116e:	615a      	str	r2, [r3, #20]
 8001170:	e00a      	b.n	8001188 <GPIO_Init+0xec>
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8001172:	683b      	ldr	r3, [r7, #0]
 8001174:	78db      	ldrb	r3, [r3, #3]
 8001176:	2b48      	cmp	r3, #72	; 0x48
 8001178:	d106      	bne.n	8001188 <GPIO_Init+0xec>
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 800117a:	69bb      	ldr	r3, [r7, #24]
 800117c:	f04f 0201 	mov.w	r2, #1
 8001180:	fa02 f203 	lsl.w	r2, r2, r3
 8001184:	687b      	ldr	r3, [r7, #4]
 8001186:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001188:	69bb      	ldr	r3, [r7, #24]
 800118a:	f103 0301 	add.w	r3, r3, #1
 800118e:	61bb      	str	r3, [r7, #24]
 8001190:	69bb      	ldr	r3, [r7, #24]
 8001192:	2b07      	cmp	r3, #7
 8001194:	d9b7      	bls.n	8001106 <GPIO_Init+0x6a>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8001196:	687b      	ldr	r3, [r7, #4]
 8001198:	697a      	ldr	r2, [r7, #20]
 800119a:	601a      	str	r2, [r3, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 800119c:	683b      	ldr	r3, [r7, #0]
 800119e:	881b      	ldrh	r3, [r3, #0]
 80011a0:	2bff      	cmp	r3, #255	; 0xff
 80011a2:	d956      	bls.n	8001252 <GPIO_Init+0x1b6>
  {
    tmpreg = GPIOx->CRH;
 80011a4:	687b      	ldr	r3, [r7, #4]
 80011a6:	685b      	ldr	r3, [r3, #4]
 80011a8:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 80011aa:	f04f 0300 	mov.w	r3, #0
 80011ae:	61bb      	str	r3, [r7, #24]
 80011b0:	e049      	b.n	8001246 <GPIO_Init+0x1aa>
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 80011b2:	69bb      	ldr	r3, [r7, #24]
 80011b4:	f103 0308 	add.w	r3, r3, #8
 80011b8:	f04f 0201 	mov.w	r2, #1
 80011bc:	fa02 f303 	lsl.w	r3, r2, r3
 80011c0:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 80011c2:	683b      	ldr	r3, [r7, #0]
 80011c4:	881b      	ldrh	r3, [r3, #0]
 80011c6:	461a      	mov	r2, r3
 80011c8:	68fb      	ldr	r3, [r7, #12]
 80011ca:	ea02 0303 	and.w	r3, r2, r3
 80011ce:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
 80011d0:	693a      	ldr	r2, [r7, #16]
 80011d2:	68fb      	ldr	r3, [r7, #12]
 80011d4:	429a      	cmp	r2, r3
 80011d6:	d132      	bne.n	800123e <GPIO_Init+0x1a2>
      {
        pos = pinpos << 2;
 80011d8:	69bb      	ldr	r3, [r7, #24]
 80011da:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80011de:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 80011e0:	68fb      	ldr	r3, [r7, #12]
 80011e2:	f04f 020f 	mov.w	r2, #15
 80011e6:	fa02 f303 	lsl.w	r3, r2, r3
 80011ea:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
 80011ec:	68bb      	ldr	r3, [r7, #8]
 80011ee:	ea6f 0303 	mvn.w	r3, r3
 80011f2:	697a      	ldr	r2, [r7, #20]
 80011f4:	ea02 0303 	and.w	r3, r2, r3
 80011f8:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 80011fa:	68fb      	ldr	r3, [r7, #12]
 80011fc:	69fa      	ldr	r2, [r7, #28]
 80011fe:	fa02 f303 	lsl.w	r3, r2, r3
 8001202:	697a      	ldr	r2, [r7, #20]
 8001204:	ea42 0303 	orr.w	r3, r2, r3
 8001208:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 800120a:	683b      	ldr	r3, [r7, #0]
 800120c:	78db      	ldrb	r3, [r3, #3]
 800120e:	2b28      	cmp	r3, #40	; 0x28
 8001210:	d108      	bne.n	8001224 <GPIO_Init+0x188>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001212:	69bb      	ldr	r3, [r7, #24]
 8001214:	f103 0308 	add.w	r3, r3, #8
 8001218:	f04f 0201 	mov.w	r2, #1
 800121c:	fa02 f203 	lsl.w	r2, r2, r3
 8001220:	687b      	ldr	r3, [r7, #4]
 8001222:	615a      	str	r2, [r3, #20]
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8001224:	683b      	ldr	r3, [r7, #0]
 8001226:	78db      	ldrb	r3, [r3, #3]
 8001228:	2b48      	cmp	r3, #72	; 0x48
 800122a:	d108      	bne.n	800123e <GPIO_Init+0x1a2>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 800122c:	69bb      	ldr	r3, [r7, #24]
 800122e:	f103 0308 	add.w	r3, r3, #8
 8001232:	f04f 0201 	mov.w	r2, #1
 8001236:	fa02 f203 	lsl.w	r2, r2, r3
 800123a:	687b      	ldr	r3, [r7, #4]
 800123c:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 800123e:	69bb      	ldr	r3, [r7, #24]
 8001240:	f103 0301 	add.w	r3, r3, #1
 8001244:	61bb      	str	r3, [r7, #24]
 8001246:	69bb      	ldr	r3, [r7, #24]
 8001248:	2b07      	cmp	r3, #7
 800124a:	d9b2      	bls.n	80011b2 <GPIO_Init+0x116>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 800124c:	687b      	ldr	r3, [r7, #4]
 800124e:	697a      	ldr	r2, [r7, #20]
 8001250:	605a      	str	r2, [r3, #4]
  }
}
 8001252:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8001256:	46bd      	mov	sp, r7
 8001258:	bc80      	pop	{r7}
 800125a:	4770      	bx	lr

0800125c <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800125c:	b480      	push	{r7}
 800125e:	b083      	sub	sp, #12
 8001260:	af00      	add	r7, sp, #0
 8001262:	6078      	str	r0, [r7, #4]
 8001264:	460b      	mov	r3, r1
 8001266:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 8001268:	887a      	ldrh	r2, [r7, #2]
 800126a:	687b      	ldr	r3, [r7, #4]
 800126c:	611a      	str	r2, [r3, #16]
}
 800126e:	f107 070c 	add.w	r7, r7, #12
 8001272:	46bd      	mov	sp, r7
 8001274:	bc80      	pop	{r7}
 8001276:	4770      	bx	lr

08001278 <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8001278:	b480      	push	{r7}
 800127a:	b083      	sub	sp, #12
 800127c:	af00      	add	r7, sp, #0
 800127e:	6078      	str	r0, [r7, #4]
 8001280:	460b      	mov	r3, r1
 8001282:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 8001284:	887a      	ldrh	r2, [r7, #2]
 8001286:	687b      	ldr	r3, [r7, #4]
 8001288:	615a      	str	r2, [r3, #20]
}
 800128a:	f107 070c 	add.w	r7, r7, #12
 800128e:	46bd      	mov	sp, r7
 8001290:	bc80      	pop	{r7}
 8001292:	4770      	bx	lr

08001294 <RCC_DeInit>:
  * @brief  Resets the RCC clock configuration to the default reset state.
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
 8001294:	b480      	push	{r7}
 8001296:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001298:	4b13      	ldr	r3, [pc, #76]	; (80012e8 <RCC_DeInit+0x54>)
 800129a:	4a13      	ldr	r2, [pc, #76]	; (80012e8 <RCC_DeInit+0x54>)
 800129c:	6812      	ldr	r2, [r2, #0]
 800129e:	f042 0201 	orr.w	r2, r2, #1
 80012a2:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 80012a4:	4a10      	ldr	r2, [pc, #64]	; (80012e8 <RCC_DeInit+0x54>)
 80012a6:	4b10      	ldr	r3, [pc, #64]	; (80012e8 <RCC_DeInit+0x54>)
 80012a8:	6859      	ldr	r1, [r3, #4]
 80012aa:	4b10      	ldr	r3, [pc, #64]	; (80012ec <RCC_DeInit+0x58>)
 80012ac:	ea01 0303 	and.w	r3, r1, r3
 80012b0:	6053      	str	r3, [r2, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80012b2:	4a0d      	ldr	r2, [pc, #52]	; (80012e8 <RCC_DeInit+0x54>)
 80012b4:	4b0c      	ldr	r3, [pc, #48]	; (80012e8 <RCC_DeInit+0x54>)
 80012b6:	681b      	ldr	r3, [r3, #0]
 80012b8:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 80012bc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80012c0:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80012c2:	4b09      	ldr	r3, [pc, #36]	; (80012e8 <RCC_DeInit+0x54>)
 80012c4:	4a08      	ldr	r2, [pc, #32]	; (80012e8 <RCC_DeInit+0x54>)
 80012c6:	6812      	ldr	r2, [r2, #0]
 80012c8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80012cc:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 80012ce:	4b06      	ldr	r3, [pc, #24]	; (80012e8 <RCC_DeInit+0x54>)
 80012d0:	4a05      	ldr	r2, [pc, #20]	; (80012e8 <RCC_DeInit+0x54>)
 80012d2:	6852      	ldr	r2, [r2, #4]
 80012d4:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80012d8:	605a      	str	r2, [r3, #4]

#ifndef STM32F10X_CL
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 80012da:	4b03      	ldr	r3, [pc, #12]	; (80012e8 <RCC_DeInit+0x54>)
 80012dc:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 80012e0:	609a      	str	r2, [r3, #8]
  RCC->CIR = 0x00FF0000;

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;
#endif /* STM32F10X_CL */
}
 80012e2:	46bd      	mov	sp, r7
 80012e4:	bc80      	pop	{r7}
 80012e6:	4770      	bx	lr
 80012e8:	40021000 	.word	0x40021000
 80012ec:	f8ff0000 	.word	0xf8ff0000

080012f0 <RCC_HSEConfig>:
  *     @arg RCC_HSE_ON: HSE oscillator ON
  *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_HSEConfig(uint32_t RCC_HSE)
{
 80012f0:	b480      	push	{r7}
 80012f2:	b083      	sub	sp, #12
 80012f4:	af00      	add	r7, sp, #0
 80012f6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80012f8:	4b13      	ldr	r3, [pc, #76]	; (8001348 <RCC_HSEConfig+0x58>)
 80012fa:	4a13      	ldr	r2, [pc, #76]	; (8001348 <RCC_HSEConfig+0x58>)
 80012fc:	6812      	ldr	r2, [r2, #0]
 80012fe:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001302:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 8001304:	4b10      	ldr	r3, [pc, #64]	; (8001348 <RCC_HSEConfig+0x58>)
 8001306:	4a10      	ldr	r2, [pc, #64]	; (8001348 <RCC_HSEConfig+0x58>)
 8001308:	6812      	ldr	r2, [r2, #0]
 800130a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800130e:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 8001310:	687b      	ldr	r3, [r7, #4]
 8001312:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001316:	d003      	beq.n	8001320 <RCC_HSEConfig+0x30>
 8001318:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800131c:	d007      	beq.n	800132e <RCC_HSEConfig+0x3e>
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
      break;
      
    default:
      break;
 800131e:	e00d      	b.n	800133c <RCC_HSEConfig+0x4c>
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 8001320:	4b09      	ldr	r3, [pc, #36]	; (8001348 <RCC_HSEConfig+0x58>)
 8001322:	4a09      	ldr	r2, [pc, #36]	; (8001348 <RCC_HSEConfig+0x58>)
 8001324:	6812      	ldr	r2, [r2, #0]
 8001326:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800132a:	601a      	str	r2, [r3, #0]
      break;
 800132c:	e006      	b.n	800133c <RCC_HSEConfig+0x4c>
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 800132e:	4b06      	ldr	r3, [pc, #24]	; (8001348 <RCC_HSEConfig+0x58>)
 8001330:	4a05      	ldr	r2, [pc, #20]	; (8001348 <RCC_HSEConfig+0x58>)
 8001332:	6812      	ldr	r2, [r2, #0]
 8001334:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 8001338:	601a      	str	r2, [r3, #0]
      break;
 800133a:	bf00      	nop
      
    default:
      break;
  }
}
 800133c:	f107 070c 	add.w	r7, r7, #12
 8001340:	46bd      	mov	sp, r7
 8001342:	bc80      	pop	{r7}
 8001344:	4770      	bx	lr
 8001346:	bf00      	nop
 8001348:	40021000 	.word	0x40021000

0800134c <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 800134c:	b580      	push	{r7, lr}
 800134e:	b082      	sub	sp, #8
 8001350:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0;
 8001352:	f04f 0300 	mov.w	r3, #0
 8001356:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
 8001358:	f04f 0300 	mov.w	r3, #0
 800135c:	71fb      	strb	r3, [r7, #7]
  FlagStatus HSEStatus = RESET;
 800135e:	f04f 0300 	mov.w	r3, #0
 8001362:	71bb      	strb	r3, [r7, #6]
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8001364:	f04f 0031 	mov.w	r0, #49	; 0x31
 8001368:	4b11      	ldr	r3, [pc, #68]	; (80013b0 <RCC_WaitForHSEStartUp+0x64>)
 800136a:	4798      	blx	r3
 800136c:	4603      	mov	r3, r0
 800136e:	71bb      	strb	r3, [r7, #6]
    StartUpCounter++;  
 8001370:	683b      	ldr	r3, [r7, #0]
 8001372:	f103 0301 	add.w	r3, r3, #1
 8001376:	603b      	str	r3, [r7, #0]
  } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
 8001378:	683b      	ldr	r3, [r7, #0]
 800137a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800137e:	d002      	beq.n	8001386 <RCC_WaitForHSEStartUp+0x3a>
 8001380:	79bb      	ldrb	r3, [r7, #6]
 8001382:	2b00      	cmp	r3, #0
 8001384:	d0ee      	beq.n	8001364 <RCC_WaitForHSEStartUp+0x18>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8001386:	f04f 0031 	mov.w	r0, #49	; 0x31
 800138a:	4b09      	ldr	r3, [pc, #36]	; (80013b0 <RCC_WaitForHSEStartUp+0x64>)
 800138c:	4798      	blx	r3
 800138e:	4603      	mov	r3, r0
 8001390:	2b00      	cmp	r3, #0
 8001392:	d003      	beq.n	800139c <RCC_WaitForHSEStartUp+0x50>
  {
    status = SUCCESS;
 8001394:	f04f 0301 	mov.w	r3, #1
 8001398:	71fb      	strb	r3, [r7, #7]
 800139a:	e002      	b.n	80013a2 <RCC_WaitForHSEStartUp+0x56>
  }
  else
  {
    status = ERROR;
 800139c:	f04f 0300 	mov.w	r3, #0
 80013a0:	71fb      	strb	r3, [r7, #7]
  }  
  return (status);
 80013a2:	79fb      	ldrb	r3, [r7, #7]
}
 80013a4:	4618      	mov	r0, r3
 80013a6:	f107 0708 	add.w	r7, r7, #8
 80013aa:	46bd      	mov	sp, r7
 80013ac:	bd80      	pop	{r7, pc}
 80013ae:	bf00      	nop
 80013b0:	0800156d 	.word	0x0800156d

080013b4 <RCC_PLLConfig>:
  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
{
 80013b4:	b480      	push	{r7}
 80013b6:	b085      	sub	sp, #20
 80013b8:	af00      	add	r7, sp, #0
 80013ba:	6078      	str	r0, [r7, #4]
 80013bc:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 80013be:	f04f 0300 	mov.w	r3, #0
 80013c2:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 80013c4:	4b0b      	ldr	r3, [pc, #44]	; (80013f4 <RCC_PLLConfig+0x40>)
 80013c6:	685b      	ldr	r3, [r3, #4]
 80013c8:	60fb      	str	r3, [r7, #12]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 80013ca:	68fb      	ldr	r3, [r7, #12]
 80013cc:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 80013d0:	60fb      	str	r3, [r7, #12]
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 80013d2:	687a      	ldr	r2, [r7, #4]
 80013d4:	683b      	ldr	r3, [r7, #0]
 80013d6:	ea42 0303 	orr.w	r3, r2, r3
 80013da:	68fa      	ldr	r2, [r7, #12]
 80013dc:	ea42 0303 	orr.w	r3, r2, r3
 80013e0:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80013e2:	4b04      	ldr	r3, [pc, #16]	; (80013f4 <RCC_PLLConfig+0x40>)
 80013e4:	68fa      	ldr	r2, [r7, #12]
 80013e6:	605a      	str	r2, [r3, #4]
}
 80013e8:	f107 0714 	add.w	r7, r7, #20
 80013ec:	46bd      	mov	sp, r7
 80013ee:	bc80      	pop	{r7}
 80013f0:	4770      	bx	lr
 80013f2:	bf00      	nop
 80013f4:	40021000 	.word	0x40021000

080013f8 <RCC_PLLCmd>:
  * @note   The PLL can not be disabled if it is used as system clock.
  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 80013f8:	b480      	push	{r7}
 80013fa:	b083      	sub	sp, #12
 80013fc:	af00      	add	r7, sp, #0
 80013fe:	4603      	mov	r3, r0
 8001400:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8001402:	4b04      	ldr	r3, [pc, #16]	; (8001414 <RCC_PLLCmd+0x1c>)
 8001404:	79fa      	ldrb	r2, [r7, #7]
 8001406:	601a      	str	r2, [r3, #0]
}
 8001408:	f107 070c 	add.w	r7, r7, #12
 800140c:	46bd      	mov	sp, r7
 800140e:	bc80      	pop	{r7}
 8001410:	4770      	bx	lr
 8001412:	bf00      	nop
 8001414:	42420060 	.word	0x42420060

08001418 <RCC_SYSCLKConfig>:
  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 8001418:	b480      	push	{r7}
 800141a:	b085      	sub	sp, #20
 800141c:	af00      	add	r7, sp, #0
 800141e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8001420:	f04f 0300 	mov.w	r3, #0
 8001424:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 8001426:	4b0a      	ldr	r3, [pc, #40]	; (8001450 <RCC_SYSCLKConfig+0x38>)
 8001428:	685b      	ldr	r3, [r3, #4]
 800142a:	60fb      	str	r3, [r7, #12]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 800142c:	68fb      	ldr	r3, [r7, #12]
 800142e:	f023 0303 	bic.w	r3, r3, #3
 8001432:	60fb      	str	r3, [r7, #12]
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8001434:	68fa      	ldr	r2, [r7, #12]
 8001436:	687b      	ldr	r3, [r7, #4]
 8001438:	ea42 0303 	orr.w	r3, r2, r3
 800143c:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800143e:	4b04      	ldr	r3, [pc, #16]	; (8001450 <RCC_SYSCLKConfig+0x38>)
 8001440:	68fa      	ldr	r2, [r7, #12]
 8001442:	605a      	str	r2, [r3, #4]
}
 8001444:	f107 0714 	add.w	r7, r7, #20
 8001448:	46bd      	mov	sp, r7
 800144a:	bc80      	pop	{r7}
 800144c:	4770      	bx	lr
 800144e:	bf00      	nop
 8001450:	40021000 	.word	0x40021000

08001454 <RCC_GetSYSCLKSource>:
  *     - 0x00: HSI used as system clock
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
 8001454:	b480      	push	{r7}
 8001456:	af00      	add	r7, sp, #0
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8001458:	4b04      	ldr	r3, [pc, #16]	; (800146c <RCC_GetSYSCLKSource+0x18>)
 800145a:	685b      	ldr	r3, [r3, #4]
 800145c:	b2db      	uxtb	r3, r3
 800145e:	f003 030c 	and.w	r3, r3, #12
 8001462:	b2db      	uxtb	r3, r3
}
 8001464:	4618      	mov	r0, r3
 8001466:	46bd      	mov	sp, r7
 8001468:	bc80      	pop	{r7}
 800146a:	4770      	bx	lr
 800146c:	40021000 	.word	0x40021000

08001470 <RCC_HCLKConfig>:
  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 8001470:	b480      	push	{r7}
 8001472:	b085      	sub	sp, #20
 8001474:	af00      	add	r7, sp, #0
 8001476:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8001478:	f04f 0300 	mov.w	r3, #0
 800147c:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 800147e:	4b0a      	ldr	r3, [pc, #40]	; (80014a8 <RCC_HCLKConfig+0x38>)
 8001480:	685b      	ldr	r3, [r3, #4]
 8001482:	60fb      	str	r3, [r7, #12]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 8001484:	68fb      	ldr	r3, [r7, #12]
 8001486:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800148a:	60fb      	str	r3, [r7, #12]
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 800148c:	68fa      	ldr	r2, [r7, #12]
 800148e:	687b      	ldr	r3, [r7, #4]
 8001490:	ea42 0303 	orr.w	r3, r2, r3
 8001494:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001496:	4b04      	ldr	r3, [pc, #16]	; (80014a8 <RCC_HCLKConfig+0x38>)
 8001498:	68fa      	ldr	r2, [r7, #12]
 800149a:	605a      	str	r2, [r3, #4]
}
 800149c:	f107 0714 	add.w	r7, r7, #20
 80014a0:	46bd      	mov	sp, r7
 80014a2:	bc80      	pop	{r7}
 80014a4:	4770      	bx	lr
 80014a6:	bf00      	nop
 80014a8:	40021000 	.word	0x40021000

080014ac <RCC_PCLK1Config>:
  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
 80014ac:	b480      	push	{r7}
 80014ae:	b085      	sub	sp, #20
 80014b0:	af00      	add	r7, sp, #0
 80014b2:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80014b4:	f04f 0300 	mov.w	r3, #0
 80014b8:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80014ba:	4b0a      	ldr	r3, [pc, #40]	; (80014e4 <RCC_PCLK1Config+0x38>)
 80014bc:	685b      	ldr	r3, [r3, #4]
 80014be:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 80014c0:	68fb      	ldr	r3, [r7, #12]
 80014c2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80014c6:	60fb      	str	r3, [r7, #12]
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 80014c8:	68fa      	ldr	r2, [r7, #12]
 80014ca:	687b      	ldr	r3, [r7, #4]
 80014cc:	ea42 0303 	orr.w	r3, r2, r3
 80014d0:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80014d2:	4b04      	ldr	r3, [pc, #16]	; (80014e4 <RCC_PCLK1Config+0x38>)
 80014d4:	68fa      	ldr	r2, [r7, #12]
 80014d6:	605a      	str	r2, [r3, #4]
}
 80014d8:	f107 0714 	add.w	r7, r7, #20
 80014dc:	46bd      	mov	sp, r7
 80014de:	bc80      	pop	{r7}
 80014e0:	4770      	bx	lr
 80014e2:	bf00      	nop
 80014e4:	40021000 	.word	0x40021000

080014e8 <RCC_PCLK2Config>:
  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
 80014e8:	b480      	push	{r7}
 80014ea:	b085      	sub	sp, #20
 80014ec:	af00      	add	r7, sp, #0
 80014ee:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80014f0:	f04f 0300 	mov.w	r3, #0
 80014f4:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80014f6:	4b0b      	ldr	r3, [pc, #44]	; (8001524 <RCC_PCLK2Config+0x3c>)
 80014f8:	685b      	ldr	r3, [r3, #4]
 80014fa:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 80014fc:	68fb      	ldr	r3, [r7, #12]
 80014fe:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8001502:	60fb      	str	r3, [r7, #12]
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8001504:	687b      	ldr	r3, [r7, #4]
 8001506:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800150a:	68fa      	ldr	r2, [r7, #12]
 800150c:	ea42 0303 	orr.w	r3, r2, r3
 8001510:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001512:	4b04      	ldr	r3, [pc, #16]	; (8001524 <RCC_PCLK2Config+0x3c>)
 8001514:	68fa      	ldr	r2, [r7, #12]
 8001516:	605a      	str	r2, [r3, #4]
}
 8001518:	f107 0714 	add.w	r7, r7, #20
 800151c:	46bd      	mov	sp, r7
 800151e:	bc80      	pop	{r7}
 8001520:	4770      	bx	lr
 8001522:	bf00      	nop
 8001524:	40021000 	.word	0x40021000

08001528 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8001528:	b480      	push	{r7}
 800152a:	b083      	sub	sp, #12
 800152c:	af00      	add	r7, sp, #0
 800152e:	6078      	str	r0, [r7, #4]
 8001530:	460b      	mov	r3, r1
 8001532:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001534:	78fb      	ldrb	r3, [r7, #3]
 8001536:	2b00      	cmp	r3, #0
 8001538:	d007      	beq.n	800154a <RCC_APB2PeriphClockCmd+0x22>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800153a:	4b0b      	ldr	r3, [pc, #44]	; (8001568 <RCC_APB2PeriphClockCmd+0x40>)
 800153c:	4a0a      	ldr	r2, [pc, #40]	; (8001568 <RCC_APB2PeriphClockCmd+0x40>)
 800153e:	6991      	ldr	r1, [r2, #24]
 8001540:	687a      	ldr	r2, [r7, #4]
 8001542:	ea41 0202 	orr.w	r2, r1, r2
 8001546:	619a      	str	r2, [r3, #24]
 8001548:	e008      	b.n	800155c <RCC_APB2PeriphClockCmd+0x34>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800154a:	4b07      	ldr	r3, [pc, #28]	; (8001568 <RCC_APB2PeriphClockCmd+0x40>)
 800154c:	4a06      	ldr	r2, [pc, #24]	; (8001568 <RCC_APB2PeriphClockCmd+0x40>)
 800154e:	6991      	ldr	r1, [r2, #24]
 8001550:	687a      	ldr	r2, [r7, #4]
 8001552:	ea6f 0202 	mvn.w	r2, r2
 8001556:	ea01 0202 	and.w	r2, r1, r2
 800155a:	619a      	str	r2, [r3, #24]
  }
}
 800155c:	f107 070c 	add.w	r7, r7, #12
 8001560:	46bd      	mov	sp, r7
 8001562:	bc80      	pop	{r7}
 8001564:	4770      	bx	lr
 8001566:	bf00      	nop
 8001568:	40021000 	.word	0x40021000

0800156c <RCC_GetFlagStatus>:
  *     @arg RCC_FLAG_LPWRRST: Low Power reset
  *   
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 800156c:	b480      	push	{r7}
 800156e:	b087      	sub	sp, #28
 8001570:	af00      	add	r7, sp, #0
 8001572:	4603      	mov	r3, r0
 8001574:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 8001576:	f04f 0300 	mov.w	r3, #0
 800157a:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 800157c:	f04f 0300 	mov.w	r3, #0
 8001580:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
 8001582:	f04f 0300 	mov.w	r3, #0
 8001586:	74fb      	strb	r3, [r7, #19]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8001588:	79fb      	ldrb	r3, [r7, #7]
 800158a:	ea4f 1353 	mov.w	r3, r3, lsr #5
 800158e:	b2db      	uxtb	r3, r3
 8001590:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
 8001592:	68fb      	ldr	r3, [r7, #12]
 8001594:	2b01      	cmp	r3, #1
 8001596:	d103      	bne.n	80015a0 <RCC_GetFlagStatus+0x34>
  {
    statusreg = RCC->CR;
 8001598:	4b14      	ldr	r3, [pc, #80]	; (80015ec <RCC_GetFlagStatus+0x80>)
 800159a:	681b      	ldr	r3, [r3, #0]
 800159c:	617b      	str	r3, [r7, #20]
 800159e:	e009      	b.n	80015b4 <RCC_GetFlagStatus+0x48>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 80015a0:	68fb      	ldr	r3, [r7, #12]
 80015a2:	2b02      	cmp	r3, #2
 80015a4:	d103      	bne.n	80015ae <RCC_GetFlagStatus+0x42>
  {
    statusreg = RCC->BDCR;
 80015a6:	4b11      	ldr	r3, [pc, #68]	; (80015ec <RCC_GetFlagStatus+0x80>)
 80015a8:	6a1b      	ldr	r3, [r3, #32]
 80015aa:	617b      	str	r3, [r7, #20]
 80015ac:	e002      	b.n	80015b4 <RCC_GetFlagStatus+0x48>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 80015ae:	4b0f      	ldr	r3, [pc, #60]	; (80015ec <RCC_GetFlagStatus+0x80>)
 80015b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80015b2:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 80015b4:	79fb      	ldrb	r3, [r7, #7]
 80015b6:	f003 031f 	and.w	r3, r3, #31
 80015ba:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80015bc:	68fb      	ldr	r3, [r7, #12]
 80015be:	697a      	ldr	r2, [r7, #20]
 80015c0:	fa22 f303 	lsr.w	r3, r2, r3
 80015c4:	f003 0301 	and.w	r3, r3, #1
 80015c8:	b2db      	uxtb	r3, r3
 80015ca:	2b00      	cmp	r3, #0
 80015cc:	d003      	beq.n	80015d6 <RCC_GetFlagStatus+0x6a>
  {
    bitstatus = SET;
 80015ce:	f04f 0301 	mov.w	r3, #1
 80015d2:	74fb      	strb	r3, [r7, #19]
 80015d4:	e002      	b.n	80015dc <RCC_GetFlagStatus+0x70>
  }
  else
  {
    bitstatus = RESET;
 80015d6:	f04f 0300 	mov.w	r3, #0
 80015da:	74fb      	strb	r3, [r7, #19]
  }

  /* Return the flag status */
  return bitstatus;
 80015dc:	7cfb      	ldrb	r3, [r7, #19]
}
 80015de:	4618      	mov	r0, r3
 80015e0:	f107 071c 	add.w	r7, r7, #28
 80015e4:	46bd      	mov	sp, r7
 80015e6:	bc80      	pop	{r7}
 80015e8:	4770      	bx	lr
 80015ea:	bf00      	nop
 80015ec:	40021000 	.word	0x40021000

080015f0 <DMA_DeInit>:
  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
  * @retval None
  */
void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
{
 80015f0:	b480      	push	{r7}
 80015f2:	b083      	sub	sp, #12
 80015f4:	af00      	add	r7, sp, #0
 80015f6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 80015f8:	687b      	ldr	r3, [r7, #4]
 80015fa:	681b      	ldr	r3, [r3, #0]
 80015fc:	f023 0201 	bic.w	r2, r3, #1
 8001600:	687b      	ldr	r3, [r7, #4]
 8001602:	601a      	str	r2, [r3, #0]
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8001604:	687b      	ldr	r3, [r7, #4]
 8001606:	f04f 0200 	mov.w	r2, #0
 800160a:	601a      	str	r2, [r3, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 800160c:	687b      	ldr	r3, [r7, #4]
 800160e:	f04f 0200 	mov.w	r2, #0
 8001612:	605a      	str	r2, [r3, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8001614:	687b      	ldr	r3, [r7, #4]
 8001616:	f04f 0200 	mov.w	r2, #0
 800161a:	609a      	str	r2, [r3, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 800161c:	687b      	ldr	r3, [r7, #4]
 800161e:	f04f 0200 	mov.w	r2, #0
 8001622:	60da      	str	r2, [r3, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8001624:	687a      	ldr	r2, [r7, #4]
 8001626:	4b43      	ldr	r3, [pc, #268]	; (8001734 <DMA_DeInit+0x144>)
 8001628:	429a      	cmp	r2, r3
 800162a:	d106      	bne.n	800163a <DMA_DeInit+0x4a>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
 800162c:	4b42      	ldr	r3, [pc, #264]	; (8001738 <DMA_DeInit+0x148>)
 800162e:	4a42      	ldr	r2, [pc, #264]	; (8001738 <DMA_DeInit+0x148>)
 8001630:	6852      	ldr	r2, [r2, #4]
 8001632:	f042 020f 	orr.w	r2, r2, #15
 8001636:	605a      	str	r2, [r3, #4]
 8001638:	e077      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 800163a:	687a      	ldr	r2, [r7, #4]
 800163c:	4b3f      	ldr	r3, [pc, #252]	; (800173c <DMA_DeInit+0x14c>)
 800163e:	429a      	cmp	r2, r3
 8001640:	d106      	bne.n	8001650 <DMA_DeInit+0x60>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
 8001642:	4b3d      	ldr	r3, [pc, #244]	; (8001738 <DMA_DeInit+0x148>)
 8001644:	4a3c      	ldr	r2, [pc, #240]	; (8001738 <DMA_DeInit+0x148>)
 8001646:	6852      	ldr	r2, [r2, #4]
 8001648:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 800164c:	605a      	str	r2, [r3, #4]
 800164e:	e06c      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8001650:	687a      	ldr	r2, [r7, #4]
 8001652:	4b3b      	ldr	r3, [pc, #236]	; (8001740 <DMA_DeInit+0x150>)
 8001654:	429a      	cmp	r2, r3
 8001656:	d106      	bne.n	8001666 <DMA_DeInit+0x76>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
 8001658:	4b37      	ldr	r3, [pc, #220]	; (8001738 <DMA_DeInit+0x148>)
 800165a:	4a37      	ldr	r2, [pc, #220]	; (8001738 <DMA_DeInit+0x148>)
 800165c:	6852      	ldr	r2, [r2, #4]
 800165e:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 8001662:	605a      	str	r2, [r3, #4]
 8001664:	e061      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 8001666:	687a      	ldr	r2, [r7, #4]
 8001668:	4b36      	ldr	r3, [pc, #216]	; (8001744 <DMA_DeInit+0x154>)
 800166a:	429a      	cmp	r2, r3
 800166c:	d106      	bne.n	800167c <DMA_DeInit+0x8c>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
 800166e:	4b32      	ldr	r3, [pc, #200]	; (8001738 <DMA_DeInit+0x148>)
 8001670:	4a31      	ldr	r2, [pc, #196]	; (8001738 <DMA_DeInit+0x148>)
 8001672:	6852      	ldr	r2, [r2, #4]
 8001674:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 8001678:	605a      	str	r2, [r3, #4]
 800167a:	e056      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 800167c:	687a      	ldr	r2, [r7, #4]
 800167e:	4b32      	ldr	r3, [pc, #200]	; (8001748 <DMA_DeInit+0x158>)
 8001680:	429a      	cmp	r2, r3
 8001682:	d106      	bne.n	8001692 <DMA_DeInit+0xa2>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
 8001684:	4b2c      	ldr	r3, [pc, #176]	; (8001738 <DMA_DeInit+0x148>)
 8001686:	4a2c      	ldr	r2, [pc, #176]	; (8001738 <DMA_DeInit+0x148>)
 8001688:	6852      	ldr	r2, [r2, #4]
 800168a:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 800168e:	605a      	str	r2, [r3, #4]
 8001690:	e04b      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 8001692:	687a      	ldr	r2, [r7, #4]
 8001694:	4b2d      	ldr	r3, [pc, #180]	; (800174c <DMA_DeInit+0x15c>)
 8001696:	429a      	cmp	r2, r3
 8001698:	d106      	bne.n	80016a8 <DMA_DeInit+0xb8>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 800169a:	4b27      	ldr	r3, [pc, #156]	; (8001738 <DMA_DeInit+0x148>)
 800169c:	4a26      	ldr	r2, [pc, #152]	; (8001738 <DMA_DeInit+0x148>)
 800169e:	6852      	ldr	r2, [r2, #4]
 80016a0:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 80016a4:	605a      	str	r2, [r3, #4]
 80016a6:	e040      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 80016a8:	687a      	ldr	r2, [r7, #4]
 80016aa:	4b29      	ldr	r3, [pc, #164]	; (8001750 <DMA_DeInit+0x160>)
 80016ac:	429a      	cmp	r2, r3
 80016ae:	d106      	bne.n	80016be <DMA_DeInit+0xce>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 80016b0:	4b21      	ldr	r3, [pc, #132]	; (8001738 <DMA_DeInit+0x148>)
 80016b2:	4a21      	ldr	r2, [pc, #132]	; (8001738 <DMA_DeInit+0x148>)
 80016b4:	6852      	ldr	r2, [r2, #4]
 80016b6:	f042 6270 	orr.w	r2, r2, #251658240	; 0xf000000
 80016ba:	605a      	str	r2, [r3, #4]
 80016bc:	e035      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 80016be:	687a      	ldr	r2, [r7, #4]
 80016c0:	4b24      	ldr	r3, [pc, #144]	; (8001754 <DMA_DeInit+0x164>)
 80016c2:	429a      	cmp	r2, r3
 80016c4:	d106      	bne.n	80016d4 <DMA_DeInit+0xe4>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 80016c6:	4b24      	ldr	r3, [pc, #144]	; (8001758 <DMA_DeInit+0x168>)
 80016c8:	4a23      	ldr	r2, [pc, #140]	; (8001758 <DMA_DeInit+0x168>)
 80016ca:	6852      	ldr	r2, [r2, #4]
 80016cc:	f042 020f 	orr.w	r2, r2, #15
 80016d0:	605a      	str	r2, [r3, #4]
 80016d2:	e02a      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 80016d4:	687a      	ldr	r2, [r7, #4]
 80016d6:	4b21      	ldr	r3, [pc, #132]	; (800175c <DMA_DeInit+0x16c>)
 80016d8:	429a      	cmp	r2, r3
 80016da:	d106      	bne.n	80016ea <DMA_DeInit+0xfa>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 80016dc:	4b1e      	ldr	r3, [pc, #120]	; (8001758 <DMA_DeInit+0x168>)
 80016de:	4a1e      	ldr	r2, [pc, #120]	; (8001758 <DMA_DeInit+0x168>)
 80016e0:	6852      	ldr	r2, [r2, #4]
 80016e2:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 80016e6:	605a      	str	r2, [r3, #4]
 80016e8:	e01f      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 80016ea:	687a      	ldr	r2, [r7, #4]
 80016ec:	4b1c      	ldr	r3, [pc, #112]	; (8001760 <DMA_DeInit+0x170>)
 80016ee:	429a      	cmp	r2, r3
 80016f0:	d106      	bne.n	8001700 <DMA_DeInit+0x110>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 80016f2:	4b19      	ldr	r3, [pc, #100]	; (8001758 <DMA_DeInit+0x168>)
 80016f4:	4a18      	ldr	r2, [pc, #96]	; (8001758 <DMA_DeInit+0x168>)
 80016f6:	6852      	ldr	r2, [r2, #4]
 80016f8:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 80016fc:	605a      	str	r2, [r3, #4]
 80016fe:	e014      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 8001700:	687a      	ldr	r2, [r7, #4]
 8001702:	4b18      	ldr	r3, [pc, #96]	; (8001764 <DMA_DeInit+0x174>)
 8001704:	429a      	cmp	r2, r3
 8001706:	d106      	bne.n	8001716 <DMA_DeInit+0x126>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 8001708:	4b13      	ldr	r3, [pc, #76]	; (8001758 <DMA_DeInit+0x168>)
 800170a:	4a13      	ldr	r2, [pc, #76]	; (8001758 <DMA_DeInit+0x168>)
 800170c:	6852      	ldr	r2, [r2, #4]
 800170e:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 8001712:	605a      	str	r2, [r3, #4]
 8001714:	e009      	b.n	800172a <DMA_DeInit+0x13a>
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 8001716:	687a      	ldr	r2, [r7, #4]
 8001718:	4b13      	ldr	r3, [pc, #76]	; (8001768 <DMA_DeInit+0x178>)
 800171a:	429a      	cmp	r2, r3
 800171c:	d105      	bne.n	800172a <DMA_DeInit+0x13a>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 800171e:	4b0e      	ldr	r3, [pc, #56]	; (8001758 <DMA_DeInit+0x168>)
 8001720:	4a0d      	ldr	r2, [pc, #52]	; (8001758 <DMA_DeInit+0x168>)
 8001722:	6852      	ldr	r2, [r2, #4]
 8001724:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 8001728:	605a      	str	r2, [r3, #4]
    }
  }
}
 800172a:	f107 070c 	add.w	r7, r7, #12
 800172e:	46bd      	mov	sp, r7
 8001730:	bc80      	pop	{r7}
 8001732:	4770      	bx	lr
 8001734:	40020008 	.word	0x40020008
 8001738:	40020000 	.word	0x40020000
 800173c:	4002001c 	.word	0x4002001c
 8001740:	40020030 	.word	0x40020030
 8001744:	40020044 	.word	0x40020044
 8001748:	40020058 	.word	0x40020058
 800174c:	4002006c 	.word	0x4002006c
 8001750:	40020080 	.word	0x40020080
 8001754:	40020408 	.word	0x40020408
 8001758:	40020400 	.word	0x40020400
 800175c:	4002041c 	.word	0x4002041c
 8001760:	40020430 	.word	0x40020430
 8001764:	40020444 	.word	0x40020444
 8001768:	40020458 	.word	0x40020458

0800176c <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
  *   contains the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 800176c:	b480      	push	{r7}
 800176e:	b085      	sub	sp, #20
 8001770:	af00      	add	r7, sp, #0
 8001772:	6078      	str	r0, [r7, #4]
 8001774:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8001776:	f04f 0300 	mov.w	r3, #0
 800177a:	60fb      	str	r3, [r7, #12]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 800177c:	687b      	ldr	r3, [r7, #4]
 800177e:	681b      	ldr	r3, [r3, #0]
 8001780:	60fb      	str	r3, [r7, #12]
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8001782:	68fb      	ldr	r3, [r7, #12]
 8001784:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8001788:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800178c:	60fb      	str	r3, [r7, #12]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800178e:	683b      	ldr	r3, [r7, #0]
 8001790:	689a      	ldr	r2, [r3, #8]
 8001792:	683b      	ldr	r3, [r7, #0]
 8001794:	6a1b      	ldr	r3, [r3, #32]
 8001796:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8001798:	683b      	ldr	r3, [r7, #0]
 800179a:	691b      	ldr	r3, [r3, #16]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800179c:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800179e:	683b      	ldr	r3, [r7, #0]
 80017a0:	695b      	ldr	r3, [r3, #20]
 80017a2:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 80017a4:	683b      	ldr	r3, [r7, #0]
 80017a6:	699b      	ldr	r3, [r3, #24]
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 80017a8:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 80017aa:	683b      	ldr	r3, [r7, #0]
 80017ac:	69db      	ldr	r3, [r3, #28]
 80017ae:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 80017b0:	683b      	ldr	r3, [r7, #0]
 80017b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 80017b4:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 80017b6:	683b      	ldr	r3, [r7, #0]
 80017b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80017ba:	ea42 0303 	orr.w	r3, r2, r3
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80017be:	68fa      	ldr	r2, [r7, #12]
 80017c0:	ea42 0303 	orr.w	r3, r2, r3
 80017c4:	60fb      	str	r3, [r7, #12]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 80017c6:	687b      	ldr	r3, [r7, #4]
 80017c8:	68fa      	ldr	r2, [r7, #12]
 80017ca:	601a      	str	r2, [r3, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 80017cc:	683b      	ldr	r3, [r7, #0]
 80017ce:	68da      	ldr	r2, [r3, #12]
 80017d0:	687b      	ldr	r3, [r7, #4]
 80017d2:	605a      	str	r2, [r3, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 80017d4:	683b      	ldr	r3, [r7, #0]
 80017d6:	681a      	ldr	r2, [r3, #0]
 80017d8:	687b      	ldr	r3, [r7, #4]
 80017da:	609a      	str	r2, [r3, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 80017dc:	683b      	ldr	r3, [r7, #0]
 80017de:	685a      	ldr	r2, [r3, #4]
 80017e0:	687b      	ldr	r3, [r7, #4]
 80017e2:	60da      	str	r2, [r3, #12]
}
 80017e4:	f107 0714 	add.w	r7, r7, #20
 80017e8:	46bd      	mov	sp, r7
 80017ea:	bc80      	pop	{r7}
 80017ec:	4770      	bx	lr
 80017ee:	bf00      	nop

080017f0 <DMA_Cmd>:
  * @param  NewState: new state of the DMAy Channelx. 
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
{
 80017f0:	b480      	push	{r7}
 80017f2:	b083      	sub	sp, #12
 80017f4:	af00      	add	r7, sp, #0
 80017f6:	6078      	str	r0, [r7, #4]
 80017f8:	460b      	mov	r3, r1
 80017fa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80017fc:	78fb      	ldrb	r3, [r7, #3]
 80017fe:	2b00      	cmp	r3, #0
 8001800:	d006      	beq.n	8001810 <DMA_Cmd+0x20>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= CCR_ENABLE_Set;
 8001802:	687b      	ldr	r3, [r7, #4]
 8001804:	681b      	ldr	r3, [r3, #0]
 8001806:	f043 0201 	orr.w	r2, r3, #1
 800180a:	687b      	ldr	r3, [r7, #4]
 800180c:	601a      	str	r2, [r3, #0]
 800180e:	e005      	b.n	800181c <DMA_Cmd+0x2c>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 8001810:	687b      	ldr	r3, [r7, #4]
 8001812:	681b      	ldr	r3, [r3, #0]
 8001814:	f023 0201 	bic.w	r2, r3, #1
 8001818:	687b      	ldr	r3, [r7, #4]
 800181a:	601a      	str	r2, [r3, #0]
  }
}
 800181c:	f107 070c 	add.w	r7, r7, #12
 8001820:	46bd      	mov	sp, r7
 8001822:	bc80      	pop	{r7}
 8001824:	4770      	bx	lr
 8001826:	bf00      	nop

08001828 <DMA_ITConfig>:
  * @param  NewState: new state of the specified DMA interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)
{
 8001828:	b480      	push	{r7}
 800182a:	b085      	sub	sp, #20
 800182c:	af00      	add	r7, sp, #0
 800182e:	60f8      	str	r0, [r7, #12]
 8001830:	60b9      	str	r1, [r7, #8]
 8001832:	4613      	mov	r3, r2
 8001834:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001836:	79fb      	ldrb	r3, [r7, #7]
 8001838:	2b00      	cmp	r3, #0
 800183a:	d006      	beq.n	800184a <DMA_ITConfig+0x22>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 800183c:	68fb      	ldr	r3, [r7, #12]
 800183e:	681a      	ldr	r2, [r3, #0]
 8001840:	68bb      	ldr	r3, [r7, #8]
 8001842:	431a      	orrs	r2, r3
 8001844:	68fb      	ldr	r3, [r7, #12]
 8001846:	601a      	str	r2, [r3, #0]
 8001848:	e007      	b.n	800185a <DMA_ITConfig+0x32>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 800184a:	68fb      	ldr	r3, [r7, #12]
 800184c:	681a      	ldr	r2, [r3, #0]
 800184e:	68bb      	ldr	r3, [r7, #8]
 8001850:	ea6f 0303 	mvn.w	r3, r3
 8001854:	401a      	ands	r2, r3
 8001856:	68fb      	ldr	r3, [r7, #12]
 8001858:	601a      	str	r2, [r3, #0]
  }
}
 800185a:	f107 0714 	add.w	r7, r7, #20
 800185e:	46bd      	mov	sp, r7
 8001860:	bc80      	pop	{r7}
 8001862:	4770      	bx	lr

08001864 <DMA_ClearFlag>:
  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
  * @retval None
  */
void DMA_ClearFlag(uint32_t DMA_FLAG)
{
 8001864:	b480      	push	{r7}
 8001866:	b083      	sub	sp, #12
 8001868:	af00      	add	r7, sp, #0
 800186a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
  /* Calculate the used DMA */

  if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
 800186c:	687b      	ldr	r3, [r7, #4]
 800186e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001872:	2b00      	cmp	r3, #0
 8001874:	d003      	beq.n	800187e <DMA_ClearFlag+0x1a>
  {
    /* Clear the selected DMA flags */
    DMA2->IFCR = DMA_FLAG;
 8001876:	4b06      	ldr	r3, [pc, #24]	; (8001890 <DMA_ClearFlag+0x2c>)
 8001878:	687a      	ldr	r2, [r7, #4]
 800187a:	605a      	str	r2, [r3, #4]
 800187c:	e002      	b.n	8001884 <DMA_ClearFlag+0x20>
  }
  else
  {
    /* Clear the selected DMA flags */
    DMA1->IFCR = DMA_FLAG;
 800187e:	4b05      	ldr	r3, [pc, #20]	; (8001894 <DMA_ClearFlag+0x30>)
 8001880:	687a      	ldr	r2, [r7, #4]
 8001882:	605a      	str	r2, [r3, #4]
  }
}
 8001884:	f107 070c 	add.w	r7, r7, #12
 8001888:	46bd      	mov	sp, r7
 800188a:	bc80      	pop	{r7}
 800188c:	4770      	bx	lr
 800188e:	bf00      	nop
 8001890:	40020400 	.word	0x40020400
 8001894:	40020000 	.word	0x40020000

08001898 <NVIC_SetVectorTable>:
  *     @arg NVIC_VectTab_FLASH
  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x100.
  * @retval None
  */
void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
{ 
 8001898:	b480      	push	{r7}
 800189a:	b083      	sub	sp, #12
 800189c:	af00      	add	r7, sp, #0
 800189e:	6078      	str	r0, [r7, #4]
 80018a0:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 80018a2:	4a07      	ldr	r2, [pc, #28]	; (80018c0 <NVIC_SetVectorTable+0x28>)
 80018a4:	683b      	ldr	r3, [r7, #0]
 80018a6:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80018aa:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80018ae:	6879      	ldr	r1, [r7, #4]
 80018b0:	430b      	orrs	r3, r1
 80018b2:	6093      	str	r3, [r2, #8]
}
 80018b4:	f107 070c 	add.w	r7, r7, #12
 80018b8:	46bd      	mov	sp, r7
 80018ba:	bc80      	pop	{r7}
 80018bc:	4770      	bx	lr
 80018be:	bf00      	nop
 80018c0:	e000ed00 	.word	0xe000ed00

080018c4 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80018c4:	b480      	push	{r7}
 80018c6:	b083      	sub	sp, #12
 80018c8:	af00      	add	r7, sp, #0
 80018ca:	4603      	mov	r3, r0
 80018cc:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 80018ce:	4b09      	ldr	r3, [pc, #36]	; (80018f4 <NVIC_EnableIRQ+0x30>)
 80018d0:	f997 2007 	ldrsb.w	r2, [r7, #7]
 80018d4:	ea4f 1252 	mov.w	r2, r2, lsr #5
 80018d8:	79f9      	ldrb	r1, [r7, #7]
 80018da:	f001 011f 	and.w	r1, r1, #31
 80018de:	f04f 0001 	mov.w	r0, #1
 80018e2:	fa00 f101 	lsl.w	r1, r0, r1
 80018e6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80018ea:	f107 070c 	add.w	r7, r7, #12
 80018ee:	46bd      	mov	sp, r7
 80018f0:	bc80      	pop	{r7}
 80018f2:	4770      	bx	lr
 80018f4:	e000e100 	.word	0xe000e100

080018f8 <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt. \n
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80018f8:	b480      	push	{r7}
 80018fa:	b083      	sub	sp, #12
 80018fc:	af00      	add	r7, sp, #0
 80018fe:	4603      	mov	r3, r0
 8001900:	6039      	str	r1, [r7, #0]
 8001902:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8001904:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001908:	2b00      	cmp	r3, #0
 800190a:	da0d      	bge.n	8001928 <NVIC_SetPriority+0x30>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
 800190c:	490e      	ldr	r1, [pc, #56]	; (8001948 <NVIC_SetPriority+0x50>)
 800190e:	79fb      	ldrb	r3, [r7, #7]
 8001910:	f003 030f 	and.w	r3, r3, #15
 8001914:	f1a3 0304 	sub.w	r3, r3, #4
 8001918:	683a      	ldr	r2, [r7, #0]
 800191a:	b2d2      	uxtb	r2, r2
 800191c:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8001920:	b2d2      	uxtb	r2, r2
 8001922:	18cb      	adds	r3, r1, r3
 8001924:	761a      	strb	r2, [r3, #24]
 8001926:	e00a      	b.n	800193e <NVIC_SetPriority+0x46>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts      */
 8001928:	4908      	ldr	r1, [pc, #32]	; (800194c <NVIC_SetPriority+0x54>)
 800192a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800192e:	683a      	ldr	r2, [r7, #0]
 8001930:	b2d2      	uxtb	r2, r2
 8001932:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8001936:	b2d2      	uxtb	r2, r2
 8001938:	18cb      	adds	r3, r1, r3
 800193a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800193e:	f107 070c 	add.w	r7, r7, #12
 8001942:	46bd      	mov	sp, r7
 8001944:	bc80      	pop	{r7}
 8001946:	4770      	bx	lr
 8001948:	e000ed00 	.word	0xe000ed00
 800194c:	e000e100 	.word	0xe000e100

08001950 <uartTxDMAConfiguration>:
UART_FIFO_STR u1Fifo;


void uartTxDMAConfiguration(USART_TypeDef *uart, DMA_Channel_TypeDef *dmatx,
		uint8_t *txBuf, uint32_t len, bool ie)
{
 8001950:	b580      	push	{r7, lr}
 8001952:	b090      	sub	sp, #64	; 0x40
 8001954:	af00      	add	r7, sp, #0
 8001956:	60f8      	str	r0, [r7, #12]
 8001958:	60b9      	str	r1, [r7, #8]
 800195a:	607a      	str	r2, [r7, #4]
 800195c:	603b      	str	r3, [r7, #0]
	DMA_InitTypeDef DMA_InitStructure;

	/* DMA1 Channel (triggered by USART_Tx event) Config */
	DMA_DeInit(dmatx);
 800195e:	68b8      	ldr	r0, [r7, #8]
 8001960:	4b20      	ldr	r3, [pc, #128]	; (80019e4 <uartTxDMAConfiguration+0x94>)
 8001962:	4798      	blx	r3
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &uart->DR;
 8001964:	68fb      	ldr	r3, [r7, #12]
 8001966:	f103 0304 	add.w	r3, r3, #4
 800196a:	617b      	str	r3, [r7, #20]
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) txBuf;
 800196c:	687b      	ldr	r3, [r7, #4]
 800196e:	61bb      	str	r3, [r7, #24]
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8001970:	f04f 0310 	mov.w	r3, #16
 8001974:	61fb      	str	r3, [r7, #28]
	DMA_InitStructure.DMA_BufferSize = len;
 8001976:	683b      	ldr	r3, [r7, #0]
 8001978:	623b      	str	r3, [r7, #32]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800197a:	f04f 0300 	mov.w	r3, #0
 800197e:	627b      	str	r3, [r7, #36]	; 0x24
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8001980:	f04f 0380 	mov.w	r3, #128	; 0x80
 8001984:	62bb      	str	r3, [r7, #40]	; 0x28
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8001986:	f04f 0300 	mov.w	r3, #0
 800198a:	62fb      	str	r3, [r7, #44]	; 0x2c
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 800198c:	f04f 0300 	mov.w	r3, #0
 8001990:	633b      	str	r3, [r7, #48]	; 0x30
	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8001992:	f04f 0300 	mov.w	r3, #0
 8001996:	637b      	str	r3, [r7, #52]	; 0x34
	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
 8001998:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 800199c:	63bb      	str	r3, [r7, #56]	; 0x38
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 800199e:	f04f 0300 	mov.w	r3, #0
 80019a2:	63fb      	str	r3, [r7, #60]	; 0x3c
	DMA_Init(dmatx, &DMA_InitStructure);
 80019a4:	f107 0314 	add.w	r3, r7, #20
 80019a8:	68b8      	ldr	r0, [r7, #8]
 80019aa:	4619      	mov	r1, r3
 80019ac:	4b0e      	ldr	r3, [pc, #56]	; (80019e8 <uartTxDMAConfiguration+0x98>)
 80019ae:	4798      	blx	r3
	DMA_Cmd(dmatx, ENABLE);
 80019b0:	68b8      	ldr	r0, [r7, #8]
 80019b2:	f04f 0101 	mov.w	r1, #1
 80019b6:	4b0d      	ldr	r3, [pc, #52]	; (80019ec <uartTxDMAConfiguration+0x9c>)
 80019b8:	4798      	blx	r3
	//if (ie)
	{
		DMA_ITConfig(USART1_TX_DMA, DMA_IT_TC, ENABLE);
 80019ba:	480d      	ldr	r0, [pc, #52]	; (80019f0 <uartTxDMAConfiguration+0xa0>)
 80019bc:	f04f 0102 	mov.w	r1, #2
 80019c0:	f04f 0201 	mov.w	r2, #1
 80019c4:	4b0b      	ldr	r3, [pc, #44]	; (80019f4 <uartTxDMAConfiguration+0xa4>)
 80019c6:	4798      	blx	r3
	}
	/* Enable USART_Tx DMA Tansmit request */
	/* Configure DMA1_Channel_Tx interrupt */
	NVIC_SetPriority(USART1_TX_DMA_IRQn, 0x01);
 80019c8:	f04f 000e 	mov.w	r0, #14
 80019cc:	f04f 0101 	mov.w	r1, #1
 80019d0:	4b09      	ldr	r3, [pc, #36]	; (80019f8 <uartTxDMAConfiguration+0xa8>)
 80019d2:	4798      	blx	r3
	NVIC_EnableIRQ(USART1_TX_DMA_IRQn);
 80019d4:	f04f 000e 	mov.w	r0, #14
 80019d8:	4b08      	ldr	r3, [pc, #32]	; (80019fc <uartTxDMAConfiguration+0xac>)
 80019da:	4798      	blx	r3
}
 80019dc:	f107 0740 	add.w	r7, r7, #64	; 0x40
 80019e0:	46bd      	mov	sp, r7
 80019e2:	bd80      	pop	{r7, pc}
 80019e4:	080015f1 	.word	0x080015f1
 80019e8:	0800176d 	.word	0x0800176d
 80019ec:	080017f1 	.word	0x080017f1
 80019f0:	40020044 	.word	0x40020044
 80019f4:	08001829 	.word	0x08001829
 80019f8:	080018f9 	.word	0x080018f9
 80019fc:	080018c5 	.word	0x080018c5

08001a00 <uart1TxTask>:
	//	IEC2bits.DMA4IE = 1;
	return 1;
}
//-----------------------------------------------------------------------------------
void uart1TxTask()
{
 8001a00:	b590      	push	{r4, r7, lr}
 8001a02:	b085      	sub	sp, #20
 8001a04:	af02      	add	r7, sp, #8
	unsigned int cnt = 0;
 8001a06:	f04f 0300 	mov.w	r3, #0
 8001a0a:	607b      	str	r3, [r7, #4]
	// If DMA COMPLITE
	if ((USART1_TX_DMA->CCR & ((uint32_t) 0x00000001)) == 0)
 8001a0c:	4b1e      	ldr	r3, [pc, #120]	; (8001a88 <uart1TxTask+0x88>)
 8001a0e:	681b      	ldr	r3, [r3, #0]
 8001a10:	f003 0301 	and.w	r3, r3, #1
 8001a14:	2b00      	cmp	r3, #0
 8001a16:	d133      	bne.n	8001a80 <uart1TxTask+0x80>
	{
		while ((u1Fifo.txCurrentStart != u1Fifo.txCurrentEnd) && (cnt
 8001a18:	e01d      	b.n	8001a56 <uart1TxTask+0x56>
				< UARTTX_FIFO_SIZE))
		{
			u1Fifo.txBuf[cnt] = u1Fifo.txBufB[u1Fifo.txCurrentStart];
 8001a1a:	4b1c      	ldr	r3, [pc, #112]	; (8001a8c <uart1TxTask+0x8c>)
 8001a1c:	685b      	ldr	r3, [r3, #4]
 8001a1e:	4a1b      	ldr	r2, [pc, #108]	; (8001a8c <uart1TxTask+0x8c>)
 8001a20:	18d3      	adds	r3, r2, r3
 8001a22:	f893 244c 	ldrb.w	r2, [r3, #1100]	; 0x44c
 8001a26:	4919      	ldr	r1, [pc, #100]	; (8001a8c <uart1TxTask+0x8c>)
 8001a28:	687b      	ldr	r3, [r7, #4]
 8001a2a:	18cb      	adds	r3, r1, r3
 8001a2c:	f503 6381 	add.w	r3, r3, #1032	; 0x408
 8001a30:	711a      	strb	r2, [r3, #4]
			u1Fifo.txCurrentStart++;
 8001a32:	4b16      	ldr	r3, [pc, #88]	; (8001a8c <uart1TxTask+0x8c>)
 8001a34:	685b      	ldr	r3, [r3, #4]
 8001a36:	f103 0201 	add.w	r2, r3, #1
 8001a3a:	4b14      	ldr	r3, [pc, #80]	; (8001a8c <uart1TxTask+0x8c>)
 8001a3c:	605a      	str	r2, [r3, #4]
			u1Fifo.txCurrentStart &= UARTTX_FIFOB_SIZE_MASK;
 8001a3e:	4b13      	ldr	r3, [pc, #76]	; (8001a8c <uart1TxTask+0x8c>)
 8001a40:	685b      	ldr	r3, [r3, #4]
 8001a42:	ea4f 5383 	mov.w	r3, r3, lsl #22
 8001a46:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8001a4a:	4a10      	ldr	r2, [pc, #64]	; (8001a8c <uart1TxTask+0x8c>)
 8001a4c:	6053      	str	r3, [r2, #4]
			cnt++;
 8001a4e:	687b      	ldr	r3, [r7, #4]
 8001a50:	f103 0301 	add.w	r3, r3, #1
 8001a54:	607b      	str	r3, [r7, #4]
{
	unsigned int cnt = 0;
	// If DMA COMPLITE
	if ((USART1_TX_DMA->CCR & ((uint32_t) 0x00000001)) == 0)
	{
		while ((u1Fifo.txCurrentStart != u1Fifo.txCurrentEnd) && (cnt
 8001a56:	4b0d      	ldr	r3, [pc, #52]	; (8001a8c <uart1TxTask+0x8c>)
 8001a58:	685a      	ldr	r2, [r3, #4]
 8001a5a:	4b0c      	ldr	r3, [pc, #48]	; (8001a8c <uart1TxTask+0x8c>)
 8001a5c:	689b      	ldr	r3, [r3, #8]
 8001a5e:	429a      	cmp	r2, r3
 8001a60:	d002      	beq.n	8001a68 <uart1TxTask+0x68>
 8001a62:	687b      	ldr	r3, [r7, #4]
 8001a64:	2b3f      	cmp	r3, #63	; 0x3f
 8001a66:	d9d8      	bls.n	8001a1a <uart1TxTask+0x1a>
			u1Fifo.txBuf[cnt] = u1Fifo.txBufB[u1Fifo.txCurrentStart];
			u1Fifo.txCurrentStart++;
			u1Fifo.txCurrentStart &= UARTTX_FIFOB_SIZE_MASK;
			cnt++;
		}
		if (cnt > 0)
 8001a68:	687b      	ldr	r3, [r7, #4]
 8001a6a:	2b00      	cmp	r3, #0
 8001a6c:	d008      	beq.n	8001a80 <uart1TxTask+0x80>
		{
			uartTxDMAConfiguration(USART1, USART1_TX_DMA, u1Fifo.txBuf, cnt,
 8001a6e:	f04f 0301 	mov.w	r3, #1
 8001a72:	9300      	str	r3, [sp, #0]
 8001a74:	4806      	ldr	r0, [pc, #24]	; (8001a90 <uart1TxTask+0x90>)
 8001a76:	4904      	ldr	r1, [pc, #16]	; (8001a88 <uart1TxTask+0x88>)
 8001a78:	4a06      	ldr	r2, [pc, #24]	; (8001a94 <uart1TxTask+0x94>)
 8001a7a:	687b      	ldr	r3, [r7, #4]
 8001a7c:	4c06      	ldr	r4, [pc, #24]	; (8001a98 <uart1TxTask+0x98>)
 8001a7e:	47a0      	blx	r4
					1);
		}
	}
}
 8001a80:	f107 070c 	add.w	r7, r7, #12
 8001a84:	46bd      	mov	sp, r7
 8001a86:	bd90      	pop	{r4, r7, pc}
 8001a88:	40020044 	.word	0x40020044
 8001a8c:	20002a94 	.word	0x20002a94
 8001a90:	40013800 	.word	0x40013800
 8001a94:	20002ea0 	.word	0x20002ea0
 8001a98:	08001951 	.word	0x08001951

08001a9c <DMA1_Channel4_IRQHandler>:
	uart1TxTask();
}

//UART 1 DMA INTERRUPT
void DMA1_Channel4_IRQHandler(void)
{
 8001a9c:	b580      	push	{r7, lr}
 8001a9e:	af00      	add	r7, sp, #0

	/* Disable DMA1_Channel4 transfer*/
	DMA_Cmd(USART1_TX_DMA, DISABLE);
 8001aa0:	4805      	ldr	r0, [pc, #20]	; (8001ab8 <DMA1_Channel4_IRQHandler+0x1c>)
 8001aa2:	f04f 0100 	mov.w	r1, #0
 8001aa6:	4b05      	ldr	r3, [pc, #20]	; (8001abc <DMA1_Channel4_IRQHandler+0x20>)
 8001aa8:	4798      	blx	r3
	/*  Clear DMA1_Channel4 Transfer Complete Flag*/
	DMA_ClearFlag(DMA1_FLAG_TC4);
 8001aaa:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8001aae:	4b04      	ldr	r3, [pc, #16]	; (8001ac0 <DMA1_Channel4_IRQHandler+0x24>)
 8001ab0:	4798      	blx	r3
	uart1TxTask();
 8001ab2:	4b04      	ldr	r3, [pc, #16]	; (8001ac4 <DMA1_Channel4_IRQHandler+0x28>)
 8001ab4:	4798      	blx	r3
}
 8001ab6:	bd80      	pop	{r7, pc}
 8001ab8:	40020044 	.word	0x40020044
 8001abc:	080017f1 	.word	0x080017f1
 8001ac0:	08001865 	.word	0x08001865
 8001ac4:	08001a01 	.word	0x08001a01

08001ac8 <USART1_IRQHandler>:
void USART1_IRQHandler(void)
{
 8001ac8:	b480      	push	{r7}
 8001aca:	af00      	add	r7, sp, #0
	//u1Fifo.rxBuf[0] = '$';

}
 8001acc:	46bd      	mov	sp, r7
 8001ace:	bc80      	pop	{r7}
 8001ad0:	4770      	bx	lr
 8001ad2:	bf00      	nop

08001ad4 <main>:

#define vLogicaTask_PRIORITY            ( tskIDLE_PRIORITY + 2 )
#define vRs485Task_PRIORITY            ( tskIDLE_PRIORITY + 1 )

int main(void)
{
 8001ad4:	b590      	push	{r4, r7, lr}
 8001ad6:	b085      	sub	sp, #20
 8001ad8:	af04      	add	r7, sp, #16
	hwInit();
 8001ada:	4b0e      	ldr	r3, [pc, #56]	; (8001b14 <main+0x40>)
 8001adc:	4798      	blx	r3
	/* Configure the GPIO ports */
	GPIO_Configuration();
 8001ade:	4b0e      	ldr	r3, [pc, #56]	; (8001b18 <main+0x44>)
 8001ae0:	4798      	blx	r3

	/* Turn on/off LED(s) */

	xTaskCreate(vLogicaTask, (const signed portCHAR * const ) "Logica",
 8001ae2:	4b0e      	ldr	r3, [pc, #56]	; (8001b1c <main+0x48>)
 8001ae4:	f04f 0202 	mov.w	r2, #2
 8001ae8:	9200      	str	r2, [sp, #0]
 8001aea:	f04f 0200 	mov.w	r2, #0
 8001aee:	9201      	str	r2, [sp, #4]
 8001af0:	f04f 0200 	mov.w	r2, #0
 8001af4:	9202      	str	r2, [sp, #8]
 8001af6:	f04f 0200 	mov.w	r2, #0
 8001afa:	9203      	str	r2, [sp, #12]
 8001afc:	4808      	ldr	r0, [pc, #32]	; (8001b20 <main+0x4c>)
 8001afe:	4619      	mov	r1, r3
 8001b00:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8001b04:	f04f 0300 	mov.w	r3, #0
 8001b08:	4c06      	ldr	r4, [pc, #24]	; (8001b24 <main+0x50>)
 8001b0a:	47a0      	blx	r4
//			vRs485Task_STACK_SIZE, NULL, vRs485Task_PRIORITY,
//			(xTaskHandle *) NULL);

	/* Start the scheduler. */

	vTaskStartScheduler();
 8001b0c:	4b06      	ldr	r3, [pc, #24]	; (8001b28 <main+0x54>)
 8001b0e:	4798      	blx	r3
	while (1)
	{
	};
 8001b10:	e7fe      	b.n	8001b10 <main+0x3c>
 8001b12:	bf00      	nop
 8001b14:	080002c9 	.word	0x080002c9
 8001b18:	08001b39 	.word	0x08001b39
 8001b1c:	08001c08 	.word	0x08001c08
 8001b20:	08001bc5 	.word	0x08001bc5
 8001b24:	080002e1 	.word	0x080002e1
 8001b28:	08000501 	.word	0x08000501

08001b2c <vApplicationTickHook>:
int t2time, t2count;
int t1oldval, t2oldval;
extern int T1, T2;

void vApplicationTickHook(void)
{
 8001b2c:	b480      	push	{r7}
 8001b2e:	af00      	add	r7, sp, #0
	t1time++;
	t1oldval = t1val;
	t2oldval = t2val;
*/
	//---------------------------------------------------------
}
 8001b30:	46bd      	mov	sp, r7
 8001b32:	bc80      	pop	{r7}
 8001b34:	4770      	bx	lr
 8001b36:	bf00      	nop

08001b38 <GPIO_Configuration>:
	while (1)
		;
}

void GPIO_Configuration(void)
{
 8001b38:	b580      	push	{r7, lr}
 8001b3a:	b082      	sub	sp, #8
 8001b3c:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	/* Enable GPIOC clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
 8001b3e:	f04f 0010 	mov.w	r0, #16
 8001b42:	f04f 0101 	mov.w	r1, #1
 8001b46:	4b1b      	ldr	r3, [pc, #108]	; (8001bb4 <GPIO_Configuration+0x7c>)
 8001b48:	4798      	blx	r3
	/* Enable GPIOC clock */
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
 8001b4a:	f04f 0008 	mov.w	r0, #8
 8001b4e:	f04f 0101 	mov.w	r1, #1
 8001b52:	4b18      	ldr	r3, [pc, #96]	; (8001bb4 <GPIO_Configuration+0x7c>)
 8001b54:	4798      	blx	r3


	/* Configure PC.4 as Output push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 8001b56:	f04f 0320 	mov.w	r3, #32
 8001b5a:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8001b5c:	f04f 0301 	mov.w	r3, #1
 8001b60:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8001b62:	f04f 0310 	mov.w	r3, #16
 8001b66:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8001b68:	f107 0304 	add.w	r3, r7, #4
 8001b6c:	4812      	ldr	r0, [pc, #72]	; (8001bb8 <GPIO_Configuration+0x80>)
 8001b6e:	4619      	mov	r1, r3
 8001b70:	4b12      	ldr	r3, [pc, #72]	; (8001bbc <GPIO_Configuration+0x84>)
 8001b72:	4798      	blx	r3

	/* Configure PC.4 as Output push-pull */
		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8001b74:	f04f 0304 	mov.w	r3, #4
 8001b78:	80bb      	strh	r3, [r7, #4]
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8001b7a:	f04f 0301 	mov.w	r3, #1
 8001b7e:	71bb      	strb	r3, [r7, #6]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8001b80:	f04f 0310 	mov.w	r3, #16
 8001b84:	71fb      	strb	r3, [r7, #7]
		GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001b86:	f107 0304 	add.w	r3, r7, #4
 8001b8a:	480d      	ldr	r0, [pc, #52]	; (8001bc0 <GPIO_Configuration+0x88>)
 8001b8c:	4619      	mov	r1, r3
 8001b8e:	4b0b      	ldr	r3, [pc, #44]	; (8001bbc <GPIO_Configuration+0x84>)
 8001b90:	4798      	blx	r3



	/* GPIOC Configuration:TIM8 Channel3-4 in Input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;
 8001b92:	f44f 7340 	mov.w	r3, #768	; 0x300
 8001b96:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8001b98:	f04f 0304 	mov.w	r3, #4
 8001b9c:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8001b9e:	f107 0304 	add.w	r3, r7, #4
 8001ba2:	4805      	ldr	r0, [pc, #20]	; (8001bb8 <GPIO_Configuration+0x80>)
 8001ba4:	4619      	mov	r1, r3
 8001ba6:	4b05      	ldr	r3, [pc, #20]	; (8001bbc <GPIO_Configuration+0x84>)
 8001ba8:	4798      	blx	r3

}
 8001baa:	f107 0708 	add.w	r7, r7, #8
 8001bae:	46bd      	mov	sp, r7
 8001bb0:	bd80      	pop	{r7, pc}
 8001bb2:	bf00      	nop
 8001bb4:	08001529 	.word	0x08001529
 8001bb8:	40011000 	.word	0x40011000
 8001bbc:	0800109d 	.word	0x0800109d
 8001bc0:	40010c00 	.word	0x40010c00

08001bc4 <vLogicaTask>:
	while (1)
	{


		//GPIO_SetBits(GPIOC, GPIO_Pin_5);
		GPIO_SetBits(GPIOB, GPIO_Pin_2);
 8001bc4:	4809      	ldr	r0, [pc, #36]	; (8001bec <vLogicaTask+0x28>)
 8001bc6:	f04f 0104 	mov.w	r1, #4
 8001bca:	4b09      	ldr	r3, [pc, #36]	; (8001bf0 <vLogicaTask+0x2c>)
 8001bcc:	4798      	blx	r3

		/* Insert delay */
		vTaskDelay(100);
 8001bce:	f04f 0064 	mov.w	r0, #100	; 0x64
 8001bd2:	4b08      	ldr	r3, [pc, #32]	; (8001bf4 <vLogicaTask+0x30>)
 8001bd4:	4798      	blx	r3
		/* Turn off led connected to PC.5 pin */
		//GPIO_ResetBits(GPIOC, GPIO_Pin_5);
		GPIO_ResetBits(GPIOB, GPIO_Pin_2);
 8001bd6:	4805      	ldr	r0, [pc, #20]	; (8001bec <vLogicaTask+0x28>)
 8001bd8:	f04f 0104 	mov.w	r1, #4
 8001bdc:	4b06      	ldr	r3, [pc, #24]	; (8001bf8 <vLogicaTask+0x34>)
 8001bde:	4798      	blx	r3

		/* Insert delay */
		vTaskDelay(100);
 8001be0:	f04f 0064 	mov.w	r0, #100	; 0x64
 8001be4:	4b03      	ldr	r3, [pc, #12]	; (8001bf4 <vLogicaTask+0x30>)
 8001be6:	4798      	blx	r3
	}
 8001be8:	e7ec      	b.n	8001bc4 <vLogicaTask>
 8001bea:	bf00      	nop
 8001bec:	40010c00 	.word	0x40010c00
 8001bf0:	0800125d 	.word	0x0800125d
 8001bf4:	08000459 	.word	0x08000459
 8001bf8:	08001279 	.word	0x08001279
 8001bfc:	454c4449 	.word	0x454c4449
 8001c00:	00000000 	.word	0x00000000

08001c04 <heapSTRUCT_SIZE>:
 8001c04:	00000010 69676f4c 00006163              ....Logica..
