
FLASH_RUN/windcatcher.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000040a4  08000000  08000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000148  20000000  080040a4  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00004a74  20000148  080041ec  00010148  2**3
                  ALLOC
  3 ._usrstack    00000100  20004bbc  20004bbc  00010148  2**0
                  CONTENTS
  4 .comment      00000489  00000000  00000000  00010248  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00001048  00000000  00000000  000106d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00002707  00000000  00000000  00011719  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000bec2  00000000  00000000  00013e20  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002348  00000000  00000000  0001fce2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000044bc  00000000  00000000  0002202a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000033b0  00000000  00000000  000264e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00004a4d  00000000  00000000  00029898  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00005ab8  00000000  00000000  0002e2e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000f70  00000000  00000000  00033d9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .ARM.attributes 00000031  00000000  00000000  00034d0d  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08000000 <g_pfnVectorsStartup>:
 8000000:	00 c0 00 20 b5 01 00 08                             ... ....

08000008 <memset>:
 8000008:	2a03      	cmp	r2, #3
 800000a:	b2c9      	uxtb	r1, r1
 800000c:	b430      	push	{r4, r5}
 800000e:	d807      	bhi.n	8000020 <memset+0x18>
 8000010:	b122      	cbz	r2, 800001c <memset+0x14>
 8000012:	2300      	movs	r3, #0
 8000014:	54c1      	strb	r1, [r0, r3]
 8000016:	3301      	adds	r3, #1
 8000018:	4293      	cmp	r3, r2
 800001a:	d1fb      	bne.n	8000014 <memset+0xc>
 800001c:	bc30      	pop	{r4, r5}
 800001e:	4770      	bx	lr
 8000020:	eb00 0c02 	add.w	ip, r0, r2
 8000024:	4603      	mov	r3, r0
 8000026:	e001      	b.n	800002c <memset+0x24>
 8000028:	f803 1c01 	strb.w	r1, [r3, #-1]
 800002c:	f003 0403 	and.w	r4, r3, #3
 8000030:	461a      	mov	r2, r3
 8000032:	3301      	adds	r3, #1
 8000034:	2c00      	cmp	r4, #0
 8000036:	d1f7      	bne.n	8000028 <memset+0x20>
 8000038:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 800003c:	ebc2 040c 	rsb	r4, r2, ip
 8000040:	fb03 f301 	mul.w	r3, r3, r1
 8000044:	e01f      	b.n	8000086 <memset+0x7e>
 8000046:	f842 3c40 	str.w	r3, [r2, #-64]
 800004a:	f842 3c3c 	str.w	r3, [r2, #-60]
 800004e:	f842 3c38 	str.w	r3, [r2, #-56]
 8000052:	f842 3c34 	str.w	r3, [r2, #-52]
 8000056:	f842 3c30 	str.w	r3, [r2, #-48]
 800005a:	f842 3c2c 	str.w	r3, [r2, #-44]
 800005e:	f842 3c28 	str.w	r3, [r2, #-40]
 8000062:	f842 3c24 	str.w	r3, [r2, #-36]
 8000066:	f842 3c20 	str.w	r3, [r2, #-32]
 800006a:	f842 3c1c 	str.w	r3, [r2, #-28]
 800006e:	f842 3c18 	str.w	r3, [r2, #-24]
 8000072:	f842 3c14 	str.w	r3, [r2, #-20]
 8000076:	f842 3c10 	str.w	r3, [r2, #-16]
 800007a:	f842 3c0c 	str.w	r3, [r2, #-12]
 800007e:	f842 3c08 	str.w	r3, [r2, #-8]
 8000082:	f842 3c04 	str.w	r3, [r2, #-4]
 8000086:	4615      	mov	r5, r2
 8000088:	3240      	adds	r2, #64	; 0x40
 800008a:	2c3f      	cmp	r4, #63	; 0x3f
 800008c:	f1a4 0440 	sub.w	r4, r4, #64	; 0x40
 8000090:	dcd9      	bgt.n	8000046 <memset+0x3e>
 8000092:	462a      	mov	r2, r5
 8000094:	ebc5 040c 	rsb	r4, r5, ip
 8000098:	e007      	b.n	80000aa <memset+0xa2>
 800009a:	f842 3c10 	str.w	r3, [r2, #-16]
 800009e:	f842 3c0c 	str.w	r3, [r2, #-12]
 80000a2:	f842 3c08 	str.w	r3, [r2, #-8]
 80000a6:	f842 3c04 	str.w	r3, [r2, #-4]
 80000aa:	4615      	mov	r5, r2
 80000ac:	3210      	adds	r2, #16
 80000ae:	2c0f      	cmp	r4, #15
 80000b0:	f1a4 0410 	sub.w	r4, r4, #16
 80000b4:	dcf1      	bgt.n	800009a <memset+0x92>
 80000b6:	462a      	mov	r2, r5
 80000b8:	ebc5 050c 	rsb	r5, r5, ip
 80000bc:	e001      	b.n	80000c2 <memset+0xba>
 80000be:	f842 3c04 	str.w	r3, [r2, #-4]
 80000c2:	4614      	mov	r4, r2
 80000c4:	3204      	adds	r2, #4
 80000c6:	2d03      	cmp	r5, #3
 80000c8:	f1a5 0504 	sub.w	r5, r5, #4
 80000cc:	dcf7      	bgt.n	80000be <memset+0xb6>
 80000ce:	e001      	b.n	80000d4 <memset+0xcc>
 80000d0:	f804 1b01 	strb.w	r1, [r4], #1
 80000d4:	4564      	cmp	r4, ip
 80000d6:	d3fb      	bcc.n	80000d0 <memset+0xc8>
 80000d8:	e7a0      	b.n	800001c <memset+0x14>
 80000da:	bf00      	nop

080000dc <strlen>:
 80000dc:	f020 0103 	bic.w	r1, r0, #3
 80000e0:	f010 0003 	ands.w	r0, r0, #3
 80000e4:	f1c0 0000 	rsb	r0, r0, #0
 80000e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80000ec:	f100 0c04 	add.w	ip, r0, #4
 80000f0:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80000f4:	f06f 0200 	mvn.w	r2, #0
 80000f8:	bf1c      	itt	ne
 80000fa:	fa22 f20c 	lsrne.w	r2, r2, ip
 80000fe:	4313      	orrne	r3, r2
 8000100:	f04f 0c01 	mov.w	ip, #1
 8000104:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 8000108:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 800010c:	eba3 020c 	sub.w	r2, r3, ip
 8000110:	ea22 0203 	bic.w	r2, r2, r3
 8000114:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8000118:	bf04      	itt	eq
 800011a:	f851 3b04 	ldreq.w	r3, [r1], #4
 800011e:	3004      	addeq	r0, #4
 8000120:	d0f4      	beq.n	800010c <strlen+0x30>
 8000122:	f013 0fff 	tst.w	r3, #255	; 0xff
 8000126:	bf1f      	itttt	ne
 8000128:	3001      	addne	r0, #1
 800012a:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 800012e:	3001      	addne	r0, #1
 8000130:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 8000134:	bf18      	it	ne
 8000136:	3001      	addne	r0, #1
 8000138:	4770      	bx	lr
 800013a:	bf00      	nop

0800013c <strncpy>:
 800013c:	ea41 0300 	orr.w	r3, r1, r0
 8000140:	f013 0f03 	tst.w	r3, #3
 8000144:	bf14      	ite	ne
 8000146:	2300      	movne	r3, #0
 8000148:	2301      	moveq	r3, #1
 800014a:	2a03      	cmp	r2, #3
 800014c:	bf94      	ite	ls
 800014e:	2300      	movls	r3, #0
 8000150:	f003 0301 	andhi.w	r3, r3, #1
 8000154:	b430      	push	{r4, r5}
 8000156:	2b00      	cmp	r3, #0
 8000158:	d02a      	beq.n	80001b0 <strncpy+0x74>
 800015a:	4604      	mov	r4, r0
 800015c:	680b      	ldr	r3, [r1, #0]
 800015e:	f1a3 3c01 	sub.w	ip, r3, #16843009	; 0x1010101
 8000162:	ea2c 0c03 	bic.w	ip, ip, r3
 8000166:	f01c 3f80 	tst.w	ip, #2155905152	; 0x80808080
 800016a:	d105      	bne.n	8000178 <strncpy+0x3c>
 800016c:	3a04      	subs	r2, #4
 800016e:	3104      	adds	r1, #4
 8000170:	2a03      	cmp	r2, #3
 8000172:	f844 3b04 	str.w	r3, [r4], #4
 8000176:	d8f1      	bhi.n	800015c <strncpy+0x20>
 8000178:	4623      	mov	r3, r4
 800017a:	b1ba      	cbz	r2, 80001ac <strncpy+0x70>
 800017c:	780d      	ldrb	r5, [r1, #0]
 800017e:	461c      	mov	r4, r3
 8000180:	3a01      	subs	r2, #1
 8000182:	f804 5b01 	strb.w	r5, [r4], #1
 8000186:	b155      	cbz	r5, 800019e <strncpy+0x62>
 8000188:	3302      	adds	r3, #2
 800018a:	b17a      	cbz	r2, 80001ac <strncpy+0x70>
 800018c:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8000190:	461c      	mov	r4, r3
 8000192:	3a01      	subs	r2, #1
 8000194:	f803 5c01 	strb.w	r5, [r3, #-1]
 8000198:	3301      	adds	r3, #1
 800019a:	2d00      	cmp	r5, #0
 800019c:	d1f5      	bne.n	800018a <strncpy+0x4e>
 800019e:	b12a      	cbz	r2, 80001ac <strncpy+0x70>
 80001a0:	2300      	movs	r3, #0
 80001a2:	4619      	mov	r1, r3
 80001a4:	54e1      	strb	r1, [r4, r3]
 80001a6:	3301      	adds	r3, #1
 80001a8:	4293      	cmp	r3, r2
 80001aa:	d1fb      	bne.n	80001a4 <strncpy+0x68>
 80001ac:	bc30      	pop	{r4, r5}
 80001ae:	4770      	bx	lr
 80001b0:	4603      	mov	r3, r0
 80001b2:	e7e2      	b.n	800017a <strncpy+0x3e>

080001b4 <Reset_Handler>:
 * @param  None
 * @retval : None
*/

void Reset_Handler(void)
{
 80001b4:	4668      	mov	r0, sp
 80001b6:	f020 0107 	bic.w	r1, r0, #7
 80001ba:	468d      	mov	sp, r1
 80001bc:	b581      	push	{r0, r7, lr}
 80001be:	b083      	sub	sp, #12
 80001c0:	af00      	add	r7, sp, #0

#ifdef STARTUP_DELAY
  volatile unsigned long i;
  for (i=0;i<500000;i++) { ; }
 80001c2:	f04f 0300 	mov.w	r3, #0
 80001c6:	607b      	str	r3, [r7, #4]
 80001c8:	e003      	b.n	80001d2 <Reset_Handler+0x1e>
 80001ca:	687b      	ldr	r3, [r7, #4]
 80001cc:	f103 0301 	add.w	r3, r3, #1
 80001d0:	607b      	str	r3, [r7, #4]
 80001d2:	687a      	ldr	r2, [r7, #4]
 80001d4:	f24a 131f 	movw	r3, #41247	; 0xa11f
 80001d8:	f2c0 0307 	movt	r3, #7
 80001dc:	429a      	cmp	r2, r3
 80001de:	d9f4      	bls.n	80001ca <Reset_Handler+0x16>
#endif

  /* Initialize data and bss */
  __Init_Data();
 80001e0:	f240 13f9 	movw	r3, #505	; 0x1f9
 80001e4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80001e8:	4798      	blx	r3

  /* Call the application's entry point.*/
  main();
 80001ea:	f643 23b5 	movw	r3, #15029	; 0x3ab5
 80001ee:	f6c0 0300 	movt	r3, #2048	; 0x800
 80001f2:	4798      	blx	r3

  while(1) { ; }
 80001f4:	e7fe      	b.n	80001f4 <Reset_Handler+0x40>
 80001f6:	bf00      	nop

080001f8 <__Init_Data>:
 * @param  None
 * @retval : None
*/

void __Init_Data(void)
{
 80001f8:	b480      	push	{r7}
 80001fa:	b083      	sub	sp, #12
 80001fc:	af00      	add	r7, sp, #0
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc  = &_sidata;
 80001fe:	f244 03a4 	movw	r3, #16548	; 0x40a4
 8000202:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000206:	603b      	str	r3, [r7, #0]
  pulDest = &_sdata;
 8000208:	f240 0300 	movw	r3, #0
 800020c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000210:	607b      	str	r3, [r7, #4]
  if ( pulSrc != pulDest )
 8000212:	683a      	ldr	r2, [r7, #0]
 8000214:	687b      	ldr	r3, [r7, #4]
 8000216:	429a      	cmp	r2, r3
 8000218:	d013      	beq.n	8000242 <__Init_Data+0x4a>
  {
    for(; pulDest < &_edata; )
 800021a:	e00b      	b.n	8000234 <__Init_Data+0x3c>
    {
      *(pulDest++) = *(pulSrc++);
 800021c:	683b      	ldr	r3, [r7, #0]
 800021e:	681a      	ldr	r2, [r3, #0]
 8000220:	687b      	ldr	r3, [r7, #4]
 8000222:	601a      	str	r2, [r3, #0]
 8000224:	687b      	ldr	r3, [r7, #4]
 8000226:	f103 0304 	add.w	r3, r3, #4
 800022a:	607b      	str	r3, [r7, #4]
 800022c:	683b      	ldr	r3, [r7, #0]
 800022e:	f103 0304 	add.w	r3, r3, #4
 8000232:	603b      	str	r3, [r7, #0]
  /* Copy the data segment initializers from flash to SRAM */
  pulSrc  = &_sidata;
  pulDest = &_sdata;
  if ( pulSrc != pulDest )
  {
    for(; pulDest < &_edata; )
 8000234:	687a      	ldr	r2, [r7, #4]
 8000236:	f240 1348 	movw	r3, #328	; 0x148
 800023a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800023e:	429a      	cmp	r2, r3
 8000240:	d3ec      	bcc.n	800021c <__Init_Data+0x24>
    {
      *(pulDest++) = *(pulSrc++);
    }
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 8000242:	f240 1348 	movw	r3, #328	; 0x148
 8000246:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800024a:	607b      	str	r3, [r7, #4]
 800024c:	e007      	b.n	800025e <__Init_Data+0x66>
  {
    *(pulDest++) = 0;
 800024e:	687b      	ldr	r3, [r7, #4]
 8000250:	f04f 0200 	mov.w	r2, #0
 8000254:	601a      	str	r2, [r3, #0]
 8000256:	687b      	ldr	r3, [r7, #4]
 8000258:	f103 0304 	add.w	r3, r3, #4
 800025c:	607b      	str	r3, [r7, #4]
    {
      *(pulDest++) = *(pulSrc++);
    }
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 800025e:	687a      	ldr	r2, [r7, #4]
 8000260:	f644 33bc 	movw	r3, #19388	; 0x4bbc
 8000264:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000268:	429a      	cmp	r2, r3
 800026a:	d3f0      	bcc.n	800024e <__Init_Data+0x56>
  {
    *(pulDest++) = 0;
  }
}
 800026c:	f107 070c 	add.w	r7, r7, #12
 8000270:	46bd      	mov	sp, r7
 8000272:	bc80      	pop	{r7}
 8000274:	4770      	bx	lr
 8000276:	bf00      	nop

08000278 <Default_Handler>:
 * @param  None
 * @retval : None
*/

void Default_Handler(void)
{
 8000278:	b480      	push	{r7}
 800027a:	af00      	add	r7, sp, #0
  /* Go into an infinite loop. */
  while (1)
  {
  }
 800027c:	e7fe      	b.n	800027c <Default_Handler+0x4>
 800027e:	bf00      	nop

08000280 <RCC_Configuration>:
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void RCC_Configuration(void)
{
 8000280:	b580      	push	{r7, lr}
 8000282:	af00      	add	r7, sp, #0
	/* RCC system reset(for debug purpose) */
	RCC_DeInit();
 8000284:	f641 4369 	movw	r3, #7273	; 0x1c69
 8000288:	f6c0 0300 	movt	r3, #2048	; 0x800
 800028c:	4798      	blx	r3

	/* Enable HSE */
	RCC_HSEConfig(RCC_HSE_ON);
 800028e:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8000292:	f641 5305 	movw	r3, #7429	; 0x1d05
 8000296:	f6c0 0300 	movt	r3, #2048	; 0x800
 800029a:	4798      	blx	r3

	/* Wait till HSE is ready */
	HSEStartUpStatus = RCC_WaitForHSEStartUp();
 800029c:	f641 5389 	movw	r3, #7561	; 0x1d89
 80002a0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80002a4:	4798      	blx	r3
 80002a6:	4603      	mov	r3, r0
 80002a8:	461a      	mov	r2, r3
 80002aa:	f642 23d8 	movw	r3, #10968	; 0x2ad8
 80002ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80002b2:	701a      	strb	r2, [r3, #0]

	if (HSEStartUpStatus == SUCCESS)
 80002b4:	f642 23d8 	movw	r3, #10968	; 0x2ad8
 80002b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80002bc:	781b      	ldrb	r3, [r3, #0]
 80002be:	2b01      	cmp	r3, #1
 80002c0:	d14b      	bne.n	800035a <RCC_Configuration+0xda>
	{
		/* Enable Prefetch Buffer */
		FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 80002c2:	f04f 0010 	mov.w	r0, #16
 80002c6:	f641 232d 	movw	r3, #6701	; 0x1a2d
 80002ca:	f6c0 0300 	movt	r3, #2048	; 0x800
 80002ce:	4798      	blx	r3

		/* Flash 2 wait state */
		FLASH_SetLatency(FLASH_Latency_2);
 80002d0:	f04f 0002 	mov.w	r0, #2
 80002d4:	f641 13e9 	movw	r3, #6633	; 0x19e9
 80002d8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80002dc:	4798      	blx	r3

		/* HCLK = SYSCLK */
		RCC_HCLKConfig(RCC_SYSCLK_Div1);
 80002de:	f04f 0000 	mov.w	r0, #0
 80002e2:	f641 63c5 	movw	r3, #7877	; 0x1ec5
 80002e6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80002ea:	4798      	blx	r3

		/* PCLK2 = HCLK */
		RCC_PCLK2Config(RCC_HCLK_Div1);
 80002ec:	f04f 0000 	mov.w	r0, #0
 80002f0:	f641 734d 	movw	r3, #8013	; 0x1f4d
 80002f4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80002f8:	4798      	blx	r3

		/* PCLK1 = HCLK/2 */
		RCC_PCLK1Config(RCC_HCLK_Div2);
 80002fa:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80002fe:	f641 7309 	movw	r3, #7945	; 0x1f09
 8000302:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000306:	4798      	blx	r3

		/* PLLCLK = 8MHz * 9 = 72 MHz */
		RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
 8000308:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800030c:	f44f 11e0 	mov.w	r1, #1835008	; 0x1c0000
 8000310:	f641 53f9 	movw	r3, #7673	; 0x1df9
 8000314:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000318:	4798      	blx	r3

		/* Enable PLL */
		RCC_PLLCmd(ENABLE);
 800031a:	f04f 0001 	mov.w	r0, #1
 800031e:	f641 6345 	movw	r3, #7749	; 0x1e45
 8000322:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000326:	4798      	blx	r3

		/* Wait till PLL is ready */
		while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
 8000328:	f04f 0039 	mov.w	r0, #57	; 0x39
 800032c:	f242 2351 	movw	r3, #8785	; 0x2251
 8000330:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000334:	4798      	blx	r3
 8000336:	4603      	mov	r3, r0
 8000338:	2b00      	cmp	r3, #0
 800033a:	d0f5      	beq.n	8000328 <RCC_Configuration+0xa8>
		{
		}

		/* Select PLL as system clock source */
		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 800033c:	f04f 0002 	mov.w	r0, #2
 8000340:	f641 6365 	movw	r3, #7781	; 0x1e65
 8000344:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000348:	4798      	blx	r3

		/* Wait till PLL is used as system clock source */
		while (RCC_GetSYSCLKSource() != 0x08)
 800034a:	f641 63a9 	movw	r3, #7849	; 0x1ea9
 800034e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000352:	4798      	blx	r3
 8000354:	4603      	mov	r3, r0
 8000356:	2b08      	cmp	r3, #8
 8000358:	d1f7      	bne.n	800034a <RCC_Configuration+0xca>
		{
		}
	}
}
 800035a:	bd80      	pop	{r7, pc}

0800035c <NVIC_Configuration>:
 *******************************************************************************/
#ifdef VECT_TAB_RAM
/* vector-offset (TBLOFF) from bottom of SRAM. defined in linker script */
extern uint32_t _isr_vectorsram_offs;
void NVIC_Configuration(void)
{
 800035c:	b580      	push	{r7, lr}
 800035e:	af00      	add	r7, sp, #0
	/* Set the Vector Table base location at 0x20000000+_isr_vectorsram_offs */
	NVIC_SetVectorTable(NVIC_VectTab_RAM, (uint32_t) &_isr_vectorsram_offs);
 8000360:	f240 0300 	movw	r3, #0
 8000364:	f2c0 0300 	movt	r3, #0
 8000368:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 800036c:	4619      	mov	r1, r3
 800036e:	f642 5371 	movw	r3, #11633	; 0x2d71
 8000372:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000376:	4798      	blx	r3
}
 8000378:	bd80      	pop	{r7, pc}
 800037a:	bf00      	nop

0800037c <hwInit>:
}
#endif


void hwInit()
{
 800037c:	b580      	push	{r7, lr}
 800037e:	af00      	add	r7, sp, #0
	/* System Clocks Configuration */
	RCC_Configuration();
 8000380:	f240 2381 	movw	r3, #641	; 0x281
 8000384:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000388:	4798      	blx	r3

	/* NVIC configuration */
	NVIC_Configuration();
 800038a:	f240 335d 	movw	r3, #861	; 0x35d
 800038e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000392:	4798      	blx	r3


}
 8000394:	bd80      	pop	{r7, pc}
 8000396:	bf00      	nop

08000398 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 8000398:	b580      	push	{r7, lr}
 800039a:	b08a      	sub	sp, #40	; 0x28
 800039c:	af02      	add	r7, sp, #8
 800039e:	60f8      	str	r0, [r7, #12]
 80003a0:	60b9      	str	r1, [r7, #8]
 80003a2:	603b      	str	r3, [r7, #0]
 80003a4:	4613      	mov	r3, r2
 80003a6:	80fb      	strh	r3, [r7, #6]
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 80003a8:	88fb      	ldrh	r3, [r7, #6]
 80003aa:	4618      	mov	r0, r3
 80003ac:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80003ae:	f640 5309 	movw	r3, #3337	; 0xd09
 80003b2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80003b6:	4798      	blx	r3
 80003b8:	4603      	mov	r3, r0
 80003ba:	61bb      	str	r3, [r7, #24]

	if( pxNewTCB != NULL )
 80003bc:	69bb      	ldr	r3, [r7, #24]
 80003be:	2b00      	cmp	r3, #0
 80003c0:	f000 80ab 	beq.w	800051a <xTaskGenericCreate+0x182>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 80003c4:	69bb      	ldr	r3, [r7, #24]
 80003c6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80003c8:	88fb      	ldrh	r3, [r7, #6]
 80003ca:	f103 33ff 	add.w	r3, r3, #4294967295
 80003ce:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80003d2:	4413      	add	r3, r2
 80003d4:	61fb      	str	r3, [r7, #28]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
 80003d6:	69fb      	ldr	r3, [r7, #28]
 80003d8:	f023 0307 	bic.w	r3, r3, #7
 80003dc:	61fb      	str	r3, [r7, #28]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 80003de:	88fb      	ldrh	r3, [r7, #6]
 80003e0:	9300      	str	r3, [sp, #0]
 80003e2:	69b8      	ldr	r0, [r7, #24]
 80003e4:	68b9      	ldr	r1, [r7, #8]
 80003e6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80003e8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80003ea:	f640 2ce5 	movw	ip, #2789	; 0xae5
 80003ee:	f6c0 0c00 	movt	ip, #2048	; 0x800
 80003f2:	47e0      	blx	ip
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80003f4:	69f8      	ldr	r0, [r7, #28]
 80003f6:	68f9      	ldr	r1, [r7, #12]
 80003f8:	683a      	ldr	r2, [r7, #0]
 80003fa:	f640 7335 	movw	r3, #3893	; 0xf35
 80003fe:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000402:	4798      	blx	r3
 8000404:	4603      	mov	r3, r0
 8000406:	461a      	mov	r2, r3
 8000408:	69bb      	ldr	r3, [r7, #24]
 800040a:	601a      	str	r2, [r3, #0]
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
 800040c:	f241 033d 	movw	r3, #4157	; 0x103d
 8000410:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000414:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
 8000416:	f240 2384 	movw	r3, #644	; 0x284
 800041a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800041e:	681b      	ldr	r3, [r3, #0]
 8000420:	f103 0201 	add.w	r2, r3, #1
 8000424:	f240 2384 	movw	r3, #644	; 0x284
 8000428:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800042c:	601a      	str	r2, [r3, #0]
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 800042e:	f240 2384 	movw	r3, #644	; 0x284
 8000432:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000436:	681b      	ldr	r3, [r3, #0]
 8000438:	2b01      	cmp	r3, #1
 800043a:	d10b      	bne.n	8000454 <xTaskGenericCreate+0xbc>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 800043c:	f240 1348 	movw	r3, #328	; 0x148
 8000440:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000444:	69ba      	ldr	r2, [r7, #24]
 8000446:	601a      	str	r2, [r3, #0]

				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 8000448:	f640 3375 	movw	r3, #2933	; 0xb75
 800044c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000450:	4798      	blx	r3
 8000452:	e015      	b.n	8000480 <xTaskGenericCreate+0xe8>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8000454:	f240 2394 	movw	r3, #660	; 0x294
 8000458:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800045c:	681b      	ldr	r3, [r3, #0]
 800045e:	2b00      	cmp	r3, #0
 8000460:	d10e      	bne.n	8000480 <xTaskGenericCreate+0xe8>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8000462:	f240 1348 	movw	r3, #328	; 0x148
 8000466:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800046a:	681b      	ldr	r3, [r3, #0]
 800046c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800046e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000470:	429a      	cmp	r2, r3
 8000472:	d805      	bhi.n	8000480 <xTaskGenericCreate+0xe8>
					{
						pxCurrentTCB = pxNewTCB;
 8000474:	f240 1348 	movw	r3, #328	; 0x148
 8000478:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800047c:	69ba      	ldr	r2, [r7, #24]
 800047e:	601a      	str	r2, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8000480:	69bb      	ldr	r3, [r7, #24]
 8000482:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000484:	f240 238c 	movw	r3, #652	; 0x28c
 8000488:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800048c:	681b      	ldr	r3, [r3, #0]
 800048e:	429a      	cmp	r2, r3
 8000490:	d906      	bls.n	80004a0 <xTaskGenericCreate+0x108>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 8000492:	69bb      	ldr	r3, [r7, #24]
 8000494:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000496:	f240 238c 	movw	r3, #652	; 0x28c
 800049a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800049e:	601a      	str	r2, [r3, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 80004a0:	f240 23a8 	movw	r3, #680	; 0x2a8
 80004a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004a8:	681b      	ldr	r3, [r3, #0]
 80004aa:	f103 0201 	add.w	r2, r3, #1
 80004ae:	f240 23a8 	movw	r3, #680	; 0x2a8
 80004b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004b6:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 80004b8:	69bb      	ldr	r3, [r7, #24]
 80004ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80004bc:	f240 2390 	movw	r3, #656	; 0x290
 80004c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004c4:	681b      	ldr	r3, [r3, #0]
 80004c6:	429a      	cmp	r2, r3
 80004c8:	d906      	bls.n	80004d8 <xTaskGenericCreate+0x140>
 80004ca:	69bb      	ldr	r3, [r7, #24]
 80004cc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80004ce:	f240 2390 	movw	r3, #656	; 0x290
 80004d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004d6:	601a      	str	r2, [r3, #0]
 80004d8:	69bb      	ldr	r3, [r7, #24]
 80004da:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80004dc:	4613      	mov	r3, r2
 80004de:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80004e2:	4413      	add	r3, r2
 80004e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80004e8:	461a      	mov	r2, r3
 80004ea:	f240 134c 	movw	r3, #332	; 0x14c
 80004ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004f2:	441a      	add	r2, r3
 80004f4:	69bb      	ldr	r3, [r7, #24]
 80004f6:	f103 0304 	add.w	r3, r3, #4
 80004fa:	4610      	mov	r0, r2
 80004fc:	4619      	mov	r1, r3
 80004fe:	f640 631d 	movw	r3, #3613	; 0xe1d
 8000502:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000506:	4798      	blx	r3

			xReturn = pdPASS;
 8000508:	f04f 0301 	mov.w	r3, #1
 800050c:	617b      	str	r3, [r7, #20]
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
 800050e:	f241 0369 	movw	r3, #4201	; 0x1069
 8000512:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000516:	4798      	blx	r3
 8000518:	e002      	b.n	8000520 <xTaskGenericCreate+0x188>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800051a:	f04f 33ff 	mov.w	r3, #4294967295
 800051e:	617b      	str	r3, [r7, #20]
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
 8000520:	697b      	ldr	r3, [r7, #20]
 8000522:	2b01      	cmp	r3, #1
 8000524:	d11a      	bne.n	800055c <xTaskGenericCreate+0x1c4>
	{
		if( ( void * ) pxCreatedTask != NULL )
 8000526:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000528:	2b00      	cmp	r3, #0
 800052a:	d002      	beq.n	8000532 <xTaskGenericCreate+0x19a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 800052c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800052e:	69ba      	ldr	r2, [r7, #24]
 8000530:	601a      	str	r2, [r3, #0]
		}

		if( xSchedulerRunning != pdFALSE )
 8000532:	f240 2394 	movw	r3, #660	; 0x294
 8000536:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800053a:	681b      	ldr	r3, [r3, #0]
 800053c:	2b00      	cmp	r3, #0
 800053e:	d00d      	beq.n	800055c <xTaskGenericCreate+0x1c4>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 8000540:	f240 1348 	movw	r3, #328	; 0x148
 8000544:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000548:	681b      	ldr	r3, [r3, #0]
 800054a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800054c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800054e:	429a      	cmp	r2, r3
 8000550:	d204      	bcs.n	800055c <xTaskGenericCreate+0x1c4>
			{
				portYIELD_WITHIN_API();
 8000552:	f241 0325 	movw	r3, #4133	; 0x1025
 8000556:	f6c0 0300 	movt	r3, #2048	; 0x800
 800055a:	4798      	blx	r3
			}
		}
	}

	return xReturn;
 800055c:	697b      	ldr	r3, [r7, #20]
}
 800055e:	4618      	mov	r0, r3
 8000560:	f107 0720 	add.w	r7, r7, #32
 8000564:	46bd      	mov	sp, r7
 8000566:	bd80      	pop	{r7, pc}

08000568 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8000568:	b580      	push	{r7, lr}
 800056a:	b084      	sub	sp, #16
 800056c:	af00      	add	r7, sp, #0
 800056e:	6078      	str	r0, [r7, #4]
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8000570:	f04f 0300 	mov.w	r3, #0
 8000574:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
 8000576:	687b      	ldr	r3, [r7, #4]
 8000578:	2b00      	cmp	r3, #0
 800057a:	d056      	beq.n	800062a <vTaskDelay+0xc2>
		{
			vTaskSuspendAll();
 800057c:	f240 63c9 	movw	r3, #1737	; 0x6c9
 8000580:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000584:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8000586:	f240 2388 	movw	r3, #648	; 0x288
 800058a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800058e:	681a      	ldr	r2, [r3, #0]
 8000590:	687b      	ldr	r3, [r7, #4]
 8000592:	4413      	add	r3, r2
 8000594:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8000596:	f240 1348 	movw	r3, #328	; 0x148
 800059a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800059e:	681b      	ldr	r3, [r3, #0]
 80005a0:	f103 0304 	add.w	r3, r3, #4
 80005a4:	4618      	mov	r0, r3
 80005a6:	f640 63e1 	movw	r3, #3809	; 0xee1
 80005aa:	f6c0 0300 	movt	r3, #2048	; 0x800
 80005ae:	4798      	blx	r3

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80005b0:	f240 1348 	movw	r3, #328	; 0x148
 80005b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005b8:	681b      	ldr	r3, [r3, #0]
 80005ba:	68ba      	ldr	r2, [r7, #8]
 80005bc:	605a      	str	r2, [r3, #4]

				if( xTimeToWake < xTickCount )
 80005be:	f240 2388 	movw	r3, #648	; 0x288
 80005c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005c6:	681b      	ldr	r3, [r3, #0]
 80005c8:	68ba      	ldr	r2, [r7, #8]
 80005ca:	429a      	cmp	r2, r3
 80005cc:	d213      	bcs.n	80005f6 <vTaskDelay+0x8e>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 80005ce:	f240 2340 	movw	r3, #576	; 0x240
 80005d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005d6:	681a      	ldr	r2, [r3, #0]
 80005d8:	f240 1348 	movw	r3, #328	; 0x148
 80005dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005e0:	681b      	ldr	r3, [r3, #0]
 80005e2:	f103 0304 	add.w	r3, r3, #4
 80005e6:	4610      	mov	r0, r2
 80005e8:	4619      	mov	r1, r3
 80005ea:	f640 636d 	movw	r3, #3693	; 0xe6d
 80005ee:	f6c0 0300 	movt	r3, #2048	; 0x800
 80005f2:	4798      	blx	r3
 80005f4:	e012      	b.n	800061c <vTaskDelay+0xb4>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 80005f6:	f240 233c 	movw	r3, #572	; 0x23c
 80005fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005fe:	681a      	ldr	r2, [r3, #0]
 8000600:	f240 1348 	movw	r3, #328	; 0x148
 8000604:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000608:	681b      	ldr	r3, [r3, #0]
 800060a:	f103 0304 	add.w	r3, r3, #4
 800060e:	4610      	mov	r0, r2
 8000610:	4619      	mov	r1, r3
 8000612:	f640 636d 	movw	r3, #3693	; 0xe6d
 8000616:	f6c0 0300 	movt	r3, #2048	; 0x800
 800061a:	4798      	blx	r3
				}
			}
			xAlreadyYielded = xTaskResumeAll();
 800061c:	f240 63ed 	movw	r3, #1773	; 0x6ed
 8000620:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000624:	4798      	blx	r3
 8000626:	4603      	mov	r3, r0
 8000628:	60fb      	str	r3, [r7, #12]
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 800062a:	68fb      	ldr	r3, [r7, #12]
 800062c:	2b00      	cmp	r3, #0
 800062e:	d104      	bne.n	800063a <vTaskDelay+0xd2>
		{
			portYIELD_WITHIN_API();
 8000630:	f241 0325 	movw	r3, #4133	; 0x1025
 8000634:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000638:	4798      	blx	r3
		}
	}
 800063a:	f107 0710 	add.w	r7, r7, #16
 800063e:	46bd      	mov	sp, r7
 8000640:	bd80      	pop	{r7, pc}
 8000642:	bf00      	nop

08000644 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 8000644:	b580      	push	{r7, lr}
 8000646:	b086      	sub	sp, #24
 8000648:	af04      	add	r7, sp, #16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 800064a:	f244 0374 	movw	r3, #16500	; 0x4074
 800064e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000652:	f04f 0200 	mov.w	r2, #0
 8000656:	9200      	str	r2, [sp, #0]
 8000658:	f04f 0200 	mov.w	r2, #0
 800065c:	9201      	str	r2, [sp, #4]
 800065e:	f04f 0200 	mov.w	r2, #0
 8000662:	9202      	str	r2, [sp, #8]
 8000664:	f04f 0200 	mov.w	r2, #0
 8000668:	9203      	str	r2, [sp, #12]
 800066a:	f640 20b5 	movw	r0, #2741	; 0xab5
 800066e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000672:	4619      	mov	r1, r3
 8000674:	f04f 0280 	mov.w	r2, #128	; 0x80
 8000678:	f04f 0300 	mov.w	r3, #0
 800067c:	f240 3c99 	movw	ip, #921	; 0x399
 8000680:	f6c0 0c00 	movt	ip, #2048	; 0x800
 8000684:	47e0      	blx	ip
 8000686:	4603      	mov	r3, r0
 8000688:	607b      	str	r3, [r7, #4]

	if( xReturn == pdPASS )
 800068a:	687b      	ldr	r3, [r7, #4]
 800068c:	2b01      	cmp	r3, #1
 800068e:	d116      	bne.n	80006be <vTaskStartScheduler+0x7a>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 8000690:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8000694:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 8000698:	f240 2394 	movw	r3, #660	; 0x294
 800069c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006a0:	f04f 0201 	mov.w	r2, #1
 80006a4:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0;
 80006a6:	f240 2388 	movw	r3, #648	; 0x288
 80006aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006ae:	f04f 0200 	mov.w	r2, #0
 80006b2:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
 80006b4:	f640 73c5 	movw	r3, #4037	; 0xfc5
 80006b8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80006bc:	4798      	blx	r3
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
 80006be:	f107 0708 	add.w	r7, r7, #8
 80006c2:	46bd      	mov	sp, r7
 80006c4:	bd80      	pop	{r7, pc}
 80006c6:	bf00      	nop

080006c8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 80006c8:	b480      	push	{r7}
 80006ca:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 80006cc:	f240 2398 	movw	r3, #664	; 0x298
 80006d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006d4:	681b      	ldr	r3, [r3, #0]
 80006d6:	f103 0201 	add.w	r2, r3, #1
 80006da:	f240 2398 	movw	r3, #664	; 0x298
 80006de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80006e2:	601a      	str	r2, [r3, #0]
}
 80006e4:	46bd      	mov	sp, r7
 80006e6:	bc80      	pop	{r7}
 80006e8:	4770      	bx	lr
 80006ea:	bf00      	nop

080006ec <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 80006ec:	b590      	push	{r4, r7, lr}
 80006ee:	b083      	sub	sp, #12
 80006f0:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80006f2:	f04f 0300 	mov.w	r3, #0
 80006f6:	603b      	str	r3, [r7, #0]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
 80006f8:	f241 033d 	movw	r3, #4157	; 0x103d
 80006fc:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000700:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
 8000702:	f240 2398 	movw	r3, #664	; 0x298
 8000706:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800070a:	681b      	ldr	r3, [r3, #0]
 800070c:	f103 32ff 	add.w	r2, r3, #4294967295
 8000710:	f240 2398 	movw	r3, #664	; 0x298
 8000714:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000718:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800071a:	f240 2398 	movw	r3, #664	; 0x298
 800071e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000722:	681b      	ldr	r3, [r3, #0]
 8000724:	2b00      	cmp	r3, #0
 8000726:	f040 809b 	bne.w	8000860 <xTaskResumeAll+0x174>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 800072a:	f240 2384 	movw	r3, #644	; 0x284
 800072e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000732:	681b      	ldr	r3, [r3, #0]
 8000734:	2b00      	cmp	r3, #0
 8000736:	f000 8093 	beq.w	8000860 <xTaskResumeAll+0x174>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 800073a:	f04f 0300 	mov.w	r3, #0
 800073e:	607b      	str	r3, [r7, #4]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 8000740:	e03f      	b.n	80007c2 <xTaskResumeAll+0xd6>
				{
					vListRemove( &( pxTCB->xEventListItem ) );
 8000742:	f104 0318 	add.w	r3, r4, #24
 8000746:	4618      	mov	r0, r3
 8000748:	f640 63e1 	movw	r3, #3809	; 0xee1
 800074c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000750:	4798      	blx	r3
					vListRemove( &( pxTCB->xGenericListItem ) );
 8000752:	f104 0304 	add.w	r3, r4, #4
 8000756:	4618      	mov	r0, r3
 8000758:	f640 63e1 	movw	r3, #3809	; 0xee1
 800075c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000760:	4798      	blx	r3
					prvAddTaskToReadyQueue( pxTCB );
 8000762:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000764:	f240 2390 	movw	r3, #656	; 0x290
 8000768:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800076c:	681b      	ldr	r3, [r3, #0]
 800076e:	429a      	cmp	r2, r3
 8000770:	d905      	bls.n	800077e <xTaskResumeAll+0x92>
 8000772:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000774:	f240 2390 	movw	r3, #656	; 0x290
 8000778:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800077c:	601a      	str	r2, [r3, #0]
 800077e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000780:	4613      	mov	r3, r2
 8000782:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000786:	4413      	add	r3, r2
 8000788:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800078c:	461a      	mov	r2, r3
 800078e:	f240 134c 	movw	r3, #332	; 0x14c
 8000792:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000796:	441a      	add	r2, r3
 8000798:	f104 0304 	add.w	r3, r4, #4
 800079c:	4610      	mov	r0, r2
 800079e:	4619      	mov	r1, r3
 80007a0:	f640 631d 	movw	r3, #3613	; 0xe1d
 80007a4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80007a8:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80007aa:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80007ac:	f240 1348 	movw	r3, #328	; 0x148
 80007b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007b4:	681b      	ldr	r3, [r3, #0]
 80007b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80007b8:	429a      	cmp	r2, r3
 80007ba:	d302      	bcc.n	80007c2 <xTaskResumeAll+0xd6>
					{
						xYieldRequired = pdTRUE;
 80007bc:	f04f 0301 	mov.w	r3, #1
 80007c0:	607b      	str	r3, [r7, #4]
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 80007c2:	f240 2344 	movw	r3, #580	; 0x244
 80007c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007ca:	681b      	ldr	r3, [r3, #0]
 80007cc:	2b00      	cmp	r3, #0
 80007ce:	d006      	beq.n	80007de <xTaskResumeAll+0xf2>
 80007d0:	f240 2344 	movw	r3, #580	; 0x244
 80007d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007d8:	68db      	ldr	r3, [r3, #12]
 80007da:	68db      	ldr	r3, [r3, #12]
 80007dc:	e001      	b.n	80007e2 <xTaskResumeAll+0xf6>
 80007de:	f04f 0300 	mov.w	r3, #0
 80007e2:	461c      	mov	r4, r3
 80007e4:	2c00      	cmp	r4, #0
 80007e6:	d1ac      	bne.n	8000742 <xTaskResumeAll+0x56>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 80007e8:	f240 239c 	movw	r3, #668	; 0x29c
 80007ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007f0:	681b      	ldr	r3, [r3, #0]
 80007f2:	2b00      	cmp	r3, #0
 80007f4:	d01b      	beq.n	800082e <xTaskResumeAll+0x142>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 80007f6:	e010      	b.n	800081a <xTaskResumeAll+0x12e>
					{
						vTaskIncrementTick();
 80007f8:	f640 0379 	movw	r3, #2169	; 0x879
 80007fc:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000800:	4798      	blx	r3
						--uxMissedTicks;
 8000802:	f240 239c 	movw	r3, #668	; 0x29c
 8000806:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800080a:	681b      	ldr	r3, [r3, #0]
 800080c:	f103 32ff 	add.w	r2, r3, #4294967295
 8000810:	f240 239c 	movw	r3, #668	; 0x29c
 8000814:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000818:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 800081a:	f240 239c 	movw	r3, #668	; 0x29c
 800081e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000822:	681b      	ldr	r3, [r3, #0]
 8000824:	2b00      	cmp	r3, #0
 8000826:	d1e7      	bne.n	80007f8 <xTaskResumeAll+0x10c>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 8000828:	f04f 0301 	mov.w	r3, #1
 800082c:	607b      	str	r3, [r7, #4]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 800082e:	687b      	ldr	r3, [r7, #4]
 8000830:	2b01      	cmp	r3, #1
 8000832:	d006      	beq.n	8000842 <xTaskResumeAll+0x156>
 8000834:	f240 23a0 	movw	r3, #672	; 0x2a0
 8000838:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800083c:	681b      	ldr	r3, [r3, #0]
 800083e:	2b01      	cmp	r3, #1
 8000840:	d10e      	bne.n	8000860 <xTaskResumeAll+0x174>
				{
					xAlreadyYielded = pdTRUE;
 8000842:	f04f 0301 	mov.w	r3, #1
 8000846:	603b      	str	r3, [r7, #0]
					xMissedYield = pdFALSE;
 8000848:	f240 23a0 	movw	r3, #672	; 0x2a0
 800084c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000850:	f04f 0200 	mov.w	r2, #0
 8000854:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 8000856:	f241 0325 	movw	r3, #4133	; 0x1025
 800085a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800085e:	4798      	blx	r3
				}
			}
		}
	}
	portEXIT_CRITICAL();
 8000860:	f241 0369 	movw	r3, #4201	; 0x1069
 8000864:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000868:	4798      	blx	r3

	return xAlreadyYielded;
 800086a:	683b      	ldr	r3, [r7, #0]
}
 800086c:	4618      	mov	r0, r3
 800086e:	f107 070c 	add.w	r7, r7, #12
 8000872:	46bd      	mov	sp, r7
 8000874:	bd90      	pop	{r4, r7, pc}
 8000876:	bf00      	nop

08000878 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
 8000878:	b590      	push	{r4, r7, lr}
 800087a:	b083      	sub	sp, #12
 800087c:	af00      	add	r7, sp, #0
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800087e:	f240 2398 	movw	r3, #664	; 0x298
 8000882:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000886:	681b      	ldr	r3, [r3, #0]
 8000888:	2b00      	cmp	r3, #0
 800088a:	f040 808b 	bne.w	80009a4 <vTaskIncrementTick+0x12c>
	{
		++xTickCount;
 800088e:	f240 2388 	movw	r3, #648	; 0x288
 8000892:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000896:	681b      	ldr	r3, [r3, #0]
 8000898:	f103 0201 	add.w	r2, r3, #1
 800089c:	f240 2388 	movw	r3, #648	; 0x288
 80008a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008a4:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0 )
 80008a6:	f240 2388 	movw	r3, #648	; 0x288
 80008aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008ae:	681b      	ldr	r3, [r3, #0]
 80008b0:	2b00      	cmp	r3, #0
 80008b2:	d161      	bne.n	8000978 <vTaskIncrementTick+0x100>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 80008b4:	f240 233c 	movw	r3, #572	; 0x23c
 80008b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008bc:	681b      	ldr	r3, [r3, #0]
 80008be:	607b      	str	r3, [r7, #4]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 80008c0:	f240 2340 	movw	r3, #576	; 0x240
 80008c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008c8:	681a      	ldr	r2, [r3, #0]
 80008ca:	f240 233c 	movw	r3, #572	; 0x23c
 80008ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008d2:	601a      	str	r2, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
 80008d4:	f240 2340 	movw	r3, #576	; 0x240
 80008d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008dc:	687a      	ldr	r2, [r7, #4]
 80008de:	601a      	str	r2, [r3, #0]
			xNumOfOverflows++;
 80008e0:	f240 23a4 	movw	r3, #676	; 0x2a4
 80008e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008e8:	681b      	ldr	r3, [r3, #0]
 80008ea:	f103 0201 	add.w	r2, r3, #1
 80008ee:	f240 23a4 	movw	r3, #676	; 0x2a4
 80008f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80008f6:	601a      	str	r2, [r3, #0]
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 80008f8:	e03e      	b.n	8000978 <vTaskIncrementTick+0x100>
 80008fa:	6862      	ldr	r2, [r4, #4]
 80008fc:	f240 2388 	movw	r3, #648	; 0x288
 8000900:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000904:	681b      	ldr	r3, [r3, #0]
 8000906:	429a      	cmp	r2, r3
 8000908:	d85d      	bhi.n	80009c6 <vTaskIncrementTick+0x14e>
 800090a:	f104 0304 	add.w	r3, r4, #4
 800090e:	4618      	mov	r0, r3
 8000910:	f640 63e1 	movw	r3, #3809	; 0xee1
 8000914:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000918:	4798      	blx	r3
 800091a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800091c:	2b00      	cmp	r3, #0
 800091e:	d007      	beq.n	8000930 <vTaskIncrementTick+0xb8>
 8000920:	f104 0318 	add.w	r3, r4, #24
 8000924:	4618      	mov	r0, r3
 8000926:	f640 63e1 	movw	r3, #3809	; 0xee1
 800092a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800092e:	4798      	blx	r3
 8000930:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000932:	f240 2390 	movw	r3, #656	; 0x290
 8000936:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800093a:	681b      	ldr	r3, [r3, #0]
 800093c:	429a      	cmp	r2, r3
 800093e:	d905      	bls.n	800094c <vTaskIncrementTick+0xd4>
 8000940:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000942:	f240 2390 	movw	r3, #656	; 0x290
 8000946:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800094a:	601a      	str	r2, [r3, #0]
 800094c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800094e:	4613      	mov	r3, r2
 8000950:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000954:	4413      	add	r3, r2
 8000956:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800095a:	461a      	mov	r2, r3
 800095c:	f240 134c 	movw	r3, #332	; 0x14c
 8000960:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000964:	441a      	add	r2, r3
 8000966:	f104 0304 	add.w	r3, r4, #4
 800096a:	4610      	mov	r0, r2
 800096c:	4619      	mov	r1, r3
 800096e:	f640 631d 	movw	r3, #3613	; 0xe1d
 8000972:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000976:	4798      	blx	r3
 8000978:	f240 233c 	movw	r3, #572	; 0x23c
 800097c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000980:	681b      	ldr	r3, [r3, #0]
 8000982:	681b      	ldr	r3, [r3, #0]
 8000984:	2b00      	cmp	r3, #0
 8000986:	d007      	beq.n	8000998 <vTaskIncrementTick+0x120>
 8000988:	f240 233c 	movw	r3, #572	; 0x23c
 800098c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000990:	681b      	ldr	r3, [r3, #0]
 8000992:	68db      	ldr	r3, [r3, #12]
 8000994:	68db      	ldr	r3, [r3, #12]
 8000996:	e001      	b.n	800099c <vTaskIncrementTick+0x124>
 8000998:	f04f 0300 	mov.w	r3, #0
 800099c:	461c      	mov	r4, r3
 800099e:	2c00      	cmp	r4, #0
 80009a0:	d1ab      	bne.n	80008fa <vTaskIncrementTick+0x82>
 80009a2:	e010      	b.n	80009c6 <vTaskIncrementTick+0x14e>
	}
	else
	{
		++uxMissedTicks;
 80009a4:	f240 239c 	movw	r3, #668	; 0x29c
 80009a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80009ac:	681b      	ldr	r3, [r3, #0]
 80009ae:	f103 0201 	add.w	r2, r3, #1
 80009b2:	f240 239c 	movw	r3, #668	; 0x29c
 80009b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80009ba:	601a      	str	r2, [r3, #0]
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
 80009bc:	f643 3355 	movw	r3, #15189	; 0x3b55
 80009c0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80009c4:	4798      	blx	r3
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
 80009c6:	f240 239c 	movw	r3, #668	; 0x29c
 80009ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80009ce:	681b      	ldr	r3, [r3, #0]
 80009d0:	2b00      	cmp	r3, #0
 80009d2:	d104      	bne.n	80009de <vTaskIncrementTick+0x166>
		{
			vApplicationTickHook();
 80009d4:	f643 3355 	movw	r3, #15189	; 0x3b55
 80009d8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80009dc:	4798      	blx	r3
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 80009de:	f107 070c 	add.w	r7, r7, #12
 80009e2:	46bd      	mov	sp, r7
 80009e4:	bd90      	pop	{r4, r7, pc}
 80009e6:	bf00      	nop

080009e8 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 80009e8:	b480      	push	{r7}
 80009ea:	b083      	sub	sp, #12
 80009ec:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 80009ee:	f240 2398 	movw	r3, #664	; 0x298
 80009f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80009f6:	681b      	ldr	r3, [r3, #0]
 80009f8:	2b00      	cmp	r3, #0
 80009fa:	d014      	beq.n	8000a26 <vTaskSwitchContext+0x3e>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 80009fc:	f240 23a0 	movw	r3, #672	; 0x2a0
 8000a00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a04:	f04f 0201 	mov.w	r2, #1
 8000a08:	601a      	str	r2, [r3, #0]
		return;
 8000a0a:	e04d      	b.n	8000aa8 <vTaskSwitchContext+0xc0>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
 8000a0c:	f240 2390 	movw	r3, #656	; 0x290
 8000a10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a14:	681b      	ldr	r3, [r3, #0]
 8000a16:	f103 32ff 	add.w	r2, r3, #4294967295
 8000a1a:	f240 2390 	movw	r3, #656	; 0x290
 8000a1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a22:	601a      	str	r2, [r3, #0]
 8000a24:	e000      	b.n	8000a28 <vTaskSwitchContext+0x40>

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 8000a26:	bf00      	nop
 8000a28:	f240 2390 	movw	r3, #656	; 0x290
 8000a2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a30:	681a      	ldr	r2, [r3, #0]
 8000a32:	4613      	mov	r3, r2
 8000a34:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000a38:	4413      	add	r3, r2
 8000a3a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000a3e:	461a      	mov	r2, r3
 8000a40:	f240 134c 	movw	r3, #332	; 0x14c
 8000a44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a48:	4413      	add	r3, r2
 8000a4a:	681b      	ldr	r3, [r3, #0]
 8000a4c:	2b00      	cmp	r3, #0
 8000a4e:	d0dd      	beq.n	8000a0c <vTaskSwitchContext+0x24>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 8000a50:	f240 2390 	movw	r3, #656	; 0x290
 8000a54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a58:	681a      	ldr	r2, [r3, #0]
 8000a5a:	4613      	mov	r3, r2
 8000a5c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000a60:	4413      	add	r3, r2
 8000a62:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000a66:	461a      	mov	r2, r3
 8000a68:	f240 134c 	movw	r3, #332	; 0x14c
 8000a6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a70:	4413      	add	r3, r2
 8000a72:	607b      	str	r3, [r7, #4]
 8000a74:	687b      	ldr	r3, [r7, #4]
 8000a76:	685b      	ldr	r3, [r3, #4]
 8000a78:	685a      	ldr	r2, [r3, #4]
 8000a7a:	687b      	ldr	r3, [r7, #4]
 8000a7c:	605a      	str	r2, [r3, #4]
 8000a7e:	687b      	ldr	r3, [r7, #4]
 8000a80:	685a      	ldr	r2, [r3, #4]
 8000a82:	687b      	ldr	r3, [r7, #4]
 8000a84:	f103 0308 	add.w	r3, r3, #8
 8000a88:	429a      	cmp	r2, r3
 8000a8a:	d104      	bne.n	8000a96 <vTaskSwitchContext+0xae>
 8000a8c:	687b      	ldr	r3, [r7, #4]
 8000a8e:	685b      	ldr	r3, [r3, #4]
 8000a90:	685a      	ldr	r2, [r3, #4]
 8000a92:	687b      	ldr	r3, [r7, #4]
 8000a94:	605a      	str	r2, [r3, #4]
 8000a96:	687b      	ldr	r3, [r7, #4]
 8000a98:	685b      	ldr	r3, [r3, #4]
 8000a9a:	68db      	ldr	r3, [r3, #12]
 8000a9c:	461a      	mov	r2, r3
 8000a9e:	f240 1348 	movw	r3, #328	; 0x148
 8000aa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000aa6:	601a      	str	r2, [r3, #0]

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
 8000aa8:	f107 070c 	add.w	r7, r7, #12
 8000aac:	46bd      	mov	sp, r7
 8000aae:	bc80      	pop	{r7}
 8000ab0:	4770      	bx	lr
 8000ab2:	bf00      	nop

08000ab4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8000ab4:	b580      	push	{r7, lr}
 8000ab6:	b082      	sub	sp, #8
 8000ab8:	af00      	add	r7, sp, #0
 8000aba:	6078      	str	r0, [r7, #4]
 8000abc:	e000      	b.n	8000ac0 <prvIdleTask+0xc>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 8000abe:	bf00      	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 8000ac0:	f640 433d 	movw	r3, #3133	; 0xc3d
 8000ac4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000ac8:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8000aca:	f240 134c 	movw	r3, #332	; 0x14c
 8000ace:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ad2:	681b      	ldr	r3, [r3, #0]
 8000ad4:	2b01      	cmp	r3, #1
 8000ad6:	d9f2      	bls.n	8000abe <prvIdleTask+0xa>
			{
				taskYIELD();
 8000ad8:	f241 0325 	movw	r3, #4133	; 0x1025
 8000adc:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000ae0:	4798      	blx	r3
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 8000ae2:	e7ed      	b.n	8000ac0 <prvIdleTask+0xc>

08000ae4 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 8000ae4:	b580      	push	{r7, lr}
 8000ae6:	b084      	sub	sp, #16
 8000ae8:	af00      	add	r7, sp, #0
 8000aea:	60f8      	str	r0, [r7, #12]
 8000aec:	60b9      	str	r1, [r7, #8]
 8000aee:	607a      	str	r2, [r7, #4]
 8000af0:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8000af2:	68fb      	ldr	r3, [r7, #12]
 8000af4:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8000af8:	461a      	mov	r2, r3
 8000afa:	68bb      	ldr	r3, [r7, #8]
 8000afc:	4610      	mov	r0, r2
 8000afe:	4619      	mov	r1, r3
 8000b00:	f04f 0210 	mov.w	r2, #16
 8000b04:	f240 133d 	movw	r3, #317	; 0x13d
 8000b08:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000b0c:	4798      	blx	r3
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 8000b0e:	68fb      	ldr	r3, [r7, #12]
 8000b10:	f04f 0200 	mov.w	r2, #0
 8000b14:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 8000b18:	687b      	ldr	r3, [r7, #4]
 8000b1a:	2b09      	cmp	r3, #9
 8000b1c:	d902      	bls.n	8000b24 <prvInitialiseTCBVariables+0x40>
	{
		uxPriority = configMAX_PRIORITIES - 1;
 8000b1e:	f04f 0309 	mov.w	r3, #9
 8000b22:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
 8000b24:	68fb      	ldr	r3, [r7, #12]
 8000b26:	687a      	ldr	r2, [r7, #4]
 8000b28:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8000b2a:	68fb      	ldr	r3, [r7, #12]
 8000b2c:	687a      	ldr	r2, [r7, #4]
 8000b2e:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8000b30:	68fb      	ldr	r3, [r7, #12]
 8000b32:	f103 0304 	add.w	r3, r3, #4
 8000b36:	4618      	mov	r0, r3
 8000b38:	f640 6301 	movw	r3, #3585	; 0xe01
 8000b3c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000b40:	4798      	blx	r3
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8000b42:	68fb      	ldr	r3, [r7, #12]
 8000b44:	f103 0318 	add.w	r3, r3, #24
 8000b48:	4618      	mov	r0, r3
 8000b4a:	f640 6301 	movw	r3, #3585	; 0xe01
 8000b4e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000b52:	4798      	blx	r3

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8000b54:	68fb      	ldr	r3, [r7, #12]
 8000b56:	68fa      	ldr	r2, [r7, #12]
 8000b58:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8000b5a:	687b      	ldr	r3, [r7, #4]
 8000b5c:	f1c3 020a 	rsb	r2, r3, #10
 8000b60:	68fb      	ldr	r3, [r7, #12]
 8000b62:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8000b64:	68fb      	ldr	r3, [r7, #12]
 8000b66:	68fa      	ldr	r2, [r7, #12]
 8000b68:	625a      	str	r2, [r3, #36]	; 0x24
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 8000b6a:	f107 0710 	add.w	r7, r7, #16
 8000b6e:	46bd      	mov	sp, r7
 8000b70:	bd80      	pop	{r7, pc}
 8000b72:	bf00      	nop

08000b74 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 8000b74:	b580      	push	{r7, lr}
 8000b76:	b082      	sub	sp, #8
 8000b78:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8000b7a:	f04f 0300 	mov.w	r3, #0
 8000b7e:	607b      	str	r3, [r7, #4]
 8000b80:	e016      	b.n	8000bb0 <prvInitialiseTaskLists+0x3c>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8000b82:	687a      	ldr	r2, [r7, #4]
 8000b84:	4613      	mov	r3, r2
 8000b86:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000b8a:	4413      	add	r3, r2
 8000b8c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000b90:	461a      	mov	r2, r3
 8000b92:	f240 134c 	movw	r3, #332	; 0x14c
 8000b96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b9a:	4413      	add	r3, r2
 8000b9c:	4618      	mov	r0, r3
 8000b9e:	f640 53b9 	movw	r3, #3513	; 0xdb9
 8000ba2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000ba6:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8000ba8:	687b      	ldr	r3, [r7, #4]
 8000baa:	f103 0301 	add.w	r3, r3, #1
 8000bae:	607b      	str	r3, [r7, #4]
 8000bb0:	687b      	ldr	r3, [r7, #4]
 8000bb2:	2b09      	cmp	r3, #9
 8000bb4:	d9e5      	bls.n	8000b82 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8000bb6:	f240 2014 	movw	r0, #532	; 0x214
 8000bba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000bbe:	f640 53b9 	movw	r3, #3513	; 0xdb9
 8000bc2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000bc6:	4798      	blx	r3
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8000bc8:	f240 2028 	movw	r0, #552	; 0x228
 8000bcc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000bd0:	f640 53b9 	movw	r3, #3513	; 0xdb9
 8000bd4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000bd8:	4798      	blx	r3
	vListInitialise( ( xList * ) &xPendingReadyList );
 8000bda:	f240 2044 	movw	r0, #580	; 0x244
 8000bde:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000be2:	f640 53b9 	movw	r3, #3513	; 0xdb9
 8000be6:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000bea:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 8000bec:	f240 2058 	movw	r0, #600	; 0x258
 8000bf0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000bf4:	f640 53b9 	movw	r3, #3513	; 0xdb9
 8000bf8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000bfc:	4798      	blx	r3
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 8000bfe:	f240 2070 	movw	r0, #624	; 0x270
 8000c02:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000c06:	f640 53b9 	movw	r3, #3513	; 0xdb9
 8000c0a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000c0e:	4798      	blx	r3
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8000c10:	f240 233c 	movw	r3, #572	; 0x23c
 8000c14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c18:	f240 2214 	movw	r2, #532	; 0x214
 8000c1c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8000c20:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8000c22:	f240 2340 	movw	r3, #576	; 0x240
 8000c26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c2a:	f240 2228 	movw	r2, #552	; 0x228
 8000c2e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8000c32:	601a      	str	r2, [r3, #0]
}
 8000c34:	f107 0708 	add.w	r7, r7, #8
 8000c38:	46bd      	mov	sp, r7
 8000c3a:	bd80      	pop	{r7, pc}

08000c3c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8000c3c:	b580      	push	{r7, lr}
 8000c3e:	b082      	sub	sp, #8
 8000c40:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 8000c42:	f240 236c 	movw	r3, #620	; 0x26c
 8000c46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c4a:	681b      	ldr	r3, [r3, #0]
 8000c4c:	2b00      	cmp	r3, #0
 8000c4e:	d055      	beq.n	8000cfc <prvCheckTasksWaitingTermination+0xc0>
		{
			vTaskSuspendAll();
 8000c50:	f240 63c9 	movw	r3, #1737	; 0x6c9
 8000c54:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000c58:	4798      	blx	r3
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8000c5a:	f240 2358 	movw	r3, #600	; 0x258
 8000c5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c62:	681b      	ldr	r3, [r3, #0]
 8000c64:	2b00      	cmp	r3, #0
 8000c66:	bf14      	ite	ne
 8000c68:	2300      	movne	r3, #0
 8000c6a:	2301      	moveq	r3, #1
 8000c6c:	603b      	str	r3, [r7, #0]
			xTaskResumeAll();
 8000c6e:	f240 63ed 	movw	r3, #1773	; 0x6ed
 8000c72:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000c76:	4798      	blx	r3

			if( !xListIsEmpty )
 8000c78:	683b      	ldr	r3, [r7, #0]
 8000c7a:	2b00      	cmp	r3, #0
 8000c7c:	d13e      	bne.n	8000cfc <prvCheckTasksWaitingTermination+0xc0>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
 8000c7e:	f241 033d 	movw	r3, #4157	; 0x103d
 8000c82:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000c86:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8000c88:	f240 2358 	movw	r3, #600	; 0x258
 8000c8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c90:	681b      	ldr	r3, [r3, #0]
 8000c92:	2b00      	cmp	r3, #0
 8000c94:	d003      	beq.n	8000c9e <prvCheckTasksWaitingTermination+0x62>
 8000c96:	4b1b      	ldr	r3, [pc, #108]	; (8000d04 <prvCheckTasksWaitingTermination+0xc8>)
 8000c98:	685b      	ldr	r3, [r3, #4]
 8000c9a:	68db      	ldr	r3, [r3, #12]
 8000c9c:	e001      	b.n	8000ca2 <prvCheckTasksWaitingTermination+0x66>
 8000c9e:	f04f 0300 	mov.w	r3, #0
 8000ca2:	607b      	str	r3, [r7, #4]
					vListRemove( &( pxTCB->xGenericListItem ) );
 8000ca4:	687b      	ldr	r3, [r7, #4]
 8000ca6:	f103 0304 	add.w	r3, r3, #4
 8000caa:	4618      	mov	r0, r3
 8000cac:	f640 63e1 	movw	r3, #3809	; 0xee1
 8000cb0:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000cb4:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
 8000cb6:	f240 2384 	movw	r3, #644	; 0x284
 8000cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cbe:	681b      	ldr	r3, [r3, #0]
 8000cc0:	f103 32ff 	add.w	r2, r3, #4294967295
 8000cc4:	f240 2384 	movw	r3, #644	; 0x284
 8000cc8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ccc:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
 8000cce:	f240 236c 	movw	r3, #620	; 0x26c
 8000cd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cd6:	681b      	ldr	r3, [r3, #0]
 8000cd8:	f103 32ff 	add.w	r2, r3, #4294967295
 8000cdc:	f240 236c 	movw	r3, #620	; 0x26c
 8000ce0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ce4:	601a      	str	r2, [r3, #0]
				}
				portEXIT_CRITICAL();
 8000ce6:	f241 0369 	movw	r3, #4201	; 0x1069
 8000cea:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000cee:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
 8000cf0:	6878      	ldr	r0, [r7, #4]
 8000cf2:	f640 538d 	movw	r3, #3469	; 0xd8d
 8000cf6:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000cfa:	4798      	blx	r3
			}
		}
	}
	#endif
}
 8000cfc:	f107 0708 	add.w	r7, r7, #8
 8000d00:	46bd      	mov	sp, r7
 8000d02:	bd80      	pop	{r7, pc}
 8000d04:	20000260 	.word	0x20000260

08000d08 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 8000d08:	b580      	push	{r7, lr}
 8000d0a:	b084      	sub	sp, #16
 8000d0c:	af00      	add	r7, sp, #0
 8000d0e:	4603      	mov	r3, r0
 8000d10:	6039      	str	r1, [r7, #0]
 8000d12:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8000d14:	f04f 0048 	mov.w	r0, #72	; 0x48
 8000d18:	f241 1345 	movw	r3, #4421	; 0x1145
 8000d1c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000d20:	4798      	blx	r3
 8000d22:	4603      	mov	r3, r0
 8000d24:	60fb      	str	r3, [r7, #12]

	if( pxNewTCB != NULL )
 8000d26:	68fb      	ldr	r3, [r7, #12]
 8000d28:	2b00      	cmp	r3, #0
 8000d2a:	d028      	beq.n	8000d7e <prvAllocateTCBAndStack+0x76>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 8000d2c:	88fb      	ldrh	r3, [r7, #6]
 8000d2e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000d32:	4618      	mov	r0, r3
 8000d34:	f241 1345 	movw	r3, #4421	; 0x1145
 8000d38:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000d3c:	4798      	blx	r3
 8000d3e:	4603      	mov	r3, r0
 8000d40:	461a      	mov	r2, r3
 8000d42:	68fb      	ldr	r3, [r7, #12]
 8000d44:	631a      	str	r2, [r3, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8000d46:	68fb      	ldr	r3, [r7, #12]
 8000d48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d4a:	2b00      	cmp	r3, #0
 8000d4c:	d109      	bne.n	8000d62 <prvAllocateTCBAndStack+0x5a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8000d4e:	68f8      	ldr	r0, [r7, #12]
 8000d50:	f241 3315 	movw	r3, #4885	; 0x1315
 8000d54:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000d58:	4798      	blx	r3
			pxNewTCB = NULL;
 8000d5a:	f04f 0300 	mov.w	r3, #0
 8000d5e:	60fb      	str	r3, [r7, #12]
 8000d60:	e00d      	b.n	8000d7e <prvAllocateTCBAndStack+0x76>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 8000d62:	68fb      	ldr	r3, [r7, #12]
 8000d64:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000d66:	88fb      	ldrh	r3, [r7, #6]
 8000d68:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8000d6c:	4610      	mov	r0, r2
 8000d6e:	f04f 01a5 	mov.w	r1, #165	; 0xa5
 8000d72:	461a      	mov	r2, r3
 8000d74:	f240 0309 	movw	r3, #9
 8000d78:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000d7c:	4798      	blx	r3
		}
	}

	return pxNewTCB;
 8000d7e:	68fb      	ldr	r3, [r7, #12]
}
 8000d80:	4618      	mov	r0, r3
 8000d82:	f107 0710 	add.w	r7, r7, #16
 8000d86:	46bd      	mov	sp, r7
 8000d88:	bd80      	pop	{r7, pc}
 8000d8a:	bf00      	nop

08000d8c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
 8000d8c:	b580      	push	{r7, lr}
 8000d8e:	b082      	sub	sp, #8
 8000d90:	af00      	add	r7, sp, #0
 8000d92:	6078      	str	r0, [r7, #4]
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8000d94:	687b      	ldr	r3, [r7, #4]
 8000d96:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d98:	4618      	mov	r0, r3
 8000d9a:	f241 3315 	movw	r3, #4885	; 0x1315
 8000d9e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000da2:	4798      	blx	r3
		vPortFree( pxTCB );
 8000da4:	6878      	ldr	r0, [r7, #4]
 8000da6:	f241 3315 	movw	r3, #4885	; 0x1315
 8000daa:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000dae:	4798      	blx	r3
	}
 8000db0:	f107 0708 	add.w	r7, r7, #8
 8000db4:	46bd      	mov	sp, r7
 8000db6:	bd80      	pop	{r7, pc}

08000db8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 8000db8:	b480      	push	{r7}
 8000dba:	b083      	sub	sp, #12
 8000dbc:	af00      	add	r7, sp, #0
 8000dbe:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8000dc0:	687b      	ldr	r3, [r7, #4]
 8000dc2:	f103 0308 	add.w	r3, r3, #8
 8000dc6:	461a      	mov	r2, r3
 8000dc8:	687b      	ldr	r3, [r7, #4]
 8000dca:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8000dcc:	687b      	ldr	r3, [r7, #4]
 8000dce:	f04f 32ff 	mov.w	r2, #4294967295
 8000dd2:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8000dd4:	687b      	ldr	r3, [r7, #4]
 8000dd6:	f103 0308 	add.w	r3, r3, #8
 8000dda:	461a      	mov	r2, r3
 8000ddc:	687b      	ldr	r3, [r7, #4]
 8000dde:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8000de0:	687b      	ldr	r3, [r7, #4]
 8000de2:	f103 0308 	add.w	r3, r3, #8
 8000de6:	461a      	mov	r2, r3
 8000de8:	687b      	ldr	r3, [r7, #4]
 8000dea:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = 0;
 8000dec:	687b      	ldr	r3, [r7, #4]
 8000dee:	f04f 0200 	mov.w	r2, #0
 8000df2:	601a      	str	r2, [r3, #0]
}
 8000df4:	f107 070c 	add.w	r7, r7, #12
 8000df8:	46bd      	mov	sp, r7
 8000dfa:	bc80      	pop	{r7}
 8000dfc:	4770      	bx	lr
 8000dfe:	bf00      	nop

08000e00 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 8000e00:	b480      	push	{r7}
 8000e02:	b083      	sub	sp, #12
 8000e04:	af00      	add	r7, sp, #0
 8000e06:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8000e08:	687b      	ldr	r3, [r7, #4]
 8000e0a:	f04f 0200 	mov.w	r2, #0
 8000e0e:	611a      	str	r2, [r3, #16]
}
 8000e10:	f107 070c 	add.w	r7, r7, #12
 8000e14:	46bd      	mov	sp, r7
 8000e16:	bc80      	pop	{r7}
 8000e18:	4770      	bx	lr
 8000e1a:	bf00      	nop

08000e1c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 8000e1c:	b480      	push	{r7}
 8000e1e:	b085      	sub	sp, #20
 8000e20:	af00      	add	r7, sp, #0
 8000e22:	6078      	str	r0, [r7, #4]
 8000e24:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8000e26:	687b      	ldr	r3, [r7, #4]
 8000e28:	685b      	ldr	r3, [r3, #4]
 8000e2a:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8000e2c:	68fb      	ldr	r3, [r7, #12]
 8000e2e:	685a      	ldr	r2, [r3, #4]
 8000e30:	683b      	ldr	r3, [r7, #0]
 8000e32:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8000e34:	687b      	ldr	r3, [r7, #4]
 8000e36:	685a      	ldr	r2, [r3, #4]
 8000e38:	683b      	ldr	r3, [r7, #0]
 8000e3a:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8000e3c:	68fb      	ldr	r3, [r7, #12]
 8000e3e:	685b      	ldr	r3, [r3, #4]
 8000e40:	683a      	ldr	r2, [r7, #0]
 8000e42:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8000e44:	683a      	ldr	r2, [r7, #0]
 8000e46:	68fb      	ldr	r3, [r7, #12]
 8000e48:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8000e4a:	683a      	ldr	r2, [r7, #0]
 8000e4c:	687b      	ldr	r3, [r7, #4]
 8000e4e:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000e50:	683b      	ldr	r3, [r7, #0]
 8000e52:	687a      	ldr	r2, [r7, #4]
 8000e54:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8000e56:	687b      	ldr	r3, [r7, #4]
 8000e58:	681b      	ldr	r3, [r3, #0]
 8000e5a:	f103 0201 	add.w	r2, r3, #1
 8000e5e:	687b      	ldr	r3, [r7, #4]
 8000e60:	601a      	str	r2, [r3, #0]
}
 8000e62:	f107 0714 	add.w	r7, r7, #20
 8000e66:	46bd      	mov	sp, r7
 8000e68:	bc80      	pop	{r7}
 8000e6a:	4770      	bx	lr

08000e6c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 8000e6c:	b480      	push	{r7}
 8000e6e:	b085      	sub	sp, #20
 8000e70:	af00      	add	r7, sp, #0
 8000e72:	6078      	str	r0, [r7, #4]
 8000e74:	6039      	str	r1, [r7, #0]
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8000e76:	683b      	ldr	r3, [r7, #0]
 8000e78:	681b      	ldr	r3, [r3, #0]
 8000e7a:	60fb      	str	r3, [r7, #12]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8000e7c:	68fb      	ldr	r3, [r7, #12]
 8000e7e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000e82:	d103      	bne.n	8000e8c <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8000e84:	687b      	ldr	r3, [r7, #4]
 8000e86:	691b      	ldr	r3, [r3, #16]
 8000e88:	60bb      	str	r3, [r7, #8]
 8000e8a:	e00d      	b.n	8000ea8 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8000e8c:	687b      	ldr	r3, [r7, #4]
 8000e8e:	f103 0308 	add.w	r3, r3, #8
 8000e92:	60bb      	str	r3, [r7, #8]
 8000e94:	e002      	b.n	8000e9c <vListInsert+0x30>
 8000e96:	68bb      	ldr	r3, [r7, #8]
 8000e98:	685b      	ldr	r3, [r3, #4]
 8000e9a:	60bb      	str	r3, [r7, #8]
 8000e9c:	68bb      	ldr	r3, [r7, #8]
 8000e9e:	685b      	ldr	r3, [r3, #4]
 8000ea0:	681a      	ldr	r2, [r3, #0]
 8000ea2:	68fb      	ldr	r3, [r7, #12]
 8000ea4:	429a      	cmp	r2, r3
 8000ea6:	d9f6      	bls.n	8000e96 <vListInsert+0x2a>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8000ea8:	68bb      	ldr	r3, [r7, #8]
 8000eaa:	685a      	ldr	r2, [r3, #4]
 8000eac:	683b      	ldr	r3, [r7, #0]
 8000eae:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8000eb0:	683b      	ldr	r3, [r7, #0]
 8000eb2:	685b      	ldr	r3, [r3, #4]
 8000eb4:	683a      	ldr	r2, [r7, #0]
 8000eb6:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8000eb8:	683b      	ldr	r3, [r7, #0]
 8000eba:	68ba      	ldr	r2, [r7, #8]
 8000ebc:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8000ebe:	683a      	ldr	r2, [r7, #0]
 8000ec0:	68bb      	ldr	r3, [r7, #8]
 8000ec2:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8000ec4:	683b      	ldr	r3, [r7, #0]
 8000ec6:	687a      	ldr	r2, [r7, #4]
 8000ec8:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8000eca:	687b      	ldr	r3, [r7, #4]
 8000ecc:	681b      	ldr	r3, [r3, #0]
 8000ece:	f103 0201 	add.w	r2, r3, #1
 8000ed2:	687b      	ldr	r3, [r7, #4]
 8000ed4:	601a      	str	r2, [r3, #0]
}
 8000ed6:	f107 0714 	add.w	r7, r7, #20
 8000eda:	46bd      	mov	sp, r7
 8000edc:	bc80      	pop	{r7}
 8000ede:	4770      	bx	lr

08000ee0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 8000ee0:	b480      	push	{r7}
 8000ee2:	b085      	sub	sp, #20
 8000ee4:	af00      	add	r7, sp, #0
 8000ee6:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000ee8:	687b      	ldr	r3, [r7, #4]
 8000eea:	685b      	ldr	r3, [r3, #4]
 8000eec:	687a      	ldr	r2, [r7, #4]
 8000eee:	6892      	ldr	r2, [r2, #8]
 8000ef0:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000ef2:	687b      	ldr	r3, [r7, #4]
 8000ef4:	689b      	ldr	r3, [r3, #8]
 8000ef6:	687a      	ldr	r2, [r7, #4]
 8000ef8:	6852      	ldr	r2, [r2, #4]
 8000efa:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8000efc:	687b      	ldr	r3, [r7, #4]
 8000efe:	691b      	ldr	r3, [r3, #16]
 8000f00:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000f02:	68fb      	ldr	r3, [r7, #12]
 8000f04:	685a      	ldr	r2, [r3, #4]
 8000f06:	687b      	ldr	r3, [r7, #4]
 8000f08:	429a      	cmp	r2, r3
 8000f0a:	d103      	bne.n	8000f14 <vListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000f0c:	687b      	ldr	r3, [r7, #4]
 8000f0e:	689a      	ldr	r2, [r3, #8]
 8000f10:	68fb      	ldr	r3, [r7, #12]
 8000f12:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8000f14:	687b      	ldr	r3, [r7, #4]
 8000f16:	f04f 0200 	mov.w	r2, #0
 8000f1a:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8000f1c:	68fb      	ldr	r3, [r7, #12]
 8000f1e:	681b      	ldr	r3, [r3, #0]
 8000f20:	f103 32ff 	add.w	r2, r3, #4294967295
 8000f24:	68fb      	ldr	r3, [r7, #12]
 8000f26:	601a      	str	r2, [r3, #0]
}
 8000f28:	f107 0714 	add.w	r7, r7, #20
 8000f2c:	46bd      	mov	sp, r7
 8000f2e:	bc80      	pop	{r7}
 8000f30:	4770      	bx	lr
 8000f32:	bf00      	nop

08000f34 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 8000f34:	b480      	push	{r7}
 8000f36:	b085      	sub	sp, #20
 8000f38:	af00      	add	r7, sp, #0
 8000f3a:	60f8      	str	r0, [r7, #12]
 8000f3c:	60b9      	str	r1, [r7, #8]
 8000f3e:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8000f40:	68fb      	ldr	r3, [r7, #12]
 8000f42:	f1a3 0304 	sub.w	r3, r3, #4
 8000f46:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8000f48:	68fb      	ldr	r3, [r7, #12]
 8000f4a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000f4e:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000f50:	68fb      	ldr	r3, [r7, #12]
 8000f52:	f1a3 0304 	sub.w	r3, r3, #4
 8000f56:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8000f58:	68ba      	ldr	r2, [r7, #8]
 8000f5a:	68fb      	ldr	r3, [r7, #12]
 8000f5c:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8000f5e:	68fb      	ldr	r3, [r7, #12]
 8000f60:	f1a3 0304 	sub.w	r3, r3, #4
 8000f64:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
 8000f66:	68fb      	ldr	r3, [r7, #12]
 8000f68:	f04f 0200 	mov.w	r2, #0
 8000f6c:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8000f6e:	68fb      	ldr	r3, [r7, #12]
 8000f70:	f1a3 0314 	sub.w	r3, r3, #20
 8000f74:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8000f76:	687a      	ldr	r2, [r7, #4]
 8000f78:	68fb      	ldr	r3, [r7, #12]
 8000f7a:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8000f7c:	68fb      	ldr	r3, [r7, #12]
 8000f7e:	f1a3 0320 	sub.w	r3, r3, #32
 8000f82:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8000f84:	68fb      	ldr	r3, [r7, #12]
}
 8000f86:	4618      	mov	r0, r3
 8000f88:	f107 0714 	add.w	r7, r7, #20
 8000f8c:	46bd      	mov	sp, r7
 8000f8e:	bc80      	pop	{r7}
 8000f90:	4770      	bx	lr
 8000f92:	bf00      	nop

08000f94 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8000f94:	4b06      	ldr	r3, [pc, #24]	; (8000fb0 <pxCurrentTCBConst2>)
 8000f96:	6819      	ldr	r1, [r3, #0]
 8000f98:	6808      	ldr	r0, [r1, #0]
 8000f9a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8000f9e:	f380 8809 	msr	PSP, r0
 8000fa2:	f04f 0000 	mov.w	r0, #0
 8000fa6:	f380 8811 	msr	BASEPRI, r0
 8000faa:	f04e 0e0d 	orr.w	lr, lr, #13
 8000fae:	4770      	bx	lr

08000fb0 <pxCurrentTCBConst2>:
 8000fb0:	20000148 	.word	0x20000148

08000fb4 <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 8000fb4:	4802      	ldr	r0, [pc, #8]	; (8000fc0 <vPortStartFirstTask+0xc>)
 8000fb6:	6800      	ldr	r0, [r0, #0]
 8000fb8:	6800      	ldr	r0, [r0, #0]
 8000fba:	f380 8808 	msr	MSP, r0
 8000fbe:	df00      	svc	0
 8000fc0:	e000ed08 	.word	0xe000ed08

08000fc4 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8000fc4:	b580      	push	{r7, lr}
 8000fc6:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8000fc8:	f64e 5320 	movw	r3, #60704	; 0xed20
 8000fcc:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000fd0:	f64e 5220 	movw	r2, #60704	; 0xed20
 8000fd4:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000fd8:	6812      	ldr	r2, [r2, #0]
 8000fda:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8000fde:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8000fe0:	f64e 5320 	movw	r3, #60704	; 0xed20
 8000fe4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000fe8:	f64e 5220 	movw	r2, #60704	; 0xed20
 8000fec:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8000ff0:	6812      	ldr	r2, [r2, #0]
 8000ff2:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8000ff6:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 8000ff8:	f241 1319 	movw	r3, #4377	; 0x1119
 8000ffc:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001000:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8001002:	f240 1330 	movw	r3, #304	; 0x130
 8001006:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800100a:	f04f 0200 	mov.w	r2, #0
 800100e:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8001010:	f640 73b5 	movw	r3, #4021	; 0xfb5
 8001014:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001018:	4798      	blx	r3

	/* Should not get here! */
	return 0;
 800101a:	f04f 0300 	mov.w	r3, #0
}
 800101e:	4618      	mov	r0, r3
 8001020:	bd80      	pop	{r7, pc}
 8001022:	bf00      	nop

08001024 <vPortYieldFromISR>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 8001024:	b480      	push	{r7}
 8001026:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8001028:	f64e 5304 	movw	r3, #60676	; 0xed04
 800102c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001030:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001034:	601a      	str	r2, [r3, #0]
}
 8001036:	46bd      	mov	sp, r7
 8001038:	bc80      	pop	{r7}
 800103a:	4770      	bx	lr

0800103c <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800103c:	b480      	push	{r7}
 800103e:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 8001040:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001044:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8001048:	f240 1330 	movw	r3, #304	; 0x130
 800104c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001050:	681b      	ldr	r3, [r3, #0]
 8001052:	f103 0201 	add.w	r2, r3, #1
 8001056:	f240 1330 	movw	r3, #304	; 0x130
 800105a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800105e:	601a      	str	r2, [r3, #0]
}
 8001060:	46bd      	mov	sp, r7
 8001062:	bc80      	pop	{r7}
 8001064:	4770      	bx	lr
 8001066:	bf00      	nop

08001068 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8001068:	b480      	push	{r7}
 800106a:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
 800106c:	f240 1330 	movw	r3, #304	; 0x130
 8001070:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001074:	681b      	ldr	r3, [r3, #0]
 8001076:	f103 32ff 	add.w	r2, r3, #4294967295
 800107a:	f240 1330 	movw	r3, #304	; 0x130
 800107e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001082:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
 8001084:	f240 1330 	movw	r3, #304	; 0x130
 8001088:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800108c:	681b      	ldr	r3, [r3, #0]
 800108e:	2b00      	cmp	r3, #0
 8001090:	d103      	bne.n	800109a <vPortExitCritical+0x32>
	{
		portENABLE_INTERRUPTS();
 8001092:	f04f 0000 	mov.w	r0, #0
 8001096:	f380 8811 	msr	BASEPRI, r0
	}
}
 800109a:	46bd      	mov	sp, r7
 800109c:	bc80      	pop	{r7}
 800109e:	4770      	bx	lr

080010a0 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 80010a0:	f3ef 8009 	mrs	r0, PSP
 80010a4:	4b0c      	ldr	r3, [pc, #48]	; (80010d8 <pxCurrentTCBConst>)
 80010a6:	681a      	ldr	r2, [r3, #0]
 80010a8:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80010ac:	6010      	str	r0, [r2, #0]
 80010ae:	e92d 4008 	stmdb	sp!, {r3, lr}
 80010b2:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 80010b6:	f380 8811 	msr	BASEPRI, r0
 80010ba:	f7ff fc95 	bl	80009e8 <vTaskSwitchContext>
 80010be:	f04f 0000 	mov.w	r0, #0
 80010c2:	f380 8811 	msr	BASEPRI, r0
 80010c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80010ca:	6819      	ldr	r1, [r3, #0]
 80010cc:	6808      	ldr	r0, [r1, #0]
 80010ce:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80010d2:	f380 8809 	msr	PSP, r0
 80010d6:	4770      	bx	lr

080010d8 <pxCurrentTCBConst>:
 80010d8:	20000148 	.word	0x20000148

080010dc <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80010dc:	b580      	push	{r7, lr}
 80010de:	b082      	sub	sp, #8
 80010e0:	af00      	add	r7, sp, #0
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 80010e2:	f64e 5304 	movw	r3, #60676	; 0xed04
 80010e6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80010ea:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80010ee:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 80010f0:	f04f 0300 	mov.w	r3, #0
 80010f4:	607b      	str	r3, [r7, #4]
 80010f6:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 80010fa:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 80010fe:	f640 0379 	movw	r3, #2169	; 0x879
 8001102:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001106:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8001108:	f04f 0000 	mov.w	r0, #0
 800110c:	f380 8811 	msr	BASEPRI, r0
}
 8001110:	f107 0708 	add.w	r7, r7, #8
 8001114:	46bd      	mov	sp, r7
 8001116:	bd80      	pop	{r7, pc}

08001118 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 8001118:	b480      	push	{r7}
 800111a:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800111c:	f24e 0314 	movw	r3, #57364	; 0xe014
 8001120:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001124:	f641 123f 	movw	r2, #6463	; 0x193f
 8001128:	f2c0 0201 	movt	r2, #1
 800112c:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800112e:	f24e 0310 	movw	r3, #57360	; 0xe010
 8001132:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001136:	f04f 0207 	mov.w	r2, #7
 800113a:	601a      	str	r2, [r3, #0]
}
 800113c:	46bd      	mov	sp, r7
 800113e:	bc80      	pop	{r7}
 8001140:	4770      	bx	lr
 8001142:	bf00      	nop

08001144 <pvPortMalloc>:
	xFreeBytesRemaining = configTOTAL_HEAP_SIZE;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8001144:	b580      	push	{r7, lr}
 8001146:	b08a      	sub	sp, #40	; 0x28
 8001148:	af00      	add	r7, sp, #0
 800114a:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 800114c:	f04f 0300 	mov.w	r3, #0
 8001150:	61bb      	str	r3, [r7, #24]

	vTaskSuspendAll();
 8001152:	f240 63c9 	movw	r3, #1737	; 0x6c9
 8001156:	f6c0 0300 	movt	r3, #2048	; 0x800
 800115a:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 800115c:	f642 23c4 	movw	r3, #10948	; 0x2ac4
 8001160:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001164:	681b      	ldr	r3, [r3, #0]
 8001166:	2b00      	cmp	r3, #0
 8001168:	d13a      	bne.n	80011e0 <pvPortMalloc+0x9c>
		{
			prvHeapInit();
 800116a:	f240 22b0 	movw	r2, #688	; 0x2b0
 800116e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001172:	f642 23b0 	movw	r3, #10928	; 0x2ab0
 8001176:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800117a:	601a      	str	r2, [r3, #0]
 800117c:	f642 23b0 	movw	r3, #10928	; 0x2ab0
 8001180:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001184:	f04f 0200 	mov.w	r2, #0
 8001188:	605a      	str	r2, [r3, #4]
 800118a:	f642 23b8 	movw	r3, #10936	; 0x2ab8
 800118e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001192:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8001196:	605a      	str	r2, [r3, #4]
 8001198:	f642 23b8 	movw	r3, #10936	; 0x2ab8
 800119c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011a0:	f04f 0200 	mov.w	r2, #0
 80011a4:	601a      	str	r2, [r3, #0]
 80011a6:	f240 23b0 	movw	r3, #688	; 0x2b0
 80011aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011ae:	61fb      	str	r3, [r7, #28]
 80011b0:	69fb      	ldr	r3, [r7, #28]
 80011b2:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 80011b6:	605a      	str	r2, [r3, #4]
 80011b8:	69fa      	ldr	r2, [r7, #28]
 80011ba:	f642 23b8 	movw	r3, #10936	; 0x2ab8
 80011be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011c2:	6013      	str	r3, [r2, #0]
 80011c4:	f642 23c0 	movw	r3, #10944	; 0x2ac0
 80011c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011cc:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 80011d0:	601a      	str	r2, [r3, #0]
			xHeapHasBeenInitialised = pdTRUE;
 80011d2:	f642 23c4 	movw	r3, #10948	; 0x2ac4
 80011d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80011da:	f04f 0201 	mov.w	r2, #1
 80011de:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 80011e0:	687b      	ldr	r3, [r7, #4]
 80011e2:	2b00      	cmp	r3, #0
 80011e4:	d012      	beq.n	800120c <pvPortMalloc+0xc8>
		{
			xWantedSize += heapSTRUCT_SIZE;
 80011e6:	f244 037c 	movw	r3, #16508	; 0x407c
 80011ea:	f6c0 0300 	movt	r3, #2048	; 0x800
 80011ee:	881b      	ldrh	r3, [r3, #0]
 80011f0:	687a      	ldr	r2, [r7, #4]
 80011f2:	4413      	add	r3, r2
 80011f4:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 80011f6:	687b      	ldr	r3, [r7, #4]
 80011f8:	f003 0307 	and.w	r3, r3, #7
 80011fc:	2b00      	cmp	r3, #0
 80011fe:	d005      	beq.n	800120c <pvPortMalloc+0xc8>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8001200:	687b      	ldr	r3, [r7, #4]
 8001202:	f023 0307 	bic.w	r3, r3, #7
 8001206:	f103 0308 	add.w	r3, r3, #8
 800120a:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
 800120c:	687b      	ldr	r3, [r7, #4]
 800120e:	2b00      	cmp	r3, #0
 8001210:	d074      	beq.n	80012fc <pvPortMalloc+0x1b8>
 8001212:	687a      	ldr	r2, [r7, #4]
 8001214:	f242 73ff 	movw	r3, #10239	; 0x27ff
 8001218:	429a      	cmp	r2, r3
 800121a:	d86f      	bhi.n	80012fc <pvPortMalloc+0x1b8>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 800121c:	f642 23b0 	movw	r3, #10928	; 0x2ab0
 8001220:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001224:	613b      	str	r3, [r7, #16]
			pxBlock = xStart.pxNextFreeBlock;
 8001226:	f642 23b0 	movw	r3, #10928	; 0x2ab0
 800122a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800122e:	681b      	ldr	r3, [r3, #0]
 8001230:	60fb      	str	r3, [r7, #12]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
 8001232:	e004      	b.n	800123e <pvPortMalloc+0xfa>
			{
				pxPreviousBlock = pxBlock;
 8001234:	68fb      	ldr	r3, [r7, #12]
 8001236:	613b      	str	r3, [r7, #16]
				pxBlock = pxBlock->pxNextFreeBlock;
 8001238:	68fb      	ldr	r3, [r7, #12]
 800123a:	681b      	ldr	r3, [r3, #0]
 800123c:	60fb      	str	r3, [r7, #12]
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
 800123e:	68fb      	ldr	r3, [r7, #12]
 8001240:	685a      	ldr	r2, [r3, #4]
 8001242:	687b      	ldr	r3, [r7, #4]
 8001244:	429a      	cmp	r2, r3
 8001246:	d203      	bcs.n	8001250 <pvPortMalloc+0x10c>
 8001248:	68fb      	ldr	r3, [r7, #12]
 800124a:	681b      	ldr	r3, [r3, #0]
 800124c:	2b00      	cmp	r3, #0
 800124e:	d1f1      	bne.n	8001234 <pvPortMalloc+0xf0>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 8001250:	68fa      	ldr	r2, [r7, #12]
 8001252:	f642 23b8 	movw	r3, #10936	; 0x2ab8
 8001256:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800125a:	429a      	cmp	r2, r3
 800125c:	d04e      	beq.n	80012fc <pvPortMalloc+0x1b8>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 800125e:	693b      	ldr	r3, [r7, #16]
 8001260:	681a      	ldr	r2, [r3, #0]
 8001262:	f244 037c 	movw	r3, #16508	; 0x407c
 8001266:	f6c0 0300 	movt	r3, #2048	; 0x800
 800126a:	881b      	ldrh	r3, [r3, #0]
 800126c:	4413      	add	r3, r2
 800126e:	61bb      	str	r3, [r7, #24]

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8001270:	68fb      	ldr	r3, [r7, #12]
 8001272:	681a      	ldr	r2, [r3, #0]
 8001274:	693b      	ldr	r3, [r7, #16]
 8001276:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8001278:	68fb      	ldr	r3, [r7, #12]
 800127a:	685a      	ldr	r2, [r3, #4]
 800127c:	687b      	ldr	r3, [r7, #4]
 800127e:	ebc3 0202 	rsb	r2, r3, r2
 8001282:	f244 037c 	movw	r3, #16508	; 0x407c
 8001286:	f6c0 0300 	movt	r3, #2048	; 0x800
 800128a:	881b      	ldrh	r3, [r3, #0]
 800128c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001290:	429a      	cmp	r2, r3
 8001292:	d926      	bls.n	80012e2 <pvPortMalloc+0x19e>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 8001294:	68fa      	ldr	r2, [r7, #12]
 8001296:	687b      	ldr	r3, [r7, #4]
 8001298:	4413      	add	r3, r2
 800129a:	617b      	str	r3, [r7, #20]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800129c:	68fb      	ldr	r3, [r7, #12]
 800129e:	685a      	ldr	r2, [r3, #4]
 80012a0:	687b      	ldr	r3, [r7, #4]
 80012a2:	ebc3 0202 	rsb	r2, r3, r2
 80012a6:	697b      	ldr	r3, [r7, #20]
 80012a8:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
 80012aa:	68fb      	ldr	r3, [r7, #12]
 80012ac:	687a      	ldr	r2, [r7, #4]
 80012ae:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 80012b0:	697b      	ldr	r3, [r7, #20]
 80012b2:	685b      	ldr	r3, [r3, #4]
 80012b4:	627b      	str	r3, [r7, #36]	; 0x24
 80012b6:	f642 23b0 	movw	r3, #10928	; 0x2ab0
 80012ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012be:	623b      	str	r3, [r7, #32]
 80012c0:	e002      	b.n	80012c8 <pvPortMalloc+0x184>
 80012c2:	6a3b      	ldr	r3, [r7, #32]
 80012c4:	681b      	ldr	r3, [r3, #0]
 80012c6:	623b      	str	r3, [r7, #32]
 80012c8:	6a3b      	ldr	r3, [r7, #32]
 80012ca:	681b      	ldr	r3, [r3, #0]
 80012cc:	685a      	ldr	r2, [r3, #4]
 80012ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80012d0:	429a      	cmp	r2, r3
 80012d2:	d3f6      	bcc.n	80012c2 <pvPortMalloc+0x17e>
 80012d4:	6a3b      	ldr	r3, [r7, #32]
 80012d6:	681a      	ldr	r2, [r3, #0]
 80012d8:	697b      	ldr	r3, [r7, #20]
 80012da:	601a      	str	r2, [r3, #0]
 80012dc:	6a3b      	ldr	r3, [r7, #32]
 80012de:	697a      	ldr	r2, [r7, #20]
 80012e0:	601a      	str	r2, [r3, #0]
				}
				
				xFreeBytesRemaining -= xWantedSize;
 80012e2:	f642 23c0 	movw	r3, #10944	; 0x2ac0
 80012e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012ea:	681a      	ldr	r2, [r3, #0]
 80012ec:	687b      	ldr	r3, [r7, #4]
 80012ee:	ebc3 0202 	rsb	r2, r3, r2
 80012f2:	f642 23c0 	movw	r3, #10944	; 0x2ac0
 80012f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80012fa:	601a      	str	r2, [r3, #0]
			}
		}
	}
	xTaskResumeAll();
 80012fc:	f240 63ed 	movw	r3, #1773	; 0x6ed
 8001300:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001304:	4798      	blx	r3
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 8001306:	69bb      	ldr	r3, [r7, #24]
}
 8001308:	4618      	mov	r0, r3
 800130a:	f107 0728 	add.w	r7, r7, #40	; 0x28
 800130e:	46bd      	mov	sp, r7
 8001310:	bd80      	pop	{r7, pc}
 8001312:	bf00      	nop

08001314 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8001314:	b580      	push	{r7, lr}
 8001316:	b086      	sub	sp, #24
 8001318:	af00      	add	r7, sp, #0
 800131a:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
 800131c:	687b      	ldr	r3, [r7, #4]
 800131e:	60bb      	str	r3, [r7, #8]
xBlockLink *pxLink;

	if( pv )
 8001320:	687b      	ldr	r3, [r7, #4]
 8001322:	2b00      	cmp	r3, #0
 8001324:	d03b      	beq.n	800139e <vPortFree+0x8a>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 8001326:	f244 037c 	movw	r3, #16508	; 0x407c
 800132a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800132e:	881b      	ldrh	r3, [r3, #0]
 8001330:	f1c3 0300 	rsb	r3, r3, #0
 8001334:	68ba      	ldr	r2, [r7, #8]
 8001336:	4413      	add	r3, r2
 8001338:	60bb      	str	r3, [r7, #8]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 800133a:	68bb      	ldr	r3, [r7, #8]
 800133c:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
 800133e:	f240 63c9 	movw	r3, #1737	; 0x6c9
 8001342:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001346:	4798      	blx	r3
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 8001348:	68fb      	ldr	r3, [r7, #12]
 800134a:	685b      	ldr	r3, [r3, #4]
 800134c:	617b      	str	r3, [r7, #20]
 800134e:	f642 23b0 	movw	r3, #10928	; 0x2ab0
 8001352:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001356:	613b      	str	r3, [r7, #16]
 8001358:	e002      	b.n	8001360 <vPortFree+0x4c>
 800135a:	693b      	ldr	r3, [r7, #16]
 800135c:	681b      	ldr	r3, [r3, #0]
 800135e:	613b      	str	r3, [r7, #16]
 8001360:	693b      	ldr	r3, [r7, #16]
 8001362:	681b      	ldr	r3, [r3, #0]
 8001364:	685a      	ldr	r2, [r3, #4]
 8001366:	697b      	ldr	r3, [r7, #20]
 8001368:	429a      	cmp	r2, r3
 800136a:	d3f6      	bcc.n	800135a <vPortFree+0x46>
 800136c:	693b      	ldr	r3, [r7, #16]
 800136e:	681a      	ldr	r2, [r3, #0]
 8001370:	68fb      	ldr	r3, [r7, #12]
 8001372:	601a      	str	r2, [r3, #0]
 8001374:	693b      	ldr	r3, [r7, #16]
 8001376:	68fa      	ldr	r2, [r7, #12]
 8001378:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
 800137a:	68fb      	ldr	r3, [r7, #12]
 800137c:	685a      	ldr	r2, [r3, #4]
 800137e:	f642 23c0 	movw	r3, #10944	; 0x2ac0
 8001382:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001386:	681b      	ldr	r3, [r3, #0]
 8001388:	441a      	add	r2, r3
 800138a:	f642 23c0 	movw	r3, #10944	; 0x2ac0
 800138e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001392:	601a      	str	r2, [r3, #0]
		}
		xTaskResumeAll();
 8001394:	f240 63ed 	movw	r3, #1773	; 0x6ed
 8001398:	f6c0 0300 	movt	r3, #2048	; 0x800
 800139c:	4798      	blx	r3
	}
}
 800139e:	f107 0718 	add.w	r7, r7, #24
 80013a2:	46bd      	mov	sp, r7
 80013a4:	bd80      	pop	{r7, pc}
 80013a6:	bf00      	nop

080013a8 <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *   the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 80013a8:	b480      	push	{r7}
 80013aa:	b085      	sub	sp, #20
 80013ac:	af00      	add	r7, sp, #0
 80013ae:	6078      	str	r0, [r7, #4]
 80013b0:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg1 = 0;
 80013b2:	f04f 0300 	mov.w	r3, #0
 80013b6:	60bb      	str	r3, [r7, #8]
  uint8_t tmpreg2 = 0;
 80013b8:	f04f 0300 	mov.w	r3, #0
 80013bc:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));

  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 80013be:	687b      	ldr	r3, [r7, #4]
 80013c0:	685b      	ldr	r3, [r3, #4]
 80013c2:	60bb      	str	r3, [r7, #8]
  /* Clear DUALMOD and SCAN bits */
  tmpreg1 &= CR1_CLEAR_Mask;
 80013c4:	68bb      	ldr	r3, [r7, #8]
 80013c6:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 80013ca:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80013ce:	60bb      	str	r3, [r7, #8]
  /* Configure ADCx: Dual mode and scan conversion mode */
  /* Set DUALMOD bits according to ADC_Mode value */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
 80013d0:	683b      	ldr	r3, [r7, #0]
 80013d2:	681a      	ldr	r2, [r3, #0]
 80013d4:	683b      	ldr	r3, [r7, #0]
 80013d6:	791b      	ldrb	r3, [r3, #4]
 80013d8:	ea4f 2303 	mov.w	r3, r3, lsl #8
 80013dc:	ea42 0303 	orr.w	r3, r2, r3
 80013e0:	68ba      	ldr	r2, [r7, #8]
 80013e2:	ea42 0303 	orr.w	r3, r2, r3
 80013e6:	60bb      	str	r3, [r7, #8]
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 80013e8:	687b      	ldr	r3, [r7, #4]
 80013ea:	68ba      	ldr	r2, [r7, #8]
 80013ec:	605a      	str	r2, [r3, #4]

  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 80013ee:	687b      	ldr	r3, [r7, #4]
 80013f0:	689b      	ldr	r3, [r3, #8]
 80013f2:	60bb      	str	r3, [r7, #8]
  /* Clear CONT, ALIGN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_Mask;
 80013f4:	68ba      	ldr	r2, [r7, #8]
 80013f6:	f24f 73fd 	movw	r3, #63485	; 0xf7fd
 80013fa:	f6cf 73f1 	movt	r3, #65521	; 0xfff1
 80013fe:	ea02 0303 	and.w	r3, r2, r3
 8001402:	60bb      	str	r3, [r7, #8]
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8001404:	683b      	ldr	r3, [r7, #0]
 8001406:	68da      	ldr	r2, [r3, #12]
 8001408:	683b      	ldr	r3, [r7, #0]
 800140a:	689b      	ldr	r3, [r3, #8]
 800140c:	ea42 0203 	orr.w	r2, r2, r3
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 8001410:	683b      	ldr	r3, [r7, #0]
 8001412:	795b      	ldrb	r3, [r3, #5]
 8001414:	ea4f 0343 	mov.w	r3, r3, lsl #1
  tmpreg1 &= CR2_CLEAR_Mask;
  /* Configure ADCx: external trigger event and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 8001418:	ea42 0303 	orr.w	r3, r2, r3
 800141c:	68ba      	ldr	r2, [r7, #8]
 800141e:	ea42 0303 	orr.w	r3, r2, r3
 8001422:	60bb      	str	r3, [r7, #8]
            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8001424:	687b      	ldr	r3, [r7, #4]
 8001426:	68ba      	ldr	r2, [r7, #8]
 8001428:	609a      	str	r2, [r3, #8]

  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 800142a:	687b      	ldr	r3, [r7, #4]
 800142c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800142e:	60bb      	str	r3, [r7, #8]
  /* Clear L bits */
  tmpreg1 &= SQR1_CLEAR_Mask;
 8001430:	68bb      	ldr	r3, [r7, #8]
 8001432:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8001436:	60bb      	str	r3, [r7, #8]
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfChannel value */
  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
 8001438:	683b      	ldr	r3, [r7, #0]
 800143a:	7c1b      	ldrb	r3, [r3, #16]
 800143c:	f103 33ff 	add.w	r3, r3, #4294967295
 8001440:	b2da      	uxtb	r2, r3
 8001442:	7bfb      	ldrb	r3, [r7, #15]
 8001444:	ea42 0303 	orr.w	r3, r2, r3
 8001448:	73fb      	strb	r3, [r7, #15]
  tmpreg1 |= (uint32_t)tmpreg2 << 20;
 800144a:	7bfb      	ldrb	r3, [r7, #15]
 800144c:	ea4f 5303 	mov.w	r3, r3, lsl #20
 8001450:	68ba      	ldr	r2, [r7, #8]
 8001452:	ea42 0303 	orr.w	r3, r2, r3
 8001456:	60bb      	str	r3, [r7, #8]
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8001458:	687b      	ldr	r3, [r7, #4]
 800145a:	68ba      	ldr	r2, [r7, #8]
 800145c:	62da      	str	r2, [r3, #44]	; 0x2c
}
 800145e:	f107 0714 	add.w	r7, r7, #20
 8001462:	46bd      	mov	sp, r7
 8001464:	bc80      	pop	{r7}
 8001466:	4770      	bx	lr

08001468 <ADC_Cmd>:
  * @param  NewState: new state of the ADCx peripheral.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8001468:	b480      	push	{r7}
 800146a:	b083      	sub	sp, #12
 800146c:	af00      	add	r7, sp, #0
 800146e:	6078      	str	r0, [r7, #4]
 8001470:	460b      	mov	r3, r1
 8001472:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001474:	78fb      	ldrb	r3, [r7, #3]
 8001476:	2b00      	cmp	r3, #0
 8001478:	d006      	beq.n	8001488 <ADC_Cmd+0x20>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= CR2_ADON_Set;
 800147a:	687b      	ldr	r3, [r7, #4]
 800147c:	689b      	ldr	r3, [r3, #8]
 800147e:	f043 0201 	orr.w	r2, r3, #1
 8001482:	687b      	ldr	r3, [r7, #4]
 8001484:	609a      	str	r2, [r3, #8]
 8001486:	e005      	b.n	8001494 <ADC_Cmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= CR2_ADON_Reset;
 8001488:	687b      	ldr	r3, [r7, #4]
 800148a:	689b      	ldr	r3, [r3, #8]
 800148c:	f023 0201 	bic.w	r2, r3, #1
 8001490:	687b      	ldr	r3, [r7, #4]
 8001492:	609a      	str	r2, [r3, #8]
  }
}
 8001494:	f107 070c 	add.w	r7, r7, #12
 8001498:	46bd      	mov	sp, r7
 800149a:	bc80      	pop	{r7}
 800149c:	4770      	bx	lr
 800149e:	bf00      	nop

080014a0 <ADC_DMACmd>:
  * @param  NewState: new state of the selected ADC DMA transfer.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 80014a0:	b480      	push	{r7}
 80014a2:	b083      	sub	sp, #12
 80014a4:	af00      	add	r7, sp, #0
 80014a6:	6078      	str	r0, [r7, #4]
 80014a8:	460b      	mov	r3, r1
 80014aa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80014ac:	78fb      	ldrb	r3, [r7, #3]
 80014ae:	2b00      	cmp	r3, #0
 80014b0:	d006      	beq.n	80014c0 <ADC_DMACmd+0x20>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= CR2_DMA_Set;
 80014b2:	687b      	ldr	r3, [r7, #4]
 80014b4:	689b      	ldr	r3, [r3, #8]
 80014b6:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 80014ba:	687b      	ldr	r3, [r7, #4]
 80014bc:	609a      	str	r2, [r3, #8]
 80014be:	e005      	b.n	80014cc <ADC_DMACmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= CR2_DMA_Reset;
 80014c0:	687b      	ldr	r3, [r7, #4]
 80014c2:	689b      	ldr	r3, [r3, #8]
 80014c4:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 80014c8:	687b      	ldr	r3, [r7, #4]
 80014ca:	609a      	str	r2, [r3, #8]
  }
}
 80014cc:	f107 070c 	add.w	r7, r7, #12
 80014d0:	46bd      	mov	sp, r7
 80014d2:	bc80      	pop	{r7}
 80014d4:	4770      	bx	lr
 80014d6:	bf00      	nop

080014d8 <ADC_ResetCalibration>:
  * @brief  Resets the selected ADC calibration registers.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_ResetCalibration(ADC_TypeDef* ADCx)
{
 80014d8:	b480      	push	{r7}
 80014da:	b083      	sub	sp, #12
 80014dc:	af00      	add	r7, sp, #0
 80014de:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Resets the selected ADC calibartion registers */  
  ADCx->CR2 |= CR2_RSTCAL_Set;
 80014e0:	687b      	ldr	r3, [r7, #4]
 80014e2:	689b      	ldr	r3, [r3, #8]
 80014e4:	f043 0208 	orr.w	r2, r3, #8
 80014e8:	687b      	ldr	r3, [r7, #4]
 80014ea:	609a      	str	r2, [r3, #8]
}
 80014ec:	f107 070c 	add.w	r7, r7, #12
 80014f0:	46bd      	mov	sp, r7
 80014f2:	bc80      	pop	{r7}
 80014f4:	4770      	bx	lr
 80014f6:	bf00      	nop

080014f8 <ADC_GetResetCalibrationStatus>:
  * @brief  Gets the selected ADC reset calibration registers status.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The new state of ADC reset calibration registers (SET or RESET).
  */
FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
{
 80014f8:	b480      	push	{r7}
 80014fa:	b085      	sub	sp, #20
 80014fc:	af00      	add	r7, sp, #0
 80014fe:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8001500:	f04f 0300 	mov.w	r3, #0
 8001504:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of RSTCAL bit */
  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
 8001506:	687b      	ldr	r3, [r7, #4]
 8001508:	689b      	ldr	r3, [r3, #8]
 800150a:	f003 0308 	and.w	r3, r3, #8
 800150e:	2b00      	cmp	r3, #0
 8001510:	d003      	beq.n	800151a <ADC_GetResetCalibrationStatus+0x22>
  {
    /* RSTCAL bit is set */
    bitstatus = SET;
 8001512:	f04f 0301 	mov.w	r3, #1
 8001516:	73fb      	strb	r3, [r7, #15]
 8001518:	e002      	b.n	8001520 <ADC_GetResetCalibrationStatus+0x28>
  }
  else
  {
    /* RSTCAL bit is reset */
    bitstatus = RESET;
 800151a:	f04f 0300 	mov.w	r3, #0
 800151e:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the RSTCAL bit status */
  return  bitstatus;
 8001520:	7bfb      	ldrb	r3, [r7, #15]
}
 8001522:	4618      	mov	r0, r3
 8001524:	f107 0714 	add.w	r7, r7, #20
 8001528:	46bd      	mov	sp, r7
 800152a:	bc80      	pop	{r7}
 800152c:	4770      	bx	lr
 800152e:	bf00      	nop

08001530 <ADC_StartCalibration>:
  * @brief  Starts the selected ADC calibration process.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_StartCalibration(ADC_TypeDef* ADCx)
{
 8001530:	b480      	push	{r7}
 8001532:	b083      	sub	sp, #12
 8001534:	af00      	add	r7, sp, #0
 8001536:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC calibration process */  
  ADCx->CR2 |= CR2_CAL_Set;
 8001538:	687b      	ldr	r3, [r7, #4]
 800153a:	689b      	ldr	r3, [r3, #8]
 800153c:	f043 0204 	orr.w	r2, r3, #4
 8001540:	687b      	ldr	r3, [r7, #4]
 8001542:	609a      	str	r2, [r3, #8]
}
 8001544:	f107 070c 	add.w	r7, r7, #12
 8001548:	46bd      	mov	sp, r7
 800154a:	bc80      	pop	{r7}
 800154c:	4770      	bx	lr
 800154e:	bf00      	nop

08001550 <ADC_GetCalibrationStatus>:
  * @brief  Gets the selected ADC calibration status.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The new state of ADC calibration (SET or RESET).
  */
FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
{
 8001550:	b480      	push	{r7}
 8001552:	b085      	sub	sp, #20
 8001554:	af00      	add	r7, sp, #0
 8001556:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
 8001558:	f04f 0300 	mov.w	r3, #0
 800155c:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of CAL bit */
  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
 800155e:	687b      	ldr	r3, [r7, #4]
 8001560:	689b      	ldr	r3, [r3, #8]
 8001562:	f003 0304 	and.w	r3, r3, #4
 8001566:	2b00      	cmp	r3, #0
 8001568:	d003      	beq.n	8001572 <ADC_GetCalibrationStatus+0x22>
  {
    /* CAL bit is set: calibration on going */
    bitstatus = SET;
 800156a:	f04f 0301 	mov.w	r3, #1
 800156e:	73fb      	strb	r3, [r7, #15]
 8001570:	e002      	b.n	8001578 <ADC_GetCalibrationStatus+0x28>
  }
  else
  {
    /* CAL bit is reset: end of calibration */
    bitstatus = RESET;
 8001572:	f04f 0300 	mov.w	r3, #0
 8001576:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the CAL bit status */
  return  bitstatus;
 8001578:	7bfb      	ldrb	r3, [r7, #15]
}
 800157a:	4618      	mov	r0, r3
 800157c:	f107 0714 	add.w	r7, r7, #20
 8001580:	46bd      	mov	sp, r7
 8001582:	bc80      	pop	{r7}
 8001584:	4770      	bx	lr
 8001586:	bf00      	nop

08001588 <ADC_SoftwareStartConvCmd>:
  * @param  NewState: new state of the selected ADC software start conversion.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8001588:	b480      	push	{r7}
 800158a:	b083      	sub	sp, #12
 800158c:	af00      	add	r7, sp, #0
 800158e:	6078      	str	r0, [r7, #4]
 8001590:	460b      	mov	r3, r1
 8001592:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001594:	78fb      	ldrb	r3, [r7, #3]
 8001596:	2b00      	cmp	r3, #0
 8001598:	d006      	beq.n	80015a8 <ADC_SoftwareStartConvCmd+0x20>
  {
    /* Enable the selected ADC conversion on external event and start the selected
       ADC conversion */
    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
 800159a:	687b      	ldr	r3, [r7, #4]
 800159c:	689b      	ldr	r3, [r3, #8]
 800159e:	f443 02a0 	orr.w	r2, r3, #5242880	; 0x500000
 80015a2:	687b      	ldr	r3, [r7, #4]
 80015a4:	609a      	str	r2, [r3, #8]
 80015a6:	e005      	b.n	80015b4 <ADC_SoftwareStartConvCmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC conversion on external event and stop the selected
       ADC conversion */
    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
 80015a8:	687b      	ldr	r3, [r7, #4]
 80015aa:	689b      	ldr	r3, [r3, #8]
 80015ac:	f423 02a0 	bic.w	r2, r3, #5242880	; 0x500000
 80015b0:	687b      	ldr	r3, [r7, #4]
 80015b2:	609a      	str	r2, [r3, #8]
  }
}
 80015b4:	f107 070c 	add.w	r7, r7, #12
 80015b8:	46bd      	mov	sp, r7
 80015ba:	bc80      	pop	{r7}
 80015bc:	4770      	bx	lr
 80015be:	bf00      	nop

080015c0 <ADC_RegularChannelConfig>:
  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80015c0:	b480      	push	{r7}
 80015c2:	b085      	sub	sp, #20
 80015c4:	af00      	add	r7, sp, #0
 80015c6:	6078      	str	r0, [r7, #4]
 80015c8:	70f9      	strb	r1, [r7, #3]
 80015ca:	70ba      	strb	r2, [r7, #2]
 80015cc:	707b      	strb	r3, [r7, #1]
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
 80015ce:	f04f 0300 	mov.w	r3, #0
 80015d2:	60bb      	str	r3, [r7, #8]
 80015d4:	f04f 0300 	mov.w	r3, #0
 80015d8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
  if (ADC_Channel > ADC_Channel_9)
 80015da:	78fb      	ldrb	r3, [r7, #3]
 80015dc:	2b09      	cmp	r3, #9
 80015de:	d929      	bls.n	8001634 <ADC_RegularChannelConfig+0x74>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 80015e0:	687b      	ldr	r3, [r7, #4]
 80015e2:	68db      	ldr	r3, [r3, #12]
 80015e4:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
 80015e6:	78fa      	ldrb	r2, [r7, #3]
 80015e8:	4613      	mov	r3, r2
 80015ea:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80015ee:	4413      	add	r3, r2
 80015f0:	f1a3 031e 	sub.w	r3, r3, #30
 80015f4:	f04f 0207 	mov.w	r2, #7
 80015f8:	fa02 f303 	lsl.w	r3, r2, r3
 80015fc:	60fb      	str	r3, [r7, #12]
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
 80015fe:	68fb      	ldr	r3, [r7, #12]
 8001600:	ea6f 0303 	mvn.w	r3, r3
 8001604:	68ba      	ldr	r2, [r7, #8]
 8001606:	ea02 0303 	and.w	r3, r2, r3
 800160a:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 800160c:	7879      	ldrb	r1, [r7, #1]
 800160e:	78fa      	ldrb	r2, [r7, #3]
 8001610:	4613      	mov	r3, r2
 8001612:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001616:	4413      	add	r3, r2
 8001618:	f1a3 031e 	sub.w	r3, r3, #30
 800161c:	fa01 f303 	lsl.w	r3, r1, r3
 8001620:	60fb      	str	r3, [r7, #12]
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
 8001622:	68ba      	ldr	r2, [r7, #8]
 8001624:	68fb      	ldr	r3, [r7, #12]
 8001626:	ea42 0303 	orr.w	r3, r2, r3
 800162a:	60bb      	str	r3, [r7, #8]
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 800162c:	687b      	ldr	r3, [r7, #4]
 800162e:	68ba      	ldr	r2, [r7, #8]
 8001630:	60da      	str	r2, [r3, #12]
 8001632:	e024      	b.n	800167e <ADC_RegularChannelConfig+0xbe>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8001634:	687b      	ldr	r3, [r7, #4]
 8001636:	691b      	ldr	r3, [r3, #16]
 8001638:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
 800163a:	78fa      	ldrb	r2, [r7, #3]
 800163c:	4613      	mov	r3, r2
 800163e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001642:	4413      	add	r3, r2
 8001644:	f04f 0207 	mov.w	r2, #7
 8001648:	fa02 f303 	lsl.w	r3, r2, r3
 800164c:	60fb      	str	r3, [r7, #12]
    /* Clear the old channel sample time */
    tmpreg1 &= ~tmpreg2;
 800164e:	68fb      	ldr	r3, [r7, #12]
 8001650:	ea6f 0303 	mvn.w	r3, r3
 8001654:	68ba      	ldr	r2, [r7, #8]
 8001656:	ea02 0303 	and.w	r3, r2, r3
 800165a:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 800165c:	7879      	ldrb	r1, [r7, #1]
 800165e:	78fa      	ldrb	r2, [r7, #3]
 8001660:	4613      	mov	r3, r2
 8001662:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001666:	4413      	add	r3, r2
 8001668:	fa01 f303 	lsl.w	r3, r1, r3
 800166c:	60fb      	str	r3, [r7, #12]
    /* Set the new channel sample time */
    tmpreg1 |= tmpreg2;
 800166e:	68ba      	ldr	r2, [r7, #8]
 8001670:	68fb      	ldr	r3, [r7, #12]
 8001672:	ea42 0303 	orr.w	r3, r2, r3
 8001676:	60bb      	str	r3, [r7, #8]
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8001678:	687b      	ldr	r3, [r7, #4]
 800167a:	68ba      	ldr	r2, [r7, #8]
 800167c:	611a      	str	r2, [r3, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 800167e:	78bb      	ldrb	r3, [r7, #2]
 8001680:	2b06      	cmp	r3, #6
 8001682:	d829      	bhi.n	80016d8 <ADC_RegularChannelConfig+0x118>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8001684:	687b      	ldr	r3, [r7, #4]
 8001686:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001688:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
 800168a:	78bb      	ldrb	r3, [r7, #2]
 800168c:	f103 32ff 	add.w	r2, r3, #4294967295
 8001690:	4613      	mov	r3, r2
 8001692:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001696:	4413      	add	r3, r2
 8001698:	f04f 021f 	mov.w	r2, #31
 800169c:	fa02 f303 	lsl.w	r3, r2, r3
 80016a0:	60fb      	str	r3, [r7, #12]
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80016a2:	68fb      	ldr	r3, [r7, #12]
 80016a4:	ea6f 0303 	mvn.w	r3, r3
 80016a8:	68ba      	ldr	r2, [r7, #8]
 80016aa:	ea02 0303 	and.w	r3, r2, r3
 80016ae:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 80016b0:	78f9      	ldrb	r1, [r7, #3]
 80016b2:	78bb      	ldrb	r3, [r7, #2]
 80016b4:	f103 32ff 	add.w	r2, r3, #4294967295
 80016b8:	4613      	mov	r3, r2
 80016ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80016be:	4413      	add	r3, r2
 80016c0:	fa01 f303 	lsl.w	r3, r1, r3
 80016c4:	60fb      	str	r3, [r7, #12]
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80016c6:	68ba      	ldr	r2, [r7, #8]
 80016c8:	68fb      	ldr	r3, [r7, #12]
 80016ca:	ea42 0303 	orr.w	r3, r2, r3
 80016ce:	60bb      	str	r3, [r7, #8]
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 80016d0:	687b      	ldr	r3, [r7, #4]
 80016d2:	68ba      	ldr	r2, [r7, #8]
 80016d4:	635a      	str	r2, [r3, #52]	; 0x34
 80016d6:	e055      	b.n	8001784 <ADC_RegularChannelConfig+0x1c4>
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 80016d8:	78bb      	ldrb	r3, [r7, #2]
 80016da:	2b0c      	cmp	r3, #12
 80016dc:	d829      	bhi.n	8001732 <ADC_RegularChannelConfig+0x172>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 80016de:	687b      	ldr	r3, [r7, #4]
 80016e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80016e2:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
 80016e4:	78ba      	ldrb	r2, [r7, #2]
 80016e6:	4613      	mov	r3, r2
 80016e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80016ec:	4413      	add	r3, r2
 80016ee:	f1a3 0323 	sub.w	r3, r3, #35	; 0x23
 80016f2:	f04f 021f 	mov.w	r2, #31
 80016f6:	fa02 f303 	lsl.w	r3, r2, r3
 80016fa:	60fb      	str	r3, [r7, #12]
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80016fc:	68fb      	ldr	r3, [r7, #12]
 80016fe:	ea6f 0303 	mvn.w	r3, r3
 8001702:	68ba      	ldr	r2, [r7, #8]
 8001704:	ea02 0303 	and.w	r3, r2, r3
 8001708:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 800170a:	78f9      	ldrb	r1, [r7, #3]
 800170c:	78ba      	ldrb	r2, [r7, #2]
 800170e:	4613      	mov	r3, r2
 8001710:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001714:	4413      	add	r3, r2
 8001716:	f1a3 0323 	sub.w	r3, r3, #35	; 0x23
 800171a:	fa01 f303 	lsl.w	r3, r1, r3
 800171e:	60fb      	str	r3, [r7, #12]
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8001720:	68ba      	ldr	r2, [r7, #8]
 8001722:	68fb      	ldr	r3, [r7, #12]
 8001724:	ea42 0303 	orr.w	r3, r2, r3
 8001728:	60bb      	str	r3, [r7, #8]
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 800172a:	687b      	ldr	r3, [r7, #4]
 800172c:	68ba      	ldr	r2, [r7, #8]
 800172e:	631a      	str	r2, [r3, #48]	; 0x30
 8001730:	e028      	b.n	8001784 <ADC_RegularChannelConfig+0x1c4>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8001732:	687b      	ldr	r3, [r7, #4]
 8001734:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001736:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
 8001738:	78ba      	ldrb	r2, [r7, #2]
 800173a:	4613      	mov	r3, r2
 800173c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001740:	4413      	add	r3, r2
 8001742:	f1a3 0341 	sub.w	r3, r3, #65	; 0x41
 8001746:	f04f 021f 	mov.w	r2, #31
 800174a:	fa02 f303 	lsl.w	r3, r2, r3
 800174e:	60fb      	str	r3, [r7, #12]
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8001750:	68fb      	ldr	r3, [r7, #12]
 8001752:	ea6f 0303 	mvn.w	r3, r3
 8001756:	68ba      	ldr	r2, [r7, #8]
 8001758:	ea02 0303 	and.w	r3, r2, r3
 800175c:	60bb      	str	r3, [r7, #8]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 800175e:	78f9      	ldrb	r1, [r7, #3]
 8001760:	78ba      	ldrb	r2, [r7, #2]
 8001762:	4613      	mov	r3, r2
 8001764:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001768:	4413      	add	r3, r2
 800176a:	f1a3 0341 	sub.w	r3, r3, #65	; 0x41
 800176e:	fa01 f303 	lsl.w	r3, r1, r3
 8001772:	60fb      	str	r3, [r7, #12]
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8001774:	68ba      	ldr	r2, [r7, #8]
 8001776:	68fb      	ldr	r3, [r7, #12]
 8001778:	ea42 0303 	orr.w	r3, r2, r3
 800177c:	60bb      	str	r3, [r7, #8]
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 800177e:	687b      	ldr	r3, [r7, #4]
 8001780:	68ba      	ldr	r2, [r7, #8]
 8001782:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
 8001784:	f107 0714 	add.w	r7, r7, #20
 8001788:	46bd      	mov	sp, r7
 800178a:	bc80      	pop	{r7}
 800178c:	4770      	bx	lr
 800178e:	bf00      	nop

08001790 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8001790:	b580      	push	{r7, lr}
 8001792:	b08c      	sub	sp, #48	; 0x30
 8001794:	af00      	add	r7, sp, #0
 8001796:	6078      	str	r0, [r7, #4]
 8001798:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00, apbclock = 0x00;
 800179a:	f04f 0300 	mov.w	r3, #0
 800179e:	61fb      	str	r3, [r7, #28]
 80017a0:	f04f 0300 	mov.w	r3, #0
 80017a4:	623b      	str	r3, [r7, #32]
  uint32_t integerdivider = 0x00;
 80017a6:	f04f 0300 	mov.w	r3, #0
 80017aa:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t fractionaldivider = 0x00;
 80017ac:	f04f 0300 	mov.w	r3, #0
 80017b0:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t usartxbase = 0;
 80017b2:	f04f 0300 	mov.w	r3, #0
 80017b6:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }

  usartxbase = (uint32_t)USARTx;
 80017b8:	687b      	ldr	r3, [r7, #4]
 80017ba:	62fb      	str	r3, [r7, #44]	; 0x2c

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80017bc:	687b      	ldr	r3, [r7, #4]
 80017be:	8a1b      	ldrh	r3, [r3, #16]
 80017c0:	b29b      	uxth	r3, r3
 80017c2:	61fb      	str	r3, [r7, #28]
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
 80017c4:	69fa      	ldr	r2, [r7, #28]
 80017c6:	f64c 73ff 	movw	r3, #53247	; 0xcfff
 80017ca:	f2c0 0300 	movt	r3, #0
 80017ce:	ea02 0303 	and.w	r3, r2, r3
 80017d2:	61fb      	str	r3, [r7, #28]
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 80017d4:	683b      	ldr	r3, [r7, #0]
 80017d6:	88db      	ldrh	r3, [r3, #6]
 80017d8:	69fa      	ldr	r2, [r7, #28]
 80017da:	ea42 0303 	orr.w	r3, r2, r3
 80017de:	61fb      	str	r3, [r7, #28]
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80017e0:	69fb      	ldr	r3, [r7, #28]
 80017e2:	b29a      	uxth	r2, r3
 80017e4:	687b      	ldr	r3, [r7, #4]
 80017e6:	821a      	strh	r2, [r3, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 80017e8:	687b      	ldr	r3, [r7, #4]
 80017ea:	899b      	ldrh	r3, [r3, #12]
 80017ec:	b29b      	uxth	r3, r3
 80017ee:	61fb      	str	r3, [r7, #28]
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 80017f0:	69fa      	ldr	r2, [r7, #28]
 80017f2:	f64e 13f3 	movw	r3, #59891	; 0xe9f3
 80017f6:	f2c0 0300 	movt	r3, #0
 80017fa:	ea02 0303 	and.w	r3, r2, r3
 80017fe:	61fb      	str	r3, [r7, #28]
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8001800:	683b      	ldr	r3, [r7, #0]
 8001802:	889a      	ldrh	r2, [r3, #4]
 8001804:	683b      	ldr	r3, [r7, #0]
 8001806:	891b      	ldrh	r3, [r3, #8]
 8001808:	ea42 0303 	orr.w	r3, r2, r3
 800180c:	b29a      	uxth	r2, r3
 800180e:	683b      	ldr	r3, [r7, #0]
 8001810:	895b      	ldrh	r3, [r3, #10]
 8001812:	ea42 0303 	orr.w	r3, r2, r3
 8001816:	b29b      	uxth	r3, r3
 8001818:	69fa      	ldr	r2, [r7, #28]
 800181a:	ea42 0303 	orr.w	r3, r2, r3
 800181e:	61fb      	str	r3, [r7, #28]
            USART_InitStruct->USART_Mode;
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8001820:	69fb      	ldr	r3, [r7, #28]
 8001822:	b29a      	uxth	r2, r3
 8001824:	687b      	ldr	r3, [r7, #4]
 8001826:	819a      	strh	r2, [r3, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8001828:	687b      	ldr	r3, [r7, #4]
 800182a:	8a9b      	ldrh	r3, [r3, #20]
 800182c:	b29b      	uxth	r3, r3
 800182e:	61fb      	str	r3, [r7, #28]
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
 8001830:	69fa      	ldr	r2, [r7, #28]
 8001832:	f64f 43ff 	movw	r3, #64767	; 0xfcff
 8001836:	f2c0 0300 	movt	r3, #0
 800183a:	ea02 0303 	and.w	r3, r2, r3
 800183e:	61fb      	str	r3, [r7, #28]
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8001840:	683b      	ldr	r3, [r7, #0]
 8001842:	899b      	ldrh	r3, [r3, #12]
 8001844:	69fa      	ldr	r2, [r7, #28]
 8001846:	ea42 0303 	orr.w	r3, r2, r3
 800184a:	61fb      	str	r3, [r7, #28]
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 800184c:	69fb      	ldr	r3, [r7, #28]
 800184e:	b29a      	uxth	r2, r3
 8001850:	687b      	ldr	r3, [r7, #4]
 8001852:	829a      	strh	r2, [r3, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8001854:	f107 0308 	add.w	r3, r7, #8
 8001858:	4618      	mov	r0, r3
 800185a:	f641 73d9 	movw	r3, #8153	; 0x1fd9
 800185e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001862:	4798      	blx	r3
  if (usartxbase == USART1_BASE)
 8001864:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8001866:	f643 0300 	movw	r3, #14336	; 0x3800
 800186a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800186e:	429a      	cmp	r2, r3
 8001870:	d102      	bne.n	8001878 <USART_Init+0xe8>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8001872:	697b      	ldr	r3, [r7, #20]
 8001874:	623b      	str	r3, [r7, #32]
 8001876:	e001      	b.n	800187c <USART_Init+0xec>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8001878:	693b      	ldr	r3, [r7, #16]
 800187a:	623b      	str	r3, [r7, #32]
  }
#ifdef MOD_MTHOMAS_STMLIB
  /* proposed by "A.K." in the mikrocontroller.net forum: */
  USARTx->BRR = ((2 * apbclock) / (USART_InitStruct->USART_BaudRate) + 1) / 2;
 800187c:	6a3b      	ldr	r3, [r7, #32]
 800187e:	ea4f 0243 	mov.w	r2, r3, lsl #1
 8001882:	683b      	ldr	r3, [r7, #0]
 8001884:	681b      	ldr	r3, [r3, #0]
 8001886:	fbb2 f3f3 	udiv	r3, r2, r3
 800188a:	f103 0301 	add.w	r3, r3, #1
 800188e:	ea4f 0353 	mov.w	r3, r3, lsr #1
 8001892:	b29a      	uxth	r2, r3
 8001894:	687b      	ldr	r3, [r7, #4]
 8001896:	811a      	strh	r2, [r3, #8]
  /* avoid "unused" warning: */
  fractionaldivider = integerdivider = 0x00;
 8001898:	f04f 0300 	mov.w	r3, #0
 800189c:	627b      	str	r3, [r7, #36]	; 0x24
 800189e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80018a0:	62bb      	str	r3, [r7, #40]	; 0x28
  fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
  tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((uint8_t)0x0F);
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
#endif
}
 80018a2:	f107 0730 	add.w	r7, r7, #48	; 0x30
 80018a6:	46bd      	mov	sp, r7
 80018a8:	bd80      	pop	{r7, pc}
 80018aa:	bf00      	nop

080018ac <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 80018ac:	b480      	push	{r7}
 80018ae:	b083      	sub	sp, #12
 80018b0:	af00      	add	r7, sp, #0
 80018b2:	6078      	str	r0, [r7, #4]
 80018b4:	460b      	mov	r3, r1
 80018b6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80018b8:	78fb      	ldrb	r3, [r7, #3]
 80018ba:	2b00      	cmp	r3, #0
 80018bc:	d008      	beq.n	80018d0 <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 80018be:	687b      	ldr	r3, [r7, #4]
 80018c0:	899b      	ldrh	r3, [r3, #12]
 80018c2:	b29b      	uxth	r3, r3
 80018c4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80018c8:	b29a      	uxth	r2, r3
 80018ca:	687b      	ldr	r3, [r7, #4]
 80018cc:	819a      	strh	r2, [r3, #12]
 80018ce:	e00c      	b.n	80018ea <USART_Cmd+0x3e>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
 80018d0:	687b      	ldr	r3, [r7, #4]
 80018d2:	899b      	ldrh	r3, [r3, #12]
 80018d4:	b29b      	uxth	r3, r3
 80018d6:	461a      	mov	r2, r3
 80018d8:	f64d 73ff 	movw	r3, #57343	; 0xdfff
 80018dc:	f2c0 0300 	movt	r3, #0
 80018e0:	ea02 0303 	and.w	r3, r2, r3
 80018e4:	461a      	mov	r2, r3
 80018e6:	687b      	ldr	r3, [r7, #4]
 80018e8:	819a      	strh	r2, [r3, #12]
  }
}
 80018ea:	f107 070c 	add.w	r7, r7, #12
 80018ee:	46bd      	mov	sp, r7
 80018f0:	bc80      	pop	{r7}
 80018f2:	4770      	bx	lr

080018f4 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 80018f4:	b480      	push	{r7}
 80018f6:	b087      	sub	sp, #28
 80018f8:	af00      	add	r7, sp, #0
 80018fa:	6078      	str	r0, [r7, #4]
 80018fc:	4613      	mov	r3, r2
 80018fe:	460a      	mov	r2, r1
 8001900:	807a      	strh	r2, [r7, #2]
 8001902:	707b      	strb	r3, [r7, #1]
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 8001904:	f04f 0300 	mov.w	r3, #0
 8001908:	60bb      	str	r3, [r7, #8]
 800190a:	f04f 0300 	mov.w	r3, #0
 800190e:	60fb      	str	r3, [r7, #12]
 8001910:	f04f 0300 	mov.w	r3, #0
 8001914:	613b      	str	r3, [r7, #16]
  uint32_t usartxbase = 0x00;
 8001916:	f04f 0300 	mov.w	r3, #0
 800191a:	617b      	str	r3, [r7, #20]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }   
  
  usartxbase = (uint32_t)USARTx;
 800191c:	687b      	ldr	r3, [r7, #4]
 800191e:	617b      	str	r3, [r7, #20]

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8001920:	887b      	ldrh	r3, [r7, #2]
 8001922:	b2db      	uxtb	r3, r3
 8001924:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8001928:	b2db      	uxtb	r3, r3
 800192a:	60bb      	str	r3, [r7, #8]

  /* Get the interrupt position */
  itpos = USART_IT & IT_Mask;
 800192c:	887b      	ldrh	r3, [r7, #2]
 800192e:	f003 031f 	and.w	r3, r3, #31
 8001932:	60fb      	str	r3, [r7, #12]
  itmask = (((uint32_t)0x01) << itpos);
 8001934:	68fb      	ldr	r3, [r7, #12]
 8001936:	f04f 0201 	mov.w	r2, #1
 800193a:	fa02 f303 	lsl.w	r3, r2, r3
 800193e:	613b      	str	r3, [r7, #16]
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8001940:	68bb      	ldr	r3, [r7, #8]
 8001942:	2b01      	cmp	r3, #1
 8001944:	d104      	bne.n	8001950 <USART_ITConfig+0x5c>
  {
    usartxbase += 0x0C;
 8001946:	697b      	ldr	r3, [r7, #20]
 8001948:	f103 030c 	add.w	r3, r3, #12
 800194c:	617b      	str	r3, [r7, #20]
 800194e:	e00b      	b.n	8001968 <USART_ITConfig+0x74>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8001950:	68bb      	ldr	r3, [r7, #8]
 8001952:	2b02      	cmp	r3, #2
 8001954:	d104      	bne.n	8001960 <USART_ITConfig+0x6c>
  {
    usartxbase += 0x10;
 8001956:	697b      	ldr	r3, [r7, #20]
 8001958:	f103 0310 	add.w	r3, r3, #16
 800195c:	617b      	str	r3, [r7, #20]
 800195e:	e003      	b.n	8001968 <USART_ITConfig+0x74>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8001960:	697b      	ldr	r3, [r7, #20]
 8001962:	f103 0314 	add.w	r3, r3, #20
 8001966:	617b      	str	r3, [r7, #20]
  }
  if (NewState != DISABLE)
 8001968:	787b      	ldrb	r3, [r7, #1]
 800196a:	2b00      	cmp	r3, #0
 800196c:	d007      	beq.n	800197e <USART_ITConfig+0x8a>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 800196e:	697b      	ldr	r3, [r7, #20]
 8001970:	697a      	ldr	r2, [r7, #20]
 8001972:	6811      	ldr	r1, [r2, #0]
 8001974:	693a      	ldr	r2, [r7, #16]
 8001976:	ea41 0202 	orr.w	r2, r1, r2
 800197a:	601a      	str	r2, [r3, #0]
 800197c:	e008      	b.n	8001990 <USART_ITConfig+0x9c>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 800197e:	697b      	ldr	r3, [r7, #20]
 8001980:	697a      	ldr	r2, [r7, #20]
 8001982:	6811      	ldr	r1, [r2, #0]
 8001984:	693a      	ldr	r2, [r7, #16]
 8001986:	ea6f 0202 	mvn.w	r2, r2
 800198a:	ea01 0202 	and.w	r2, r1, r2
 800198e:	601a      	str	r2, [r3, #0]
  }
}
 8001990:	f107 071c 	add.w	r7, r7, #28
 8001994:	46bd      	mov	sp, r7
 8001996:	bc80      	pop	{r7}
 8001998:	4770      	bx	lr
 800199a:	bf00      	nop

0800199c <USART_DMACmd>:
  *   This parameter can be: ENABLE or DISABLE.
  * @note The DMA mode is not available for UART5.  
  * @retval None
  */
void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
{
 800199c:	b480      	push	{r7}
 800199e:	b083      	sub	sp, #12
 80019a0:	af00      	add	r7, sp, #0
 80019a2:	6078      	str	r0, [r7, #4]
 80019a4:	4613      	mov	r3, r2
 80019a6:	460a      	mov	r2, r1
 80019a8:	807a      	strh	r2, [r7, #2]
 80019aa:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  if (NewState != DISABLE)
 80019ac:	787b      	ldrb	r3, [r7, #1]
 80019ae:	2b00      	cmp	r3, #0
 80019b0:	d009      	beq.n	80019c6 <USART_DMACmd+0x2a>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 80019b2:	687b      	ldr	r3, [r7, #4]
 80019b4:	8a9b      	ldrh	r3, [r3, #20]
 80019b6:	b29a      	uxth	r2, r3
 80019b8:	887b      	ldrh	r3, [r7, #2]
 80019ba:	ea42 0303 	orr.w	r3, r2, r3
 80019be:	b29a      	uxth	r2, r3
 80019c0:	687b      	ldr	r3, [r7, #4]
 80019c2:	829a      	strh	r2, [r3, #20]
 80019c4:	e00b      	b.n	80019de <USART_DMACmd+0x42>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 80019c6:	687b      	ldr	r3, [r7, #4]
 80019c8:	8a9b      	ldrh	r3, [r3, #20]
 80019ca:	b29a      	uxth	r2, r3
 80019cc:	887b      	ldrh	r3, [r7, #2]
 80019ce:	ea6f 0303 	mvn.w	r3, r3
 80019d2:	b29b      	uxth	r3, r3
 80019d4:	ea02 0303 	and.w	r3, r2, r3
 80019d8:	b29a      	uxth	r2, r3
 80019da:	687b      	ldr	r3, [r7, #4]
 80019dc:	829a      	strh	r2, [r3, #20]
  }
}
 80019de:	f107 070c 	add.w	r7, r7, #12
 80019e2:	46bd      	mov	sp, r7
 80019e4:	bc80      	pop	{r7}
 80019e6:	4770      	bx	lr

080019e8 <FLASH_SetLatency>:
  *     @arg FLASH_Latency_1: FLASH One Latency cycle
  *     @arg FLASH_Latency_2: FLASH Two Latency cycles
  * @retval None
  */
void FLASH_SetLatency(uint32_t FLASH_Latency)
{
 80019e8:	b480      	push	{r7}
 80019ea:	b085      	sub	sp, #20
 80019ec:	af00      	add	r7, sp, #0
 80019ee:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80019f0:	f04f 0300 	mov.w	r3, #0
 80019f4:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));

  /* Read the ACR register */
  tmpreg = FLASH->ACR;
 80019f6:	f242 0300 	movw	r3, #8192	; 0x2000
 80019fa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80019fe:	681b      	ldr	r3, [r3, #0]
 8001a00:	60fb      	str	r3, [r7, #12]

  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 8001a02:	68fb      	ldr	r3, [r7, #12]
 8001a04:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8001a08:	60fb      	str	r3, [r7, #12]
  tmpreg |= FLASH_Latency;
 8001a0a:	68fa      	ldr	r2, [r7, #12]
 8001a0c:	687b      	ldr	r3, [r7, #4]
 8001a0e:	ea42 0303 	orr.w	r3, r2, r3
 8001a12:	60fb      	str	r3, [r7, #12]

  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 8001a14:	f242 0300 	movw	r3, #8192	; 0x2000
 8001a18:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001a1c:	68fa      	ldr	r2, [r7, #12]
 8001a1e:	601a      	str	r2, [r3, #0]
}
 8001a20:	f107 0714 	add.w	r7, r7, #20
 8001a24:	46bd      	mov	sp, r7
 8001a26:	bc80      	pop	{r7}
 8001a28:	4770      	bx	lr
 8001a2a:	bf00      	nop

08001a2c <FLASH_PrefetchBufferCmd>:
  *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
  *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
  * @retval None
  */
void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
{
 8001a2c:	b480      	push	{r7}
 8001a2e:	b083      	sub	sp, #12
 8001a30:	af00      	add	r7, sp, #0
 8001a32:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));

  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 8001a34:	f242 0300 	movw	r3, #8192	; 0x2000
 8001a38:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001a3c:	f242 0200 	movw	r2, #8192	; 0x2000
 8001a40:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001a44:	6812      	ldr	r2, [r2, #0]
 8001a46:	f022 0210 	bic.w	r2, r2, #16
 8001a4a:	601a      	str	r2, [r3, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 8001a4c:	f242 0300 	movw	r3, #8192	; 0x2000
 8001a50:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001a54:	f242 0200 	movw	r2, #8192	; 0x2000
 8001a58:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001a5c:	6811      	ldr	r1, [r2, #0]
 8001a5e:	687a      	ldr	r2, [r7, #4]
 8001a60:	ea41 0202 	orr.w	r2, r1, r2
 8001a64:	601a      	str	r2, [r3, #0]
}
 8001a66:	f107 070c 	add.w	r7, r7, #12
 8001a6a:	46bd      	mov	sp, r7
 8001a6c:	bc80      	pop	{r7}
 8001a6e:	4770      	bx	lr

08001a70 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8001a70:	b480      	push	{r7}
 8001a72:	b089      	sub	sp, #36	; 0x24
 8001a74:	af00      	add	r7, sp, #0
 8001a76:	6078      	str	r0, [r7, #4]
 8001a78:	6039      	str	r1, [r7, #0]
  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
 8001a7a:	f04f 0300 	mov.w	r3, #0
 8001a7e:	60bb      	str	r3, [r7, #8]
 8001a80:	f04f 0300 	mov.w	r3, #0
 8001a84:	60fb      	str	r3, [r7, #12]
 8001a86:	f04f 0300 	mov.w	r3, #0
 8001a8a:	613b      	str	r3, [r7, #16]
 8001a8c:	f04f 0300 	mov.w	r3, #0
 8001a90:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg = 0x00, pinmask = 0x00;
 8001a92:	f04f 0300 	mov.w	r3, #0
 8001a96:	61bb      	str	r3, [r7, #24]
 8001a98:	f04f 0300 	mov.w	r3, #0
 8001a9c:	61fb      	str	r3, [r7, #28]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8001a9e:	683b      	ldr	r3, [r7, #0]
 8001aa0:	78db      	ldrb	r3, [r3, #3]
 8001aa2:	f003 030f 	and.w	r3, r3, #15
 8001aa6:	60bb      	str	r3, [r7, #8]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 8001aa8:	683b      	ldr	r3, [r7, #0]
 8001aaa:	78db      	ldrb	r3, [r3, #3]
 8001aac:	f003 0310 	and.w	r3, r3, #16
 8001ab0:	2b00      	cmp	r3, #0
 8001ab2:	d005      	beq.n	8001ac0 <GPIO_Init+0x50>
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8001ab4:	683b      	ldr	r3, [r7, #0]
 8001ab6:	789b      	ldrb	r3, [r3, #2]
 8001ab8:	68ba      	ldr	r2, [r7, #8]
 8001aba:	ea42 0303 	orr.w	r3, r2, r3
 8001abe:	60bb      	str	r3, [r7, #8]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8001ac0:	683b      	ldr	r3, [r7, #0]
 8001ac2:	881b      	ldrh	r3, [r3, #0]
 8001ac4:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8001ac8:	2b00      	cmp	r3, #0
 8001aca:	d051      	beq.n	8001b70 <GPIO_Init+0x100>
  {
    tmpreg = GPIOx->CRL;
 8001acc:	687b      	ldr	r3, [r7, #4]
 8001ace:	681b      	ldr	r3, [r3, #0]
 8001ad0:	61bb      	str	r3, [r7, #24]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001ad2:	f04f 0300 	mov.w	r3, #0
 8001ad6:	613b      	str	r3, [r7, #16]
 8001ad8:	e044      	b.n	8001b64 <GPIO_Init+0xf4>
    {
      pos = ((uint32_t)0x01) << pinpos;
 8001ada:	693b      	ldr	r3, [r7, #16]
 8001adc:	f04f 0201 	mov.w	r2, #1
 8001ae0:	fa02 f303 	lsl.w	r3, r2, r3
 8001ae4:	617b      	str	r3, [r7, #20]
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8001ae6:	683b      	ldr	r3, [r7, #0]
 8001ae8:	881b      	ldrh	r3, [r3, #0]
 8001aea:	461a      	mov	r2, r3
 8001aec:	697b      	ldr	r3, [r7, #20]
 8001aee:	ea02 0303 	and.w	r3, r2, r3
 8001af2:	60fb      	str	r3, [r7, #12]
      if (currentpin == pos)
 8001af4:	68fa      	ldr	r2, [r7, #12]
 8001af6:	697b      	ldr	r3, [r7, #20]
 8001af8:	429a      	cmp	r2, r3
 8001afa:	d12f      	bne.n	8001b5c <GPIO_Init+0xec>
      {
        pos = pinpos << 2;
 8001afc:	693b      	ldr	r3, [r7, #16]
 8001afe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001b02:	617b      	str	r3, [r7, #20]
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8001b04:	697b      	ldr	r3, [r7, #20]
 8001b06:	f04f 020f 	mov.w	r2, #15
 8001b0a:	fa02 f303 	lsl.w	r3, r2, r3
 8001b0e:	61fb      	str	r3, [r7, #28]
        tmpreg &= ~pinmask;
 8001b10:	69fb      	ldr	r3, [r7, #28]
 8001b12:	ea6f 0303 	mvn.w	r3, r3
 8001b16:	69ba      	ldr	r2, [r7, #24]
 8001b18:	ea02 0303 	and.w	r3, r2, r3
 8001b1c:	61bb      	str	r3, [r7, #24]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001b1e:	697b      	ldr	r3, [r7, #20]
 8001b20:	68ba      	ldr	r2, [r7, #8]
 8001b22:	fa02 f303 	lsl.w	r3, r2, r3
 8001b26:	69ba      	ldr	r2, [r7, #24]
 8001b28:	ea42 0303 	orr.w	r3, r2, r3
 8001b2c:	61bb      	str	r3, [r7, #24]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8001b2e:	683b      	ldr	r3, [r7, #0]
 8001b30:	78db      	ldrb	r3, [r3, #3]
 8001b32:	2b28      	cmp	r3, #40	; 0x28
 8001b34:	d107      	bne.n	8001b46 <GPIO_Init+0xd6>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8001b36:	693b      	ldr	r3, [r7, #16]
 8001b38:	f04f 0201 	mov.w	r2, #1
 8001b3c:	fa02 f203 	lsl.w	r2, r2, r3
 8001b40:	687b      	ldr	r3, [r7, #4]
 8001b42:	615a      	str	r2, [r3, #20]
 8001b44:	e00a      	b.n	8001b5c <GPIO_Init+0xec>
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8001b46:	683b      	ldr	r3, [r7, #0]
 8001b48:	78db      	ldrb	r3, [r3, #3]
 8001b4a:	2b48      	cmp	r3, #72	; 0x48
 8001b4c:	d106      	bne.n	8001b5c <GPIO_Init+0xec>
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8001b4e:	693b      	ldr	r3, [r7, #16]
 8001b50:	f04f 0201 	mov.w	r2, #1
 8001b54:	fa02 f203 	lsl.w	r2, r2, r3
 8001b58:	687b      	ldr	r3, [r7, #4]
 8001b5a:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001b5c:	693b      	ldr	r3, [r7, #16]
 8001b5e:	f103 0301 	add.w	r3, r3, #1
 8001b62:	613b      	str	r3, [r7, #16]
 8001b64:	693b      	ldr	r3, [r7, #16]
 8001b66:	2b07      	cmp	r3, #7
 8001b68:	d9b7      	bls.n	8001ada <GPIO_Init+0x6a>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8001b6a:	687b      	ldr	r3, [r7, #4]
 8001b6c:	69ba      	ldr	r2, [r7, #24]
 8001b6e:	601a      	str	r2, [r3, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8001b70:	683b      	ldr	r3, [r7, #0]
 8001b72:	881b      	ldrh	r3, [r3, #0]
 8001b74:	2bff      	cmp	r3, #255	; 0xff
 8001b76:	d956      	bls.n	8001c26 <GPIO_Init+0x1b6>
  {
    tmpreg = GPIOx->CRH;
 8001b78:	687b      	ldr	r3, [r7, #4]
 8001b7a:	685b      	ldr	r3, [r3, #4]
 8001b7c:	61bb      	str	r3, [r7, #24]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001b7e:	f04f 0300 	mov.w	r3, #0
 8001b82:	613b      	str	r3, [r7, #16]
 8001b84:	e049      	b.n	8001c1a <GPIO_Init+0x1aa>
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8001b86:	693b      	ldr	r3, [r7, #16]
 8001b88:	f103 0308 	add.w	r3, r3, #8
 8001b8c:	f04f 0201 	mov.w	r2, #1
 8001b90:	fa02 f303 	lsl.w	r3, r2, r3
 8001b94:	617b      	str	r3, [r7, #20]
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8001b96:	683b      	ldr	r3, [r7, #0]
 8001b98:	881b      	ldrh	r3, [r3, #0]
 8001b9a:	461a      	mov	r2, r3
 8001b9c:	697b      	ldr	r3, [r7, #20]
 8001b9e:	ea02 0303 	and.w	r3, r2, r3
 8001ba2:	60fb      	str	r3, [r7, #12]
      if (currentpin == pos)
 8001ba4:	68fa      	ldr	r2, [r7, #12]
 8001ba6:	697b      	ldr	r3, [r7, #20]
 8001ba8:	429a      	cmp	r2, r3
 8001baa:	d132      	bne.n	8001c12 <GPIO_Init+0x1a2>
      {
        pos = pinpos << 2;
 8001bac:	693b      	ldr	r3, [r7, #16]
 8001bae:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001bb2:	617b      	str	r3, [r7, #20]
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8001bb4:	697b      	ldr	r3, [r7, #20]
 8001bb6:	f04f 020f 	mov.w	r2, #15
 8001bba:	fa02 f303 	lsl.w	r3, r2, r3
 8001bbe:	61fb      	str	r3, [r7, #28]
        tmpreg &= ~pinmask;
 8001bc0:	69fb      	ldr	r3, [r7, #28]
 8001bc2:	ea6f 0303 	mvn.w	r3, r3
 8001bc6:	69ba      	ldr	r2, [r7, #24]
 8001bc8:	ea02 0303 	and.w	r3, r2, r3
 8001bcc:	61bb      	str	r3, [r7, #24]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8001bce:	697b      	ldr	r3, [r7, #20]
 8001bd0:	68ba      	ldr	r2, [r7, #8]
 8001bd2:	fa02 f303 	lsl.w	r3, r2, r3
 8001bd6:	69ba      	ldr	r2, [r7, #24]
 8001bd8:	ea42 0303 	orr.w	r3, r2, r3
 8001bdc:	61bb      	str	r3, [r7, #24]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8001bde:	683b      	ldr	r3, [r7, #0]
 8001be0:	78db      	ldrb	r3, [r3, #3]
 8001be2:	2b28      	cmp	r3, #40	; 0x28
 8001be4:	d108      	bne.n	8001bf8 <GPIO_Init+0x188>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001be6:	693b      	ldr	r3, [r7, #16]
 8001be8:	f103 0308 	add.w	r3, r3, #8
 8001bec:	f04f 0201 	mov.w	r2, #1
 8001bf0:	fa02 f203 	lsl.w	r2, r2, r3
 8001bf4:	687b      	ldr	r3, [r7, #4]
 8001bf6:	615a      	str	r2, [r3, #20]
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8001bf8:	683b      	ldr	r3, [r7, #0]
 8001bfa:	78db      	ldrb	r3, [r3, #3]
 8001bfc:	2b48      	cmp	r3, #72	; 0x48
 8001bfe:	d108      	bne.n	8001c12 <GPIO_Init+0x1a2>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8001c00:	693b      	ldr	r3, [r7, #16]
 8001c02:	f103 0308 	add.w	r3, r3, #8
 8001c06:	f04f 0201 	mov.w	r2, #1
 8001c0a:	fa02 f203 	lsl.w	r2, r2, r3
 8001c0e:	687b      	ldr	r3, [r7, #4]
 8001c10:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8001c12:	693b      	ldr	r3, [r7, #16]
 8001c14:	f103 0301 	add.w	r3, r3, #1
 8001c18:	613b      	str	r3, [r7, #16]
 8001c1a:	693b      	ldr	r3, [r7, #16]
 8001c1c:	2b07      	cmp	r3, #7
 8001c1e:	d9b2      	bls.n	8001b86 <GPIO_Init+0x116>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8001c20:	687b      	ldr	r3, [r7, #4]
 8001c22:	69ba      	ldr	r2, [r7, #24]
 8001c24:	605a      	str	r2, [r3, #4]
  }
}
 8001c26:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8001c2a:	46bd      	mov	sp, r7
 8001c2c:	bc80      	pop	{r7}
 8001c2e:	4770      	bx	lr

08001c30 <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8001c30:	b480      	push	{r7}
 8001c32:	b083      	sub	sp, #12
 8001c34:	af00      	add	r7, sp, #0
 8001c36:	6078      	str	r0, [r7, #4]
 8001c38:	460b      	mov	r3, r1
 8001c3a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 8001c3c:	887a      	ldrh	r2, [r7, #2]
 8001c3e:	687b      	ldr	r3, [r7, #4]
 8001c40:	611a      	str	r2, [r3, #16]
}
 8001c42:	f107 070c 	add.w	r7, r7, #12
 8001c46:	46bd      	mov	sp, r7
 8001c48:	bc80      	pop	{r7}
 8001c4a:	4770      	bx	lr

08001c4c <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8001c4c:	b480      	push	{r7}
 8001c4e:	b083      	sub	sp, #12
 8001c50:	af00      	add	r7, sp, #0
 8001c52:	6078      	str	r0, [r7, #4]
 8001c54:	460b      	mov	r3, r1
 8001c56:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 8001c58:	887a      	ldrh	r2, [r7, #2]
 8001c5a:	687b      	ldr	r3, [r7, #4]
 8001c5c:	615a      	str	r2, [r3, #20]
}
 8001c5e:	f107 070c 	add.w	r7, r7, #12
 8001c62:	46bd      	mov	sp, r7
 8001c64:	bc80      	pop	{r7}
 8001c66:	4770      	bx	lr

08001c68 <RCC_DeInit>:
  * @brief  Resets the RCC clock configuration to the default reset state.
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
 8001c68:	b480      	push	{r7}
 8001c6a:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001c6c:	f241 0300 	movw	r3, #4096	; 0x1000
 8001c70:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c74:	f241 0200 	movw	r2, #4096	; 0x1000
 8001c78:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001c7c:	6812      	ldr	r2, [r2, #0]
 8001c7e:	f042 0201 	orr.w	r2, r2, #1
 8001c82:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8001c84:	f241 0200 	movw	r2, #4096	; 0x1000
 8001c88:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001c8c:	f241 0300 	movw	r3, #4096	; 0x1000
 8001c90:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c94:	6859      	ldr	r1, [r3, #4]
 8001c96:	f240 0300 	movw	r3, #0
 8001c9a:	f6cf 03ff 	movt	r3, #63743	; 0xf8ff
 8001c9e:	ea01 0303 	and.w	r3, r1, r3
 8001ca2:	6053      	str	r3, [r2, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8001ca4:	f241 0300 	movw	r3, #4096	; 0x1000
 8001ca8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001cac:	f241 0200 	movw	r2, #4096	; 0x1000
 8001cb0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001cb4:	6812      	ldr	r2, [r2, #0]
 8001cb6:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8001cba:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001cbe:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8001cc0:	f241 0300 	movw	r3, #4096	; 0x1000
 8001cc4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001cc8:	f241 0200 	movw	r2, #4096	; 0x1000
 8001ccc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001cd0:	6812      	ldr	r2, [r2, #0]
 8001cd2:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001cd6:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8001cd8:	f241 0300 	movw	r3, #4096	; 0x1000
 8001cdc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001ce0:	f241 0200 	movw	r2, #4096	; 0x1000
 8001ce4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001ce8:	6852      	ldr	r2, [r2, #4]
 8001cea:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8001cee:	605a      	str	r2, [r3, #4]

#ifndef STM32F10X_CL
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 8001cf0:	f241 0300 	movw	r3, #4096	; 0x1000
 8001cf4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001cf8:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8001cfc:	609a      	str	r2, [r3, #8]
  RCC->CIR = 0x00FF0000;

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;
#endif /* STM32F10X_CL */
}
 8001cfe:	46bd      	mov	sp, r7
 8001d00:	bc80      	pop	{r7}
 8001d02:	4770      	bx	lr

08001d04 <RCC_HSEConfig>:
  *     @arg RCC_HSE_ON: HSE oscillator ON
  *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_HSEConfig(uint32_t RCC_HSE)
{
 8001d04:	b480      	push	{r7}
 8001d06:	b083      	sub	sp, #12
 8001d08:	af00      	add	r7, sp, #0
 8001d0a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 8001d0c:	f241 0300 	movw	r3, #4096	; 0x1000
 8001d10:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d14:	f241 0200 	movw	r2, #4096	; 0x1000
 8001d18:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001d1c:	6812      	ldr	r2, [r2, #0]
 8001d1e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001d22:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 8001d24:	f241 0300 	movw	r3, #4096	; 0x1000
 8001d28:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d2c:	f241 0200 	movw	r2, #4096	; 0x1000
 8001d30:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001d34:	6812      	ldr	r2, [r2, #0]
 8001d36:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001d3a:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 8001d3c:	687b      	ldr	r3, [r7, #4]
 8001d3e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001d42:	d003      	beq.n	8001d4c <RCC_HSEConfig+0x48>
 8001d44:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001d48:	d00d      	beq.n	8001d66 <RCC_HSEConfig+0x62>
 8001d4a:	e018      	b.n	8001d7e <RCC_HSEConfig+0x7a>
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
 8001d4c:	f241 0300 	movw	r3, #4096	; 0x1000
 8001d50:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d54:	f241 0200 	movw	r2, #4096	; 0x1000
 8001d58:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001d5c:	6812      	ldr	r2, [r2, #0]
 8001d5e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001d62:	601a      	str	r2, [r3, #0]
      break;
 8001d64:	e00b      	b.n	8001d7e <RCC_HSEConfig+0x7a>
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 8001d66:	f241 0300 	movw	r3, #4096	; 0x1000
 8001d6a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d6e:	f241 0200 	movw	r2, #4096	; 0x1000
 8001d72:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001d76:	6812      	ldr	r2, [r2, #0]
 8001d78:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 8001d7c:	601a      	str	r2, [r3, #0]
      break;
      
    default:
      break;
  }
}
 8001d7e:	f107 070c 	add.w	r7, r7, #12
 8001d82:	46bd      	mov	sp, r7
 8001d84:	bc80      	pop	{r7}
 8001d86:	4770      	bx	lr

08001d88 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8001d88:	b580      	push	{r7, lr}
 8001d8a:	b082      	sub	sp, #8
 8001d8c:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0;
 8001d8e:	f04f 0300 	mov.w	r3, #0
 8001d92:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
 8001d94:	f04f 0300 	mov.w	r3, #0
 8001d98:	71bb      	strb	r3, [r7, #6]
  FlagStatus HSEStatus = RESET;
 8001d9a:	f04f 0300 	mov.w	r3, #0
 8001d9e:	71fb      	strb	r3, [r7, #7]
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8001da0:	f04f 0031 	mov.w	r0, #49	; 0x31
 8001da4:	f242 2351 	movw	r3, #8785	; 0x2251
 8001da8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001dac:	4798      	blx	r3
 8001dae:	4603      	mov	r3, r0
 8001db0:	71fb      	strb	r3, [r7, #7]
    StartUpCounter++;  
 8001db2:	683b      	ldr	r3, [r7, #0]
 8001db4:	f103 0301 	add.w	r3, r3, #1
 8001db8:	603b      	str	r3, [r7, #0]
  } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
 8001dba:	683b      	ldr	r3, [r7, #0]
 8001dbc:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8001dc0:	d002      	beq.n	8001dc8 <RCC_WaitForHSEStartUp+0x40>
 8001dc2:	79fb      	ldrb	r3, [r7, #7]
 8001dc4:	2b00      	cmp	r3, #0
 8001dc6:	d0eb      	beq.n	8001da0 <RCC_WaitForHSEStartUp+0x18>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8001dc8:	f04f 0031 	mov.w	r0, #49	; 0x31
 8001dcc:	f242 2351 	movw	r3, #8785	; 0x2251
 8001dd0:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001dd4:	4798      	blx	r3
 8001dd6:	4603      	mov	r3, r0
 8001dd8:	2b00      	cmp	r3, #0
 8001dda:	d003      	beq.n	8001de4 <RCC_WaitForHSEStartUp+0x5c>
  {
    status = SUCCESS;
 8001ddc:	f04f 0301 	mov.w	r3, #1
 8001de0:	71bb      	strb	r3, [r7, #6]
 8001de2:	e002      	b.n	8001dea <RCC_WaitForHSEStartUp+0x62>
  }
  else
  {
    status = ERROR;
 8001de4:	f04f 0300 	mov.w	r3, #0
 8001de8:	71bb      	strb	r3, [r7, #6]
  }  
  return (status);
 8001dea:	79bb      	ldrb	r3, [r7, #6]
}
 8001dec:	4618      	mov	r0, r3
 8001dee:	f107 0708 	add.w	r7, r7, #8
 8001df2:	46bd      	mov	sp, r7
 8001df4:	bd80      	pop	{r7, pc}
 8001df6:	bf00      	nop

08001df8 <RCC_PLLConfig>:
  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
{
 8001df8:	b480      	push	{r7}
 8001dfa:	b085      	sub	sp, #20
 8001dfc:	af00      	add	r7, sp, #0
 8001dfe:	6078      	str	r0, [r7, #4]
 8001e00:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8001e02:	f04f 0300 	mov.w	r3, #0
 8001e06:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 8001e08:	f241 0300 	movw	r3, #4096	; 0x1000
 8001e0c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e10:	685b      	ldr	r3, [r3, #4]
 8001e12:	60fb      	str	r3, [r7, #12]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 8001e14:	68fb      	ldr	r3, [r7, #12]
 8001e16:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8001e1a:	60fb      	str	r3, [r7, #12]
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 8001e1c:	687a      	ldr	r2, [r7, #4]
 8001e1e:	683b      	ldr	r3, [r7, #0]
 8001e20:	ea42 0303 	orr.w	r3, r2, r3
 8001e24:	68fa      	ldr	r2, [r7, #12]
 8001e26:	ea42 0303 	orr.w	r3, r2, r3
 8001e2a:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001e2c:	f241 0300 	movw	r3, #4096	; 0x1000
 8001e30:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e34:	68fa      	ldr	r2, [r7, #12]
 8001e36:	605a      	str	r2, [r3, #4]
}
 8001e38:	f107 0714 	add.w	r7, r7, #20
 8001e3c:	46bd      	mov	sp, r7
 8001e3e:	bc80      	pop	{r7}
 8001e40:	4770      	bx	lr
 8001e42:	bf00      	nop

08001e44 <RCC_PLLCmd>:
  * @note   The PLL can not be disabled if it is used as system clock.
  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 8001e44:	b480      	push	{r7}
 8001e46:	b083      	sub	sp, #12
 8001e48:	af00      	add	r7, sp, #0
 8001e4a:	4603      	mov	r3, r0
 8001e4c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8001e4e:	f240 0360 	movw	r3, #96	; 0x60
 8001e52:	f2c4 2342 	movt	r3, #16962	; 0x4242
 8001e56:	79fa      	ldrb	r2, [r7, #7]
 8001e58:	601a      	str	r2, [r3, #0]
}
 8001e5a:	f107 070c 	add.w	r7, r7, #12
 8001e5e:	46bd      	mov	sp, r7
 8001e60:	bc80      	pop	{r7}
 8001e62:	4770      	bx	lr

08001e64 <RCC_SYSCLKConfig>:
  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 8001e64:	b480      	push	{r7}
 8001e66:	b085      	sub	sp, #20
 8001e68:	af00      	add	r7, sp, #0
 8001e6a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8001e6c:	f04f 0300 	mov.w	r3, #0
 8001e70:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 8001e72:	f241 0300 	movw	r3, #4096	; 0x1000
 8001e76:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e7a:	685b      	ldr	r3, [r3, #4]
 8001e7c:	60fb      	str	r3, [r7, #12]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 8001e7e:	68fb      	ldr	r3, [r7, #12]
 8001e80:	f023 0303 	bic.w	r3, r3, #3
 8001e84:	60fb      	str	r3, [r7, #12]
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8001e86:	68fa      	ldr	r2, [r7, #12]
 8001e88:	687b      	ldr	r3, [r7, #4]
 8001e8a:	ea42 0303 	orr.w	r3, r2, r3
 8001e8e:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001e90:	f241 0300 	movw	r3, #4096	; 0x1000
 8001e94:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e98:	68fa      	ldr	r2, [r7, #12]
 8001e9a:	605a      	str	r2, [r3, #4]
}
 8001e9c:	f107 0714 	add.w	r7, r7, #20
 8001ea0:	46bd      	mov	sp, r7
 8001ea2:	bc80      	pop	{r7}
 8001ea4:	4770      	bx	lr
 8001ea6:	bf00      	nop

08001ea8 <RCC_GetSYSCLKSource>:
  *     - 0x00: HSI used as system clock
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
 8001ea8:	b480      	push	{r7}
 8001eaa:	af00      	add	r7, sp, #0
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8001eac:	f241 0300 	movw	r3, #4096	; 0x1000
 8001eb0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001eb4:	685b      	ldr	r3, [r3, #4]
 8001eb6:	b2db      	uxtb	r3, r3
 8001eb8:	f003 030c 	and.w	r3, r3, #12
}
 8001ebc:	4618      	mov	r0, r3
 8001ebe:	46bd      	mov	sp, r7
 8001ec0:	bc80      	pop	{r7}
 8001ec2:	4770      	bx	lr

08001ec4 <RCC_HCLKConfig>:
  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 8001ec4:	b480      	push	{r7}
 8001ec6:	b085      	sub	sp, #20
 8001ec8:	af00      	add	r7, sp, #0
 8001eca:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8001ecc:	f04f 0300 	mov.w	r3, #0
 8001ed0:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 8001ed2:	f241 0300 	movw	r3, #4096	; 0x1000
 8001ed6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001eda:	685b      	ldr	r3, [r3, #4]
 8001edc:	60fb      	str	r3, [r7, #12]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 8001ede:	68fb      	ldr	r3, [r7, #12]
 8001ee0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8001ee4:	60fb      	str	r3, [r7, #12]
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8001ee6:	68fa      	ldr	r2, [r7, #12]
 8001ee8:	687b      	ldr	r3, [r7, #4]
 8001eea:	ea42 0303 	orr.w	r3, r2, r3
 8001eee:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001ef0:	f241 0300 	movw	r3, #4096	; 0x1000
 8001ef4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001ef8:	68fa      	ldr	r2, [r7, #12]
 8001efa:	605a      	str	r2, [r3, #4]
}
 8001efc:	f107 0714 	add.w	r7, r7, #20
 8001f00:	46bd      	mov	sp, r7
 8001f02:	bc80      	pop	{r7}
 8001f04:	4770      	bx	lr
 8001f06:	bf00      	nop

08001f08 <RCC_PCLK1Config>:
  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
 8001f08:	b480      	push	{r7}
 8001f0a:	b085      	sub	sp, #20
 8001f0c:	af00      	add	r7, sp, #0
 8001f0e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8001f10:	f04f 0300 	mov.w	r3, #0
 8001f14:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8001f16:	f241 0300 	movw	r3, #4096	; 0x1000
 8001f1a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f1e:	685b      	ldr	r3, [r3, #4]
 8001f20:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 8001f22:	68fb      	ldr	r3, [r7, #12]
 8001f24:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001f28:	60fb      	str	r3, [r7, #12]
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8001f2a:	68fa      	ldr	r2, [r7, #12]
 8001f2c:	687b      	ldr	r3, [r7, #4]
 8001f2e:	ea42 0303 	orr.w	r3, r2, r3
 8001f32:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001f34:	f241 0300 	movw	r3, #4096	; 0x1000
 8001f38:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f3c:	68fa      	ldr	r2, [r7, #12]
 8001f3e:	605a      	str	r2, [r3, #4]
}
 8001f40:	f107 0714 	add.w	r7, r7, #20
 8001f44:	46bd      	mov	sp, r7
 8001f46:	bc80      	pop	{r7}
 8001f48:	4770      	bx	lr
 8001f4a:	bf00      	nop

08001f4c <RCC_PCLK2Config>:
  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
 8001f4c:	b480      	push	{r7}
 8001f4e:	b085      	sub	sp, #20
 8001f50:	af00      	add	r7, sp, #0
 8001f52:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8001f54:	f04f 0300 	mov.w	r3, #0
 8001f58:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 8001f5a:	f241 0300 	movw	r3, #4096	; 0x1000
 8001f5e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f62:	685b      	ldr	r3, [r3, #4]
 8001f64:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 8001f66:	68fb      	ldr	r3, [r7, #12]
 8001f68:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8001f6c:	60fb      	str	r3, [r7, #12]
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8001f6e:	687b      	ldr	r3, [r7, #4]
 8001f70:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8001f74:	68fa      	ldr	r2, [r7, #12]
 8001f76:	ea42 0303 	orr.w	r3, r2, r3
 8001f7a:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001f7c:	f241 0300 	movw	r3, #4096	; 0x1000
 8001f80:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f84:	68fa      	ldr	r2, [r7, #12]
 8001f86:	605a      	str	r2, [r3, #4]
}
 8001f88:	f107 0714 	add.w	r7, r7, #20
 8001f8c:	46bd      	mov	sp, r7
 8001f8e:	bc80      	pop	{r7}
 8001f90:	4770      	bx	lr
 8001f92:	bf00      	nop

08001f94 <RCC_ADCCLKConfig>:
  *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
  *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
  * @retval None
  */
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
 8001f94:	b480      	push	{r7}
 8001f96:	b085      	sub	sp, #20
 8001f98:	af00      	add	r7, sp, #0
 8001f9a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8001f9c:	f04f 0300 	mov.w	r3, #0
 8001fa0:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 8001fa2:	f241 0300 	movw	r3, #4096	; 0x1000
 8001fa6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001faa:	685b      	ldr	r3, [r3, #4]
 8001fac:	60fb      	str	r3, [r7, #12]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 8001fae:	68fb      	ldr	r3, [r7, #12]
 8001fb0:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8001fb4:	60fb      	str	r3, [r7, #12]
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 8001fb6:	68fa      	ldr	r2, [r7, #12]
 8001fb8:	687b      	ldr	r3, [r7, #4]
 8001fba:	ea42 0303 	orr.w	r3, r2, r3
 8001fbe:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8001fc0:	f241 0300 	movw	r3, #4096	; 0x1000
 8001fc4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001fc8:	68fa      	ldr	r2, [r7, #12]
 8001fca:	605a      	str	r2, [r3, #4]
}
 8001fcc:	f107 0714 	add.w	r7, r7, #20
 8001fd0:	46bd      	mov	sp, r7
 8001fd2:	bc80      	pop	{r7}
 8001fd4:	4770      	bx	lr
 8001fd6:	bf00      	nop

08001fd8 <RCC_GetClocksFreq>:
  * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
  *   the clocks frequencies.
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8001fd8:	b480      	push	{r7}
 8001fda:	b087      	sub	sp, #28
 8001fdc:	af00      	add	r7, sp, #0
 8001fde:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
 8001fe0:	f04f 0300 	mov.w	r3, #0
 8001fe4:	60bb      	str	r3, [r7, #8]
 8001fe6:	f04f 0300 	mov.w	r3, #0
 8001fea:	60fb      	str	r3, [r7, #12]
 8001fec:	f04f 0300 	mov.w	r3, #0
 8001ff0:	613b      	str	r3, [r7, #16]
 8001ff2:	f04f 0300 	mov.w	r3, #0
 8001ff6:	617b      	str	r3, [r7, #20]
#ifdef  STM32F10X_CL
  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
#endif /* STM32F10X_CL */
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8001ff8:	f241 0300 	movw	r3, #4096	; 0x1000
 8001ffc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002000:	685b      	ldr	r3, [r3, #4]
 8002002:	f003 030c 	and.w	r3, r3, #12
 8002006:	60bb      	str	r3, [r7, #8]
  
  switch (tmp)
 8002008:	68bb      	ldr	r3, [r7, #8]
 800200a:	2b04      	cmp	r3, #4
 800200c:	d00a      	beq.n	8002024 <RCC_GetClocksFreq+0x4c>
 800200e:	2b08      	cmp	r3, #8
 8002010:	d00f      	beq.n	8002032 <RCC_GetClocksFreq+0x5a>
 8002012:	2b00      	cmp	r3, #0
 8002014:	d14d      	bne.n	80020b2 <RCC_GetClocksFreq+0xda>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 8002016:	687a      	ldr	r2, [r7, #4]
 8002018:	f241 2300 	movw	r3, #4608	; 0x1200
 800201c:	f2c0 037a 	movt	r3, #122	; 0x7a
 8002020:	6013      	str	r3, [r2, #0]
      break;
 8002022:	e04c      	b.n	80020be <RCC_GetClocksFreq+0xe6>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
 8002024:	687a      	ldr	r2, [r7, #4]
 8002026:	f241 2300 	movw	r3, #4608	; 0x1200
 800202a:	f2c0 037a 	movt	r3, #122	; 0x7a
 800202e:	6013      	str	r3, [r2, #0]
      break;
 8002030:	e045      	b.n	80020be <RCC_GetClocksFreq+0xe6>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 8002032:	f241 0300 	movw	r3, #4096	; 0x1000
 8002036:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800203a:	685b      	ldr	r3, [r3, #4]
 800203c:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 8002040:	60fb      	str	r3, [r7, #12]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 8002042:	f241 0300 	movw	r3, #4096	; 0x1000
 8002046:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800204a:	685b      	ldr	r3, [r3, #4]
 800204c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002050:	613b      	str	r3, [r7, #16]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8002052:	68fb      	ldr	r3, [r7, #12]
 8002054:	ea4f 4393 	mov.w	r3, r3, lsr #18
 8002058:	f103 0302 	add.w	r3, r3, #2
 800205c:	60fb      	str	r3, [r7, #12]
      
      if (pllsource == 0x00)
 800205e:	693b      	ldr	r3, [r7, #16]
 8002060:	2b00      	cmp	r3, #0
 8002062:	d109      	bne.n	8002078 <RCC_GetClocksFreq+0xa0>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
 8002064:	68fa      	ldr	r2, [r7, #12]
 8002066:	f640 1300 	movw	r3, #2304	; 0x900
 800206a:	f2c0 033d 	movt	r3, #61	; 0x3d
 800206e:	fb03 f202 	mul.w	r2, r3, r2
 8002072:	687b      	ldr	r3, [r7, #4]
 8002074:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 8002076:	e022      	b.n	80020be <RCC_GetClocksFreq+0xe6>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
      }
      else
      {/* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 8002078:	f241 0300 	movw	r3, #4096	; 0x1000
 800207c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002080:	685b      	ldr	r3, [r3, #4]
 8002082:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002086:	2b00      	cmp	r3, #0
 8002088:	d009      	beq.n	800209e <RCC_GetClocksFreq+0xc6>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
 800208a:	68fa      	ldr	r2, [r7, #12]
 800208c:	f640 1300 	movw	r3, #2304	; 0x900
 8002090:	f2c0 033d 	movt	r3, #61	; 0x3d
 8002094:	fb03 f202 	mul.w	r2, r3, r2
 8002098:	687b      	ldr	r3, [r7, #4]
 800209a:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 800209c:	e00f      	b.n	80020be <RCC_GetClocksFreq+0xe6>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
 800209e:	68fa      	ldr	r2, [r7, #12]
 80020a0:	f241 2300 	movw	r3, #4608	; 0x1200
 80020a4:	f2c0 037a 	movt	r3, #122	; 0x7a
 80020a8:	fb03 f202 	mul.w	r2, r3, r2
 80020ac:	687b      	ldr	r3, [r7, #4]
 80020ae:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 80020b0:	e005      	b.n	80020be <RCC_GetClocksFreq+0xe6>

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 80020b2:	687a      	ldr	r2, [r7, #4]
 80020b4:	f241 2300 	movw	r3, #4608	; 0x1200
 80020b8:	f2c0 037a 	movt	r3, #122	; 0x7a
 80020bc:	6013      	str	r3, [r2, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 80020be:	f241 0300 	movw	r3, #4096	; 0x1000
 80020c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80020c6:	685b      	ldr	r3, [r3, #4]
 80020c8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80020cc:	60bb      	str	r3, [r7, #8]
  tmp = tmp >> 4;
 80020ce:	68bb      	ldr	r3, [r7, #8]
 80020d0:	ea4f 1313 	mov.w	r3, r3, lsr #4
 80020d4:	60bb      	str	r3, [r7, #8]
  presc = APBAHBPrescTable[tmp];
 80020d6:	68ba      	ldr	r2, [r7, #8]
 80020d8:	f240 1334 	movw	r3, #308	; 0x134
 80020dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80020e0:	5c9b      	ldrb	r3, [r3, r2]
 80020e2:	b2db      	uxtb	r3, r3
 80020e4:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80020e6:	687b      	ldr	r3, [r7, #4]
 80020e8:	681a      	ldr	r2, [r3, #0]
 80020ea:	697b      	ldr	r3, [r7, #20]
 80020ec:	fa22 f203 	lsr.w	r2, r2, r3
 80020f0:	687b      	ldr	r3, [r7, #4]
 80020f2:	605a      	str	r2, [r3, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 80020f4:	f241 0300 	movw	r3, #4096	; 0x1000
 80020f8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80020fc:	685b      	ldr	r3, [r3, #4]
 80020fe:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002102:	60bb      	str	r3, [r7, #8]
  tmp = tmp >> 8;
 8002104:	68bb      	ldr	r3, [r7, #8]
 8002106:	ea4f 2313 	mov.w	r3, r3, lsr #8
 800210a:	60bb      	str	r3, [r7, #8]
  presc = APBAHBPrescTable[tmp];
 800210c:	68ba      	ldr	r2, [r7, #8]
 800210e:	f240 1334 	movw	r3, #308	; 0x134
 8002112:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002116:	5c9b      	ldrb	r3, [r3, r2]
 8002118:	b2db      	uxtb	r3, r3
 800211a:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 800211c:	687b      	ldr	r3, [r7, #4]
 800211e:	685a      	ldr	r2, [r3, #4]
 8002120:	697b      	ldr	r3, [r7, #20]
 8002122:	fa22 f203 	lsr.w	r2, r2, r3
 8002126:	687b      	ldr	r3, [r7, #4]
 8002128:	609a      	str	r2, [r3, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 800212a:	f241 0300 	movw	r3, #4096	; 0x1000
 800212e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002132:	685b      	ldr	r3, [r3, #4]
 8002134:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 8002138:	60bb      	str	r3, [r7, #8]
  tmp = tmp >> 11;
 800213a:	68bb      	ldr	r3, [r7, #8]
 800213c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8002140:	60bb      	str	r3, [r7, #8]
  presc = APBAHBPrescTable[tmp];
 8002142:	68ba      	ldr	r2, [r7, #8]
 8002144:	f240 1334 	movw	r3, #308	; 0x134
 8002148:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800214c:	5c9b      	ldrb	r3, [r3, r2]
 800214e:	b2db      	uxtb	r3, r3
 8002150:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8002152:	687b      	ldr	r3, [r7, #4]
 8002154:	685a      	ldr	r2, [r3, #4]
 8002156:	697b      	ldr	r3, [r7, #20]
 8002158:	fa22 f203 	lsr.w	r2, r2, r3
 800215c:	687b      	ldr	r3, [r7, #4]
 800215e:	60da      	str	r2, [r3, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8002160:	f241 0300 	movw	r3, #4096	; 0x1000
 8002164:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002168:	685b      	ldr	r3, [r3, #4]
 800216a:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800216e:	60bb      	str	r3, [r7, #8]
  tmp = tmp >> 14;
 8002170:	68bb      	ldr	r3, [r7, #8]
 8002172:	ea4f 3393 	mov.w	r3, r3, lsr #14
 8002176:	60bb      	str	r3, [r7, #8]
  presc = ADCPrescTable[tmp];
 8002178:	68ba      	ldr	r2, [r7, #8]
 800217a:	f240 1344 	movw	r3, #324	; 0x144
 800217e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002182:	5c9b      	ldrb	r3, [r3, r2]
 8002184:	b2db      	uxtb	r3, r3
 8002186:	617b      	str	r3, [r7, #20]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8002188:	687b      	ldr	r3, [r7, #4]
 800218a:	68da      	ldr	r2, [r3, #12]
 800218c:	697b      	ldr	r3, [r7, #20]
 800218e:	fbb2 f2f3 	udiv	r2, r2, r3
 8002192:	687b      	ldr	r3, [r7, #4]
 8002194:	611a      	str	r2, [r3, #16]
}
 8002196:	f107 071c 	add.w	r7, r7, #28
 800219a:	46bd      	mov	sp, r7
 800219c:	bc80      	pop	{r7}
 800219e:	4770      	bx	lr

080021a0 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 80021a0:	b480      	push	{r7}
 80021a2:	b083      	sub	sp, #12
 80021a4:	af00      	add	r7, sp, #0
 80021a6:	6078      	str	r0, [r7, #4]
 80021a8:	460b      	mov	r3, r1
 80021aa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80021ac:	78fb      	ldrb	r3, [r7, #3]
 80021ae:	2b00      	cmp	r3, #0
 80021b0:	d00d      	beq.n	80021ce <RCC_AHBPeriphClockCmd+0x2e>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80021b2:	f241 0300 	movw	r3, #4096	; 0x1000
 80021b6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80021ba:	f241 0200 	movw	r2, #4096	; 0x1000
 80021be:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80021c2:	6951      	ldr	r1, [r2, #20]
 80021c4:	687a      	ldr	r2, [r7, #4]
 80021c6:	ea41 0202 	orr.w	r2, r1, r2
 80021ca:	615a      	str	r2, [r3, #20]
 80021cc:	e00e      	b.n	80021ec <RCC_AHBPeriphClockCmd+0x4c>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 80021ce:	f241 0300 	movw	r3, #4096	; 0x1000
 80021d2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80021d6:	f241 0200 	movw	r2, #4096	; 0x1000
 80021da:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80021de:	6951      	ldr	r1, [r2, #20]
 80021e0:	687a      	ldr	r2, [r7, #4]
 80021e2:	ea6f 0202 	mvn.w	r2, r2
 80021e6:	ea01 0202 	and.w	r2, r1, r2
 80021ea:	615a      	str	r2, [r3, #20]
  }
}
 80021ec:	f107 070c 	add.w	r7, r7, #12
 80021f0:	46bd      	mov	sp, r7
 80021f2:	bc80      	pop	{r7}
 80021f4:	4770      	bx	lr
 80021f6:	bf00      	nop

080021f8 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80021f8:	b480      	push	{r7}
 80021fa:	b083      	sub	sp, #12
 80021fc:	af00      	add	r7, sp, #0
 80021fe:	6078      	str	r0, [r7, #4]
 8002200:	460b      	mov	r3, r1
 8002202:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8002204:	78fb      	ldrb	r3, [r7, #3]
 8002206:	2b00      	cmp	r3, #0
 8002208:	d00d      	beq.n	8002226 <RCC_APB2PeriphClockCmd+0x2e>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800220a:	f241 0300 	movw	r3, #4096	; 0x1000
 800220e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002212:	f241 0200 	movw	r2, #4096	; 0x1000
 8002216:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800221a:	6991      	ldr	r1, [r2, #24]
 800221c:	687a      	ldr	r2, [r7, #4]
 800221e:	ea41 0202 	orr.w	r2, r1, r2
 8002222:	619a      	str	r2, [r3, #24]
 8002224:	e00e      	b.n	8002244 <RCC_APB2PeriphClockCmd+0x4c>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8002226:	f241 0300 	movw	r3, #4096	; 0x1000
 800222a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800222e:	f241 0200 	movw	r2, #4096	; 0x1000
 8002232:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002236:	6991      	ldr	r1, [r2, #24]
 8002238:	687a      	ldr	r2, [r7, #4]
 800223a:	ea6f 0202 	mvn.w	r2, r2
 800223e:	ea01 0202 	and.w	r2, r1, r2
 8002242:	619a      	str	r2, [r3, #24]
  }
}
 8002244:	f107 070c 	add.w	r7, r7, #12
 8002248:	46bd      	mov	sp, r7
 800224a:	bc80      	pop	{r7}
 800224c:	4770      	bx	lr
 800224e:	bf00      	nop

08002250 <RCC_GetFlagStatus>:
  *     @arg RCC_FLAG_LPWRRST: Low Power reset
  *   
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 8002250:	b480      	push	{r7}
 8002252:	b087      	sub	sp, #28
 8002254:	af00      	add	r7, sp, #0
 8002256:	4603      	mov	r3, r0
 8002258:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 800225a:	f04f 0300 	mov.w	r3, #0
 800225e:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 8002260:	f04f 0300 	mov.w	r3, #0
 8002264:	613b      	str	r3, [r7, #16]
  FlagStatus bitstatus = RESET;
 8002266:	f04f 0300 	mov.w	r3, #0
 800226a:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 800226c:	79fb      	ldrb	r3, [r7, #7]
 800226e:	ea4f 1353 	mov.w	r3, r3, lsr #5
 8002272:	b2db      	uxtb	r3, r3
 8002274:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
 8002276:	68fb      	ldr	r3, [r7, #12]
 8002278:	2b01      	cmp	r3, #1
 800227a:	d106      	bne.n	800228a <RCC_GetFlagStatus+0x3a>
  {
    statusreg = RCC->CR;
 800227c:	f241 0300 	movw	r3, #4096	; 0x1000
 8002280:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002284:	681b      	ldr	r3, [r3, #0]
 8002286:	613b      	str	r3, [r7, #16]
 8002288:	e00f      	b.n	80022aa <RCC_GetFlagStatus+0x5a>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 800228a:	68fb      	ldr	r3, [r7, #12]
 800228c:	2b02      	cmp	r3, #2
 800228e:	d106      	bne.n	800229e <RCC_GetFlagStatus+0x4e>
  {
    statusreg = RCC->BDCR;
 8002290:	f241 0300 	movw	r3, #4096	; 0x1000
 8002294:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002298:	6a1b      	ldr	r3, [r3, #32]
 800229a:	613b      	str	r3, [r7, #16]
 800229c:	e005      	b.n	80022aa <RCC_GetFlagStatus+0x5a>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800229e:	f241 0300 	movw	r3, #4096	; 0x1000
 80022a2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80022a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80022a8:	613b      	str	r3, [r7, #16]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 80022aa:	79fb      	ldrb	r3, [r7, #7]
 80022ac:	f003 031f 	and.w	r3, r3, #31
 80022b0:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80022b2:	68fb      	ldr	r3, [r7, #12]
 80022b4:	693a      	ldr	r2, [r7, #16]
 80022b6:	fa22 f303 	lsr.w	r3, r2, r3
 80022ba:	f003 0301 	and.w	r3, r3, #1
 80022be:	b2db      	uxtb	r3, r3
 80022c0:	2b00      	cmp	r3, #0
 80022c2:	d003      	beq.n	80022cc <RCC_GetFlagStatus+0x7c>
  {
    bitstatus = SET;
 80022c4:	f04f 0301 	mov.w	r3, #1
 80022c8:	75fb      	strb	r3, [r7, #23]
 80022ca:	e002      	b.n	80022d2 <RCC_GetFlagStatus+0x82>
  }
  else
  {
    bitstatus = RESET;
 80022cc:	f04f 0300 	mov.w	r3, #0
 80022d0:	75fb      	strb	r3, [r7, #23]
  }

  /* Return the flag status */
  return bitstatus;
 80022d2:	7dfb      	ldrb	r3, [r7, #23]
}
 80022d4:	4618      	mov	r0, r3
 80022d6:	f107 071c 	add.w	r7, r7, #28
 80022da:	46bd      	mov	sp, r7
 80022dc:	bc80      	pop	{r7}
 80022de:	4770      	bx	lr

080022e0 <DMA_DeInit>:
  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
  * @retval None
  */
void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
{
 80022e0:	b480      	push	{r7}
 80022e2:	b083      	sub	sp, #12
 80022e4:	af00      	add	r7, sp, #0
 80022e6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 80022e8:	687b      	ldr	r3, [r7, #4]
 80022ea:	681b      	ldr	r3, [r3, #0]
 80022ec:	f023 0201 	bic.w	r2, r3, #1
 80022f0:	687b      	ldr	r3, [r7, #4]
 80022f2:	601a      	str	r2, [r3, #0]
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 80022f4:	687b      	ldr	r3, [r7, #4]
 80022f6:	f04f 0200 	mov.w	r2, #0
 80022fa:	601a      	str	r2, [r3, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 80022fc:	687b      	ldr	r3, [r7, #4]
 80022fe:	f04f 0200 	mov.w	r2, #0
 8002302:	605a      	str	r2, [r3, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8002304:	687b      	ldr	r3, [r7, #4]
 8002306:	f04f 0200 	mov.w	r2, #0
 800230a:	609a      	str	r2, [r3, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 800230c:	687b      	ldr	r3, [r7, #4]
 800230e:	f04f 0200 	mov.w	r2, #0
 8002312:	60da      	str	r2, [r3, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8002314:	687a      	ldr	r2, [r7, #4]
 8002316:	f240 0308 	movw	r3, #8
 800231a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800231e:	429a      	cmp	r2, r3
 8002320:	d10c      	bne.n	800233c <DMA_DeInit+0x5c>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
 8002322:	f240 0300 	movw	r3, #0
 8002326:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800232a:	f240 0200 	movw	r2, #0
 800232e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002332:	6852      	ldr	r2, [r2, #4]
 8002334:	f042 020f 	orr.w	r2, r2, #15
 8002338:	605a      	str	r2, [r3, #4]
 800233a:	e0da      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 800233c:	687a      	ldr	r2, [r7, #4]
 800233e:	f240 031c 	movw	r3, #28
 8002342:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002346:	429a      	cmp	r2, r3
 8002348:	d10c      	bne.n	8002364 <DMA_DeInit+0x84>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
 800234a:	f240 0300 	movw	r3, #0
 800234e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002352:	f240 0200 	movw	r2, #0
 8002356:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800235a:	6852      	ldr	r2, [r2, #4]
 800235c:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 8002360:	605a      	str	r2, [r3, #4]
 8002362:	e0c6      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8002364:	687a      	ldr	r2, [r7, #4]
 8002366:	f240 0330 	movw	r3, #48	; 0x30
 800236a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800236e:	429a      	cmp	r2, r3
 8002370:	d10c      	bne.n	800238c <DMA_DeInit+0xac>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
 8002372:	f240 0300 	movw	r3, #0
 8002376:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800237a:	f240 0200 	movw	r2, #0
 800237e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002382:	6852      	ldr	r2, [r2, #4]
 8002384:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 8002388:	605a      	str	r2, [r3, #4]
 800238a:	e0b2      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 800238c:	687a      	ldr	r2, [r7, #4]
 800238e:	f240 0344 	movw	r3, #68	; 0x44
 8002392:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002396:	429a      	cmp	r2, r3
 8002398:	d10c      	bne.n	80023b4 <DMA_DeInit+0xd4>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
 800239a:	f240 0300 	movw	r3, #0
 800239e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80023a2:	f240 0200 	movw	r2, #0
 80023a6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80023aa:	6852      	ldr	r2, [r2, #4]
 80023ac:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 80023b0:	605a      	str	r2, [r3, #4]
 80023b2:	e09e      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 80023b4:	687a      	ldr	r2, [r7, #4]
 80023b6:	f240 0358 	movw	r3, #88	; 0x58
 80023ba:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80023be:	429a      	cmp	r2, r3
 80023c0:	d10c      	bne.n	80023dc <DMA_DeInit+0xfc>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
 80023c2:	f240 0300 	movw	r3, #0
 80023c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80023ca:	f240 0200 	movw	r2, #0
 80023ce:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80023d2:	6852      	ldr	r2, [r2, #4]
 80023d4:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 80023d8:	605a      	str	r2, [r3, #4]
 80023da:	e08a      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 80023dc:	687a      	ldr	r2, [r7, #4]
 80023de:	f240 036c 	movw	r3, #108	; 0x6c
 80023e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80023e6:	429a      	cmp	r2, r3
 80023e8:	d10c      	bne.n	8002404 <DMA_DeInit+0x124>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 80023ea:	f240 0300 	movw	r3, #0
 80023ee:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80023f2:	f240 0200 	movw	r2, #0
 80023f6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80023fa:	6852      	ldr	r2, [r2, #4]
 80023fc:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8002400:	605a      	str	r2, [r3, #4]
 8002402:	e076      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 8002404:	687a      	ldr	r2, [r7, #4]
 8002406:	f240 0380 	movw	r3, #128	; 0x80
 800240a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800240e:	429a      	cmp	r2, r3
 8002410:	d10c      	bne.n	800242c <DMA_DeInit+0x14c>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 8002412:	f240 0300 	movw	r3, #0
 8002416:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800241a:	f240 0200 	movw	r2, #0
 800241e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002422:	6852      	ldr	r2, [r2, #4]
 8002424:	f042 6270 	orr.w	r2, r2, #251658240	; 0xf000000
 8002428:	605a      	str	r2, [r3, #4]
 800242a:	e062      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 800242c:	687a      	ldr	r2, [r7, #4]
 800242e:	f240 4308 	movw	r3, #1032	; 0x408
 8002432:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002436:	429a      	cmp	r2, r3
 8002438:	d10c      	bne.n	8002454 <DMA_DeInit+0x174>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 800243a:	f240 4300 	movw	r3, #1024	; 0x400
 800243e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002442:	f240 4200 	movw	r2, #1024	; 0x400
 8002446:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800244a:	6852      	ldr	r2, [r2, #4]
 800244c:	f042 020f 	orr.w	r2, r2, #15
 8002450:	605a      	str	r2, [r3, #4]
 8002452:	e04e      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 8002454:	687a      	ldr	r2, [r7, #4]
 8002456:	f240 431c 	movw	r3, #1052	; 0x41c
 800245a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800245e:	429a      	cmp	r2, r3
 8002460:	d10c      	bne.n	800247c <DMA_DeInit+0x19c>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 8002462:	f240 4300 	movw	r3, #1024	; 0x400
 8002466:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800246a:	f240 4200 	movw	r2, #1024	; 0x400
 800246e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002472:	6852      	ldr	r2, [r2, #4]
 8002474:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 8002478:	605a      	str	r2, [r3, #4]
 800247a:	e03a      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 800247c:	687a      	ldr	r2, [r7, #4]
 800247e:	f240 4330 	movw	r3, #1072	; 0x430
 8002482:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002486:	429a      	cmp	r2, r3
 8002488:	d10c      	bne.n	80024a4 <DMA_DeInit+0x1c4>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 800248a:	f240 4300 	movw	r3, #1024	; 0x400
 800248e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002492:	f240 4200 	movw	r2, #1024	; 0x400
 8002496:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800249a:	6852      	ldr	r2, [r2, #4]
 800249c:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 80024a0:	605a      	str	r2, [r3, #4]
 80024a2:	e026      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 80024a4:	687a      	ldr	r2, [r7, #4]
 80024a6:	f240 4344 	movw	r3, #1092	; 0x444
 80024aa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80024ae:	429a      	cmp	r2, r3
 80024b0:	d10c      	bne.n	80024cc <DMA_DeInit+0x1ec>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 80024b2:	f240 4300 	movw	r3, #1024	; 0x400
 80024b6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80024ba:	f240 4200 	movw	r2, #1024	; 0x400
 80024be:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80024c2:	6852      	ldr	r2, [r2, #4]
 80024c4:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 80024c8:	605a      	str	r2, [r3, #4]
 80024ca:	e012      	b.n	80024f2 <DMA_DeInit+0x212>
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 80024cc:	687a      	ldr	r2, [r7, #4]
 80024ce:	f240 4358 	movw	r3, #1112	; 0x458
 80024d2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80024d6:	429a      	cmp	r2, r3
 80024d8:	d10b      	bne.n	80024f2 <DMA_DeInit+0x212>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 80024da:	f240 4300 	movw	r3, #1024	; 0x400
 80024de:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80024e2:	f240 4200 	movw	r2, #1024	; 0x400
 80024e6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80024ea:	6852      	ldr	r2, [r2, #4]
 80024ec:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 80024f0:	605a      	str	r2, [r3, #4]
    }
  }
}
 80024f2:	f107 070c 	add.w	r7, r7, #12
 80024f6:	46bd      	mov	sp, r7
 80024f8:	bc80      	pop	{r7}
 80024fa:	4770      	bx	lr

080024fc <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
  *   contains the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 80024fc:	b480      	push	{r7}
 80024fe:	b085      	sub	sp, #20
 8002500:	af00      	add	r7, sp, #0
 8002502:	6078      	str	r0, [r7, #4]
 8002504:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8002506:	f04f 0300 	mov.w	r3, #0
 800250a:	60fb      	str	r3, [r7, #12]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 800250c:	687b      	ldr	r3, [r7, #4]
 800250e:	681b      	ldr	r3, [r3, #0]
 8002510:	60fb      	str	r3, [r7, #12]
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 8002512:	68fb      	ldr	r3, [r7, #12]
 8002514:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8002518:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800251c:	60fb      	str	r3, [r7, #12]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800251e:	683b      	ldr	r3, [r7, #0]
 8002520:	689a      	ldr	r2, [r3, #8]
 8002522:	683b      	ldr	r3, [r7, #0]
 8002524:	6a1b      	ldr	r3, [r3, #32]
 8002526:	ea42 0203 	orr.w	r2, r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 800252a:	683b      	ldr	r3, [r7, #0]
 800252c:	691b      	ldr	r3, [r3, #16]
 800252e:	ea42 0203 	orr.w	r2, r2, r3
 8002532:	683b      	ldr	r3, [r7, #0]
 8002534:	695b      	ldr	r3, [r3, #20]
 8002536:	ea42 0203 	orr.w	r2, r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800253a:	683b      	ldr	r3, [r7, #0]
 800253c:	699b      	ldr	r3, [r3, #24]
 800253e:	ea42 0203 	orr.w	r2, r2, r3
 8002542:	683b      	ldr	r3, [r7, #0]
 8002544:	69db      	ldr	r3, [r3, #28]
 8002546:	ea42 0203 	orr.w	r2, r2, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 800254a:	683b      	ldr	r3, [r7, #0]
 800254c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800254e:	ea42 0203 	orr.w	r2, r2, r3
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8002552:	683b      	ldr	r3, [r7, #0]
 8002554:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002556:	ea42 0303 	orr.w	r3, r2, r3
 800255a:	68fa      	ldr	r2, [r7, #12]
 800255c:	ea42 0303 	orr.w	r3, r2, r3
 8002560:	60fb      	str	r3, [r7, #12]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8002562:	687b      	ldr	r3, [r7, #4]
 8002564:	68fa      	ldr	r2, [r7, #12]
 8002566:	601a      	str	r2, [r3, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8002568:	683b      	ldr	r3, [r7, #0]
 800256a:	68da      	ldr	r2, [r3, #12]
 800256c:	687b      	ldr	r3, [r7, #4]
 800256e:	605a      	str	r2, [r3, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8002570:	683b      	ldr	r3, [r7, #0]
 8002572:	681a      	ldr	r2, [r3, #0]
 8002574:	687b      	ldr	r3, [r7, #4]
 8002576:	609a      	str	r2, [r3, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8002578:	683b      	ldr	r3, [r7, #0]
 800257a:	685a      	ldr	r2, [r3, #4]
 800257c:	687b      	ldr	r3, [r7, #4]
 800257e:	60da      	str	r2, [r3, #12]
}
 8002580:	f107 0714 	add.w	r7, r7, #20
 8002584:	46bd      	mov	sp, r7
 8002586:	bc80      	pop	{r7}
 8002588:	4770      	bx	lr
 800258a:	bf00      	nop

0800258c <DMA_Cmd>:
  * @param  NewState: new state of the DMAy Channelx. 
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
{
 800258c:	b480      	push	{r7}
 800258e:	b083      	sub	sp, #12
 8002590:	af00      	add	r7, sp, #0
 8002592:	6078      	str	r0, [r7, #4]
 8002594:	460b      	mov	r3, r1
 8002596:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002598:	78fb      	ldrb	r3, [r7, #3]
 800259a:	2b00      	cmp	r3, #0
 800259c:	d006      	beq.n	80025ac <DMA_Cmd+0x20>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= CCR_ENABLE_Set;
 800259e:	687b      	ldr	r3, [r7, #4]
 80025a0:	681b      	ldr	r3, [r3, #0]
 80025a2:	f043 0201 	orr.w	r2, r3, #1
 80025a6:	687b      	ldr	r3, [r7, #4]
 80025a8:	601a      	str	r2, [r3, #0]
 80025aa:	e005      	b.n	80025b8 <DMA_Cmd+0x2c>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 80025ac:	687b      	ldr	r3, [r7, #4]
 80025ae:	681b      	ldr	r3, [r3, #0]
 80025b0:	f023 0201 	bic.w	r2, r3, #1
 80025b4:	687b      	ldr	r3, [r7, #4]
 80025b6:	601a      	str	r2, [r3, #0]
  }
}
 80025b8:	f107 070c 	add.w	r7, r7, #12
 80025bc:	46bd      	mov	sp, r7
 80025be:	bc80      	pop	{r7}
 80025c0:	4770      	bx	lr
 80025c2:	bf00      	nop

080025c4 <DMA_ITConfig>:
  * @param  NewState: new state of the specified DMA interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)
{
 80025c4:	b480      	push	{r7}
 80025c6:	b085      	sub	sp, #20
 80025c8:	af00      	add	r7, sp, #0
 80025ca:	60f8      	str	r0, [r7, #12]
 80025cc:	60b9      	str	r1, [r7, #8]
 80025ce:	4613      	mov	r3, r2
 80025d0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80025d2:	79fb      	ldrb	r3, [r7, #7]
 80025d4:	2b00      	cmp	r3, #0
 80025d6:	d007      	beq.n	80025e8 <DMA_ITConfig+0x24>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 80025d8:	68fb      	ldr	r3, [r7, #12]
 80025da:	681a      	ldr	r2, [r3, #0]
 80025dc:	68bb      	ldr	r3, [r7, #8]
 80025de:	ea42 0203 	orr.w	r2, r2, r3
 80025e2:	68fb      	ldr	r3, [r7, #12]
 80025e4:	601a      	str	r2, [r3, #0]
 80025e6:	e008      	b.n	80025fa <DMA_ITConfig+0x36>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 80025e8:	68fb      	ldr	r3, [r7, #12]
 80025ea:	681a      	ldr	r2, [r3, #0]
 80025ec:	68bb      	ldr	r3, [r7, #8]
 80025ee:	ea6f 0303 	mvn.w	r3, r3
 80025f2:	ea02 0203 	and.w	r2, r2, r3
 80025f6:	68fb      	ldr	r3, [r7, #12]
 80025f8:	601a      	str	r2, [r3, #0]
  }
}
 80025fa:	f107 0714 	add.w	r7, r7, #20
 80025fe:	46bd      	mov	sp, r7
 8002600:	bc80      	pop	{r7}
 8002602:	4770      	bx	lr

08002604 <DMA_ClearFlag>:
  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
  * @retval None
  */
void DMA_ClearFlag(uint32_t DMA_FLAG)
{
 8002604:	b480      	push	{r7}
 8002606:	b083      	sub	sp, #12
 8002608:	af00      	add	r7, sp, #0
 800260a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
  /* Calculate the used DMA */

  if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
 800260c:	687b      	ldr	r3, [r7, #4]
 800260e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002612:	2b00      	cmp	r3, #0
 8002614:	d006      	beq.n	8002624 <DMA_ClearFlag+0x20>
  {
    /* Clear the selected DMA flags */
    DMA2->IFCR = DMA_FLAG;
 8002616:	f240 4300 	movw	r3, #1024	; 0x400
 800261a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800261e:	687a      	ldr	r2, [r7, #4]
 8002620:	605a      	str	r2, [r3, #4]
 8002622:	e005      	b.n	8002630 <DMA_ClearFlag+0x2c>
  }
  else
  {
    /* Clear the selected DMA flags */
    DMA1->IFCR = DMA_FLAG;
 8002624:	f240 0300 	movw	r3, #0
 8002628:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800262c:	687a      	ldr	r2, [r7, #4]
 800262e:	605a      	str	r2, [r3, #4]
  }
}
 8002630:	f107 070c 	add.w	r7, r7, #12
 8002634:	46bd      	mov	sp, r7
 8002636:	bc80      	pop	{r7}
 8002638:	4770      	bx	lr
 800263a:	bf00      	nop

0800263c <TIM_TimeBaseInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
  *   structure that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 800263c:	b480      	push	{r7}
 800263e:	b083      	sub	sp, #12
 8002640:	af00      	add	r7, sp, #0
 8002642:	6078      	str	r0, [r7, #4]
 8002644:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
  /* Select the Counter Mode and set the clock division */
  TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
 8002646:	687b      	ldr	r3, [r7, #4]
 8002648:	881b      	ldrh	r3, [r3, #0]
 800264a:	b29b      	uxth	r3, r3
 800264c:	f003 038f 	and.w	r3, r3, #143	; 0x8f
 8002650:	687a      	ldr	r2, [r7, #4]
 8002652:	8013      	strh	r3, [r2, #0]
  TIMx->CR1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision |
 8002654:	687b      	ldr	r3, [r7, #4]
 8002656:	881b      	ldrh	r3, [r3, #0]
 8002658:	b29a      	uxth	r2, r3
 800265a:	683b      	ldr	r3, [r7, #0]
 800265c:	88d9      	ldrh	r1, [r3, #6]
 800265e:	683b      	ldr	r3, [r7, #0]
 8002660:	885b      	ldrh	r3, [r3, #2]
 8002662:	ea41 0303 	orr.w	r3, r1, r3
 8002666:	b29b      	uxth	r3, r3
 8002668:	ea42 0303 	orr.w	r3, r2, r3
 800266c:	b29a      	uxth	r2, r3
 800266e:	687b      	ldr	r3, [r7, #4]
 8002670:	801a      	strh	r2, [r3, #0]
                TIM_TimeBaseInitStruct->TIM_CounterMode;
  
  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8002672:	683b      	ldr	r3, [r7, #0]
 8002674:	889a      	ldrh	r2, [r3, #4]
 8002676:	687b      	ldr	r3, [r7, #4]
 8002678:	859a      	strh	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 800267a:	683b      	ldr	r3, [r7, #0]
 800267c:	881a      	ldrh	r2, [r3, #0]
 800267e:	687b      	ldr	r3, [r7, #4]
 8002680:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((((uint32_t) TIMx) == TIM1_BASE) || (((uint32_t) TIMx) == TIM8_BASE))  
 8002682:	687a      	ldr	r2, [r7, #4]
 8002684:	f642 4300 	movw	r3, #11264	; 0x2c00
 8002688:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800268c:	429a      	cmp	r2, r3
 800268e:	d006      	beq.n	800269e <TIM_TimeBaseInit+0x62>
 8002690:	687a      	ldr	r2, [r7, #4]
 8002692:	f243 4300 	movw	r3, #13312	; 0x3400
 8002696:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800269a:	429a      	cmp	r2, r3
 800269c:	d104      	bne.n	80026a8 <TIM_TimeBaseInit+0x6c>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 800269e:	683b      	ldr	r3, [r7, #0]
 80026a0:	7a1b      	ldrb	r3, [r3, #8]
 80026a2:	461a      	mov	r2, r3
 80026a4:	687b      	ldr	r3, [r7, #4]
 80026a6:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 80026a8:	687b      	ldr	r3, [r7, #4]
 80026aa:	f04f 0201 	mov.w	r2, #1
 80026ae:	829a      	strh	r2, [r3, #20]
}
 80026b0:	f107 070c 	add.w	r7, r7, #12
 80026b4:	46bd      	mov	sp, r7
 80026b6:	bc80      	pop	{r7}
 80026b8:	4770      	bx	lr
 80026ba:	bf00      	nop

080026bc <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
  *   that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 80026bc:	b580      	push	{r7, lr}
 80026be:	b082      	sub	sp, #8
 80026c0:	af00      	add	r7, sp, #0
 80026c2:	6078      	str	r0, [r7, #4]
 80026c4:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 80026c6:	683b      	ldr	r3, [r7, #0]
 80026c8:	881b      	ldrh	r3, [r3, #0]
 80026ca:	2b00      	cmp	r3, #0
 80026cc:	d115      	bne.n	80026fa <TIM_ICInit+0x3e>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 80026ce:	683b      	ldr	r3, [r7, #0]
 80026d0:	8859      	ldrh	r1, [r3, #2]
 80026d2:	683b      	ldr	r3, [r7, #0]
 80026d4:	889a      	ldrh	r2, [r3, #4]
 80026d6:	683b      	ldr	r3, [r7, #0]
 80026d8:	891b      	ldrh	r3, [r3, #8]
 80026da:	6878      	ldr	r0, [r7, #4]
 80026dc:	f642 2c01 	movw	ip, #10753	; 0x2a01
 80026e0:	f6c0 0c00 	movt	ip, #2048	; 0x800
 80026e4:	47e0      	blx	ip
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80026e6:	683b      	ldr	r3, [r7, #0]
 80026e8:	88db      	ldrh	r3, [r3, #6]
 80026ea:	6878      	ldr	r0, [r7, #4]
 80026ec:	4619      	mov	r1, r3
 80026ee:	f642 0329 	movw	r3, #10281	; 0x2829
 80026f2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80026f6:	4798      	blx	r3
 80026f8:	e048      	b.n	800278c <TIM_ICInit+0xd0>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 80026fa:	683b      	ldr	r3, [r7, #0]
 80026fc:	881b      	ldrh	r3, [r3, #0]
 80026fe:	2b04      	cmp	r3, #4
 8002700:	d115      	bne.n	800272e <TIM_ICInit+0x72>
  {
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8002702:	683b      	ldr	r3, [r7, #0]
 8002704:	8859      	ldrh	r1, [r3, #2]
 8002706:	683b      	ldr	r3, [r7, #0]
 8002708:	889a      	ldrh	r2, [r3, #4]
 800270a:	683b      	ldr	r3, [r7, #0]
 800270c:	891b      	ldrh	r3, [r3, #8]
 800270e:	6878      	ldr	r0, [r7, #4]
 8002710:	f642 2c91 	movw	ip, #10897	; 0x2a91
 8002714:	f6c0 0c00 	movt	ip, #2048	; 0x800
 8002718:	47e0      	blx	ip
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800271a:	683b      	ldr	r3, [r7, #0]
 800271c:	88db      	ldrh	r3, [r3, #6]
 800271e:	6878      	ldr	r0, [r7, #4]
 8002720:	4619      	mov	r1, r3
 8002722:	f642 036d 	movw	r3, #10349	; 0x286d
 8002726:	f6c0 0300 	movt	r3, #2048	; 0x800
 800272a:	4798      	blx	r3
 800272c:	e02e      	b.n	800278c <TIM_ICInit+0xd0>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 800272e:	683b      	ldr	r3, [r7, #0]
 8002730:	881b      	ldrh	r3, [r3, #0]
 8002732:	2b08      	cmp	r3, #8
 8002734:	d115      	bne.n	8002762 <TIM_ICInit+0xa6>
  {
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 8002736:	683b      	ldr	r3, [r7, #0]
 8002738:	8859      	ldrh	r1, [r3, #2]
 800273a:	683b      	ldr	r3, [r7, #0]
 800273c:	889a      	ldrh	r2, [r3, #4]
 800273e:	683b      	ldr	r3, [r7, #0]
 8002740:	891b      	ldrh	r3, [r3, #8]
 8002742:	6878      	ldr	r0, [r7, #4]
 8002744:	f642 3c3d 	movw	ip, #11069	; 0x2b3d
 8002748:	f6c0 0c00 	movt	ip, #2048	; 0x800
 800274c:	47e0      	blx	ip
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800274e:	683b      	ldr	r3, [r7, #0]
 8002750:	88db      	ldrh	r3, [r3, #6]
 8002752:	6878      	ldr	r0, [r7, #4]
 8002754:	4619      	mov	r1, r3
 8002756:	f642 03b5 	movw	r3, #10421	; 0x28b5
 800275a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800275e:	4798      	blx	r3
 8002760:	e014      	b.n	800278c <TIM_ICInit+0xd0>
  }
  else
  {
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8002762:	683b      	ldr	r3, [r7, #0]
 8002764:	8859      	ldrh	r1, [r3, #2]
 8002766:	683b      	ldr	r3, [r7, #0]
 8002768:	889a      	ldrh	r2, [r3, #4]
 800276a:	683b      	ldr	r3, [r7, #0]
 800276c:	891b      	ldrh	r3, [r3, #8]
 800276e:	6878      	ldr	r0, [r7, #4]
 8002770:	f642 3cd9 	movw	ip, #11225	; 0x2bd9
 8002774:	f6c0 0c00 	movt	ip, #2048	; 0x800
 8002778:	47e0      	blx	ip
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800277a:	683b      	ldr	r3, [r7, #0]
 800277c:	88db      	ldrh	r3, [r3, #6]
 800277e:	6878      	ldr	r0, [r7, #4]
 8002780:	4619      	mov	r1, r3
 8002782:	f642 03f9 	movw	r3, #10489	; 0x28f9
 8002786:	f6c0 0300 	movt	r3, #2048	; 0x800
 800278a:	4798      	blx	r3
  }
}
 800278c:	f107 0708 	add.w	r7, r7, #8
 8002790:	46bd      	mov	sp, r7
 8002792:	bd80      	pop	{r7, pc}

08002794 <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8002794:	b480      	push	{r7}
 8002796:	b083      	sub	sp, #12
 8002798:	af00      	add	r7, sp, #0
 800279a:	6078      	str	r0, [r7, #4]
 800279c:	460b      	mov	r3, r1
 800279e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80027a0:	78fb      	ldrb	r3, [r7, #3]
 80027a2:	2b00      	cmp	r3, #0
 80027a4:	d008      	beq.n	80027b8 <TIM_Cmd+0x24>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= CR1_CEN_Set;
 80027a6:	687b      	ldr	r3, [r7, #4]
 80027a8:	881b      	ldrh	r3, [r3, #0]
 80027aa:	b29b      	uxth	r3, r3
 80027ac:	f043 0301 	orr.w	r3, r3, #1
 80027b0:	b29a      	uxth	r2, r3
 80027b2:	687b      	ldr	r3, [r7, #4]
 80027b4:	801a      	strh	r2, [r3, #0]
 80027b6:	e00c      	b.n	80027d2 <TIM_Cmd+0x3e>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= CR1_CEN_Reset;
 80027b8:	687b      	ldr	r3, [r7, #4]
 80027ba:	881b      	ldrh	r3, [r3, #0]
 80027bc:	b29b      	uxth	r3, r3
 80027be:	461a      	mov	r2, r3
 80027c0:	f240 33fe 	movw	r3, #1022	; 0x3fe
 80027c4:	f2c0 0300 	movt	r3, #0
 80027c8:	ea02 0303 	and.w	r3, r2, r3
 80027cc:	461a      	mov	r2, r3
 80027ce:	687b      	ldr	r3, [r7, #4]
 80027d0:	801a      	strh	r2, [r3, #0]
  }
}
 80027d2:	f107 070c 	add.w	r7, r7, #12
 80027d6:	46bd      	mov	sp, r7
 80027d8:	bc80      	pop	{r7}
 80027da:	4770      	bx	lr

080027dc <TIM_ITConfig>:
  * @param  NewState: new state of the TIM interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
 80027dc:	b480      	push	{r7}
 80027de:	b083      	sub	sp, #12
 80027e0:	af00      	add	r7, sp, #0
 80027e2:	6078      	str	r0, [r7, #4]
 80027e4:	4613      	mov	r3, r2
 80027e6:	460a      	mov	r2, r1
 80027e8:	807a      	strh	r2, [r7, #2]
 80027ea:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80027ec:	787b      	ldrb	r3, [r7, #1]
 80027ee:	2b00      	cmp	r3, #0
 80027f0:	d009      	beq.n	8002806 <TIM_ITConfig+0x2a>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 80027f2:	687b      	ldr	r3, [r7, #4]
 80027f4:	899b      	ldrh	r3, [r3, #12]
 80027f6:	b29a      	uxth	r2, r3
 80027f8:	887b      	ldrh	r3, [r7, #2]
 80027fa:	ea42 0303 	orr.w	r3, r2, r3
 80027fe:	b29a      	uxth	r2, r3
 8002800:	687b      	ldr	r3, [r7, #4]
 8002802:	819a      	strh	r2, [r3, #12]
 8002804:	e00b      	b.n	800281e <TIM_ITConfig+0x42>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 8002806:	687b      	ldr	r3, [r7, #4]
 8002808:	899b      	ldrh	r3, [r3, #12]
 800280a:	b29a      	uxth	r2, r3
 800280c:	887b      	ldrh	r3, [r7, #2]
 800280e:	ea6f 0303 	mvn.w	r3, r3
 8002812:	b29b      	uxth	r3, r3
 8002814:	ea02 0303 	and.w	r3, r2, r3
 8002818:	b29a      	uxth	r2, r3
 800281a:	687b      	ldr	r3, [r7, #4]
 800281c:	819a      	strh	r2, [r3, #12]
  }
}
 800281e:	f107 070c 	add.w	r7, r7, #12
 8002822:	46bd      	mov	sp, r7
 8002824:	bc80      	pop	{r7}
 8002826:	4770      	bx	lr

08002828 <TIM_SetIC1Prescaler>:
  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 8002828:	b480      	push	{r7}
 800282a:	b083      	sub	sp, #12
 800282c:	af00      	add	r7, sp, #0
 800282e:	6078      	str	r0, [r7, #4]
 8002830:	460b      	mov	r3, r1
 8002832:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
 8002834:	687b      	ldr	r3, [r7, #4]
 8002836:	8b1b      	ldrh	r3, [r3, #24]
 8002838:	b29b      	uxth	r3, r3
 800283a:	461a      	mov	r2, r3
 800283c:	f64f 73f3 	movw	r3, #65523	; 0xfff3
 8002840:	f2c0 0300 	movt	r3, #0
 8002844:	ea02 0303 	and.w	r3, r2, r3
 8002848:	461a      	mov	r2, r3
 800284a:	687b      	ldr	r3, [r7, #4]
 800284c:	831a      	strh	r2, [r3, #24]
  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 800284e:	687b      	ldr	r3, [r7, #4]
 8002850:	8b1b      	ldrh	r3, [r3, #24]
 8002852:	b29a      	uxth	r2, r3
 8002854:	887b      	ldrh	r3, [r7, #2]
 8002856:	ea42 0303 	orr.w	r3, r2, r3
 800285a:	b29a      	uxth	r2, r3
 800285c:	687b      	ldr	r3, [r7, #4]
 800285e:	831a      	strh	r2, [r3, #24]
}
 8002860:	f107 070c 	add.w	r7, r7, #12
 8002864:	46bd      	mov	sp, r7
 8002866:	bc80      	pop	{r7}
 8002868:	4770      	bx	lr
 800286a:	bf00      	nop

0800286c <TIM_SetIC2Prescaler>:
  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 800286c:	b480      	push	{r7}
 800286e:	b083      	sub	sp, #12
 8002870:	af00      	add	r7, sp, #0
 8002872:	6078      	str	r0, [r7, #4]
 8002874:	460b      	mov	r3, r1
 8002876:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
 8002878:	687b      	ldr	r3, [r7, #4]
 800287a:	8b1b      	ldrh	r3, [r3, #24]
 800287c:	b29b      	uxth	r3, r3
 800287e:	461a      	mov	r2, r3
 8002880:	f24f 33ff 	movw	r3, #62463	; 0xf3ff
 8002884:	f2c0 0300 	movt	r3, #0
 8002888:	ea02 0303 	and.w	r3, r2, r3
 800288c:	461a      	mov	r2, r3
 800288e:	687b      	ldr	r3, [r7, #4]
 8002890:	831a      	strh	r2, [r3, #24]
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8002892:	687b      	ldr	r3, [r7, #4]
 8002894:	8b1b      	ldrh	r3, [r3, #24]
 8002896:	b29a      	uxth	r2, r3
 8002898:	887b      	ldrh	r3, [r7, #2]
 800289a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800289e:	b29b      	uxth	r3, r3
 80028a0:	ea42 0303 	orr.w	r3, r2, r3
 80028a4:	b29a      	uxth	r2, r3
 80028a6:	687b      	ldr	r3, [r7, #4]
 80028a8:	831a      	strh	r2, [r3, #24]
}
 80028aa:	f107 070c 	add.w	r7, r7, #12
 80028ae:	46bd      	mov	sp, r7
 80028b0:	bc80      	pop	{r7}
 80028b2:	4770      	bx	lr

080028b4 <TIM_SetIC3Prescaler>:
  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
 80028b4:	b480      	push	{r7}
 80028b6:	b083      	sub	sp, #12
 80028b8:	af00      	add	r7, sp, #0
 80028ba:	6078      	str	r0, [r7, #4]
 80028bc:	460b      	mov	r3, r1
 80028be:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
 80028c0:	687b      	ldr	r3, [r7, #4]
 80028c2:	8b9b      	ldrh	r3, [r3, #28]
 80028c4:	b29b      	uxth	r3, r3
 80028c6:	461a      	mov	r2, r3
 80028c8:	f64f 73f3 	movw	r3, #65523	; 0xfff3
 80028cc:	f2c0 0300 	movt	r3, #0
 80028d0:	ea02 0303 	and.w	r3, r2, r3
 80028d4:	461a      	mov	r2, r3
 80028d6:	687b      	ldr	r3, [r7, #4]
 80028d8:	839a      	strh	r2, [r3, #28]
  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 80028da:	687b      	ldr	r3, [r7, #4]
 80028dc:	8b9b      	ldrh	r3, [r3, #28]
 80028de:	b29a      	uxth	r2, r3
 80028e0:	887b      	ldrh	r3, [r7, #2]
 80028e2:	ea42 0303 	orr.w	r3, r2, r3
 80028e6:	b29a      	uxth	r2, r3
 80028e8:	687b      	ldr	r3, [r7, #4]
 80028ea:	839a      	strh	r2, [r3, #28]
}
 80028ec:	f107 070c 	add.w	r7, r7, #12
 80028f0:	46bd      	mov	sp, r7
 80028f2:	bc80      	pop	{r7}
 80028f4:	4770      	bx	lr
 80028f6:	bf00      	nop

080028f8 <TIM_SetIC4Prescaler>:
  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{  
 80028f8:	b480      	push	{r7}
 80028fa:	b083      	sub	sp, #12
 80028fc:	af00      	add	r7, sp, #0
 80028fe:	6078      	str	r0, [r7, #4]
 8002900:	460b      	mov	r3, r1
 8002902:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
 8002904:	687b      	ldr	r3, [r7, #4]
 8002906:	8b9b      	ldrh	r3, [r3, #28]
 8002908:	b29b      	uxth	r3, r3
 800290a:	461a      	mov	r2, r3
 800290c:	f24f 33ff 	movw	r3, #62463	; 0xf3ff
 8002910:	f2c0 0300 	movt	r3, #0
 8002914:	ea02 0303 	and.w	r3, r2, r3
 8002918:	461a      	mov	r2, r3
 800291a:	687b      	ldr	r3, [r7, #4]
 800291c:	839a      	strh	r2, [r3, #28]
  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 800291e:	687b      	ldr	r3, [r7, #4]
 8002920:	8b9b      	ldrh	r3, [r3, #28]
 8002922:	b29a      	uxth	r2, r3
 8002924:	887b      	ldrh	r3, [r7, #2]
 8002926:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800292a:	b29b      	uxth	r3, r3
 800292c:	ea42 0303 	orr.w	r3, r2, r3
 8002930:	b29a      	uxth	r2, r3
 8002932:	687b      	ldr	r3, [r7, #4]
 8002934:	839a      	strh	r2, [r3, #28]
}
 8002936:	f107 070c 	add.w	r7, r7, #12
 800293a:	46bd      	mov	sp, r7
 800293c:	bc80      	pop	{r7}
 800293e:	4770      	bx	lr

08002940 <TIM_GetCapture3>:
  * @brief  Gets the TIMx Input Capture 3 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 3 Register value.
  */
uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
{
 8002940:	b480      	push	{r7}
 8002942:	b083      	sub	sp, #12
 8002944:	af00      	add	r7, sp, #0
 8002946:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 8002948:	687b      	ldr	r3, [r7, #4]
 800294a:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800294c:	b29b      	uxth	r3, r3
}
 800294e:	4618      	mov	r0, r3
 8002950:	f107 070c 	add.w	r7, r7, #12
 8002954:	46bd      	mov	sp, r7
 8002956:	bc80      	pop	{r7}
 8002958:	4770      	bx	lr
 800295a:	bf00      	nop

0800295c <TIM_GetCapture4>:
  * @brief  Gets the TIMx Input Capture 4 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 4 Register value.
  */
uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
{
 800295c:	b480      	push	{r7}
 800295e:	b083      	sub	sp, #12
 8002960:	af00      	add	r7, sp, #0
 8002962:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx));
  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 8002964:	687b      	ldr	r3, [r7, #4]
 8002966:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 800296a:	b29b      	uxth	r3, r3
}
 800296c:	4618      	mov	r0, r3
 800296e:	f107 070c 	add.w	r7, r7, #12
 8002972:	46bd      	mov	sp, r7
 8002974:	bc80      	pop	{r7}
 8002976:	4770      	bx	lr

08002978 <TIM_GetITStatus>:
  *   - TIM6 and TIM7 can generate only an update interrupt.
  *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.  
  * @retval The new state of the TIM_IT(SET or RESET).
  */
ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 8002978:	b480      	push	{r7}
 800297a:	b085      	sub	sp, #20
 800297c:	af00      	add	r7, sp, #0
 800297e:	6078      	str	r0, [r7, #4]
 8002980:	460b      	mov	r3, r1
 8002982:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 8002984:	f04f 0300 	mov.w	r3, #0
 8002988:	72fb      	strb	r3, [r7, #11]
  uint16_t itstatus = 0x0, itenable = 0x0;
 800298a:	f04f 0300 	mov.w	r3, #0
 800298e:	81bb      	strh	r3, [r7, #12]
 8002990:	f04f 0300 	mov.w	r3, #0
 8002994:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8002996:	687b      	ldr	r3, [r7, #4]
 8002998:	8a1b      	ldrh	r3, [r3, #16]
 800299a:	b29a      	uxth	r2, r3
 800299c:	887b      	ldrh	r3, [r7, #2]
 800299e:	ea02 0303 	and.w	r3, r2, r3
 80029a2:	81bb      	strh	r3, [r7, #12]
  
  itenable = TIMx->DIER & TIM_IT;
 80029a4:	687b      	ldr	r3, [r7, #4]
 80029a6:	899b      	ldrh	r3, [r3, #12]
 80029a8:	b29a      	uxth	r2, r3
 80029aa:	887b      	ldrh	r3, [r7, #2]
 80029ac:	ea02 0303 	and.w	r3, r2, r3
 80029b0:	81fb      	strh	r3, [r7, #14]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80029b2:	89bb      	ldrh	r3, [r7, #12]
 80029b4:	2b00      	cmp	r3, #0
 80029b6:	d006      	beq.n	80029c6 <TIM_GetITStatus+0x4e>
 80029b8:	89fb      	ldrh	r3, [r7, #14]
 80029ba:	2b00      	cmp	r3, #0
 80029bc:	d003      	beq.n	80029c6 <TIM_GetITStatus+0x4e>
  {
    bitstatus = SET;
 80029be:	f04f 0301 	mov.w	r3, #1
 80029c2:	72fb      	strb	r3, [r7, #11]
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
  
  itenable = TIMx->DIER & TIM_IT;
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80029c4:	e002      	b.n	80029cc <TIM_GetITStatus+0x54>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 80029c6:	f04f 0300 	mov.w	r3, #0
 80029ca:	72fb      	strb	r3, [r7, #11]
  }
  return bitstatus;
 80029cc:	7afb      	ldrb	r3, [r7, #11]
}
 80029ce:	4618      	mov	r0, r3
 80029d0:	f107 0714 	add.w	r7, r7, #20
 80029d4:	46bd      	mov	sp, r7
 80029d6:	bc80      	pop	{r7}
 80029d8:	4770      	bx	lr
 80029da:	bf00      	nop

080029dc <TIM_ClearITPendingBit>:
  *   - TIM6 and TIM7 can generate only an update interrupt.
  *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.    
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 80029dc:	b480      	push	{r7}
 80029de:	b083      	sub	sp, #12
 80029e0:	af00      	add	r7, sp, #0
 80029e2:	6078      	str	r0, [r7, #4]
 80029e4:	460b      	mov	r3, r1
 80029e6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 80029e8:	887b      	ldrh	r3, [r7, #2]
 80029ea:	ea6f 0303 	mvn.w	r3, r3
 80029ee:	b29a      	uxth	r2, r3
 80029f0:	687b      	ldr	r3, [r7, #4]
 80029f2:	821a      	strh	r2, [r3, #16]
}
 80029f4:	f107 070c 	add.w	r7, r7, #12
 80029f8:	46bd      	mov	sp, r7
 80029fa:	bc80      	pop	{r7}
 80029fc:	4770      	bx	lr
 80029fe:	bf00      	nop

08002a00 <TI1_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8002a00:	b480      	push	{r7}
 8002a02:	b087      	sub	sp, #28
 8002a04:	af00      	add	r7, sp, #0
 8002a06:	60f8      	str	r0, [r7, #12]
 8002a08:	8179      	strh	r1, [r7, #10]
 8002a0a:	813a      	strh	r2, [r7, #8]
 8002a0c:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0;
 8002a0e:	f04f 0300 	mov.w	r3, #0
 8002a12:	82bb      	strh	r3, [r7, #20]
 8002a14:	f04f 0300 	mov.w	r3, #0
 8002a18:	82fb      	strh	r3, [r7, #22]
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= CCER_CC1E_Reset;
 8002a1a:	68fb      	ldr	r3, [r7, #12]
 8002a1c:	8c1b      	ldrh	r3, [r3, #32]
 8002a1e:	b29b      	uxth	r3, r3
 8002a20:	461a      	mov	r2, r3
 8002a22:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8002a26:	f2c0 0300 	movt	r3, #0
 8002a2a:	ea02 0303 	and.w	r3, r2, r3
 8002a2e:	461a      	mov	r2, r3
 8002a30:	68fb      	ldr	r3, [r7, #12]
 8002a32:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002a34:	68fb      	ldr	r3, [r7, #12]
 8002a36:	8b1b      	ldrh	r3, [r3, #24]
 8002a38:	82bb      	strh	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 8002a3a:	68fb      	ldr	r3, [r7, #12]
 8002a3c:	8c1b      	ldrh	r3, [r3, #32]
 8002a3e:	82fb      	strh	r3, [r7, #22]
  /* Select the Input and set the filter */
  tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
 8002a40:	8abb      	ldrh	r3, [r7, #20]
 8002a42:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
 8002a46:	82bb      	strh	r3, [r7, #20]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002a48:	88fb      	ldrh	r3, [r7, #6]
 8002a4a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002a4e:	b29a      	uxth	r2, r3
 8002a50:	893b      	ldrh	r3, [r7, #8]
 8002a52:	ea42 0303 	orr.w	r3, r2, r3
 8002a56:	b29a      	uxth	r2, r3
 8002a58:	8abb      	ldrh	r3, [r7, #20]
 8002a5a:	ea42 0303 	orr.w	r3, r2, r3
 8002a5e:	82bb      	strh	r3, [r7, #20]
  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= CCER_CC1P_Reset;
 8002a60:	8afb      	ldrh	r3, [r7, #22]
 8002a62:	f023 0302 	bic.w	r3, r3, #2
 8002a66:	82fb      	strh	r3, [r7, #22]
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)CCER_CC1E_Set);
 8002a68:	897a      	ldrh	r2, [r7, #10]
 8002a6a:	8afb      	ldrh	r3, [r7, #22]
 8002a6c:	ea42 0303 	orr.w	r3, r2, r3
 8002a70:	b29b      	uxth	r3, r3
 8002a72:	f043 0301 	orr.w	r3, r3, #1
 8002a76:	82fb      	strh	r3, [r7, #22]
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8002a78:	68fb      	ldr	r3, [r7, #12]
 8002a7a:	8aba      	ldrh	r2, [r7, #20]
 8002a7c:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8002a7e:	68fb      	ldr	r3, [r7, #12]
 8002a80:	8afa      	ldrh	r2, [r7, #22]
 8002a82:	841a      	strh	r2, [r3, #32]
}
 8002a84:	f107 071c 	add.w	r7, r7, #28
 8002a88:	46bd      	mov	sp, r7
 8002a8a:	bc80      	pop	{r7}
 8002a8c:	4770      	bx	lr
 8002a8e:	bf00      	nop

08002a90 <TI2_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8002a90:	b480      	push	{r7}
 8002a92:	b087      	sub	sp, #28
 8002a94:	af00      	add	r7, sp, #0
 8002a96:	60f8      	str	r0, [r7, #12]
 8002a98:	8179      	strh	r1, [r7, #10]
 8002a9a:	813a      	strh	r2, [r7, #8]
 8002a9c:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
 8002a9e:	f04f 0300 	mov.w	r3, #0
 8002aa2:	827b      	strh	r3, [r7, #18]
 8002aa4:	f04f 0300 	mov.w	r3, #0
 8002aa8:	82bb      	strh	r3, [r7, #20]
 8002aaa:	f04f 0300 	mov.w	r3, #0
 8002aae:	82fb      	strh	r3, [r7, #22]
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= CCER_CC2E_Reset;
 8002ab0:	68fb      	ldr	r3, [r7, #12]
 8002ab2:	8c1b      	ldrh	r3, [r3, #32]
 8002ab4:	b29b      	uxth	r3, r3
 8002ab6:	461a      	mov	r2, r3
 8002ab8:	f64f 73ef 	movw	r3, #65519	; 0xffef
 8002abc:	f2c0 0300 	movt	r3, #0
 8002ac0:	ea02 0303 	and.w	r3, r2, r3
 8002ac4:	461a      	mov	r2, r3
 8002ac6:	68fb      	ldr	r3, [r7, #12]
 8002ac8:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002aca:	68fb      	ldr	r3, [r7, #12]
 8002acc:	8b1b      	ldrh	r3, [r3, #24]
 8002ace:	827b      	strh	r3, [r7, #18]
  tmpccer = TIMx->CCER;
 8002ad0:	68fb      	ldr	r3, [r7, #12]
 8002ad2:	8c1b      	ldrh	r3, [r3, #32]
 8002ad4:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 8002ad6:	897b      	ldrh	r3, [r7, #10]
 8002ad8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002adc:	82fb      	strh	r3, [r7, #22]
  /* Select the Input and set the filter */
  tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
 8002ade:	8a7b      	ldrh	r3, [r7, #18]
 8002ae0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002ae4:	ea4f 5303 	mov.w	r3, r3, lsl #20
 8002ae8:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8002aec:	827b      	strh	r3, [r7, #18]
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8002aee:	88fb      	ldrh	r3, [r7, #6]
 8002af0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8002af4:	b29a      	uxth	r2, r3
 8002af6:	8a7b      	ldrh	r3, [r7, #18]
 8002af8:	ea42 0303 	orr.w	r3, r2, r3
 8002afc:	827b      	strh	r3, [r7, #18]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8002afe:	893b      	ldrh	r3, [r7, #8]
 8002b00:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8002b04:	b29a      	uxth	r2, r3
 8002b06:	8a7b      	ldrh	r3, [r7, #18]
 8002b08:	ea42 0303 	orr.w	r3, r2, r3
 8002b0c:	827b      	strh	r3, [r7, #18]
  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= CCER_CC2P_Reset;
 8002b0e:	8abb      	ldrh	r3, [r7, #20]
 8002b10:	f023 0320 	bic.w	r3, r3, #32
 8002b14:	82bb      	strh	r3, [r7, #20]
  tmpccer |=  (uint16_t)(tmp | (uint16_t)CCER_CC2E_Set);
 8002b16:	8afa      	ldrh	r2, [r7, #22]
 8002b18:	8abb      	ldrh	r3, [r7, #20]
 8002b1a:	ea42 0303 	orr.w	r3, r2, r3
 8002b1e:	b29b      	uxth	r3, r3
 8002b20:	f043 0310 	orr.w	r3, r3, #16
 8002b24:	82bb      	strh	r3, [r7, #20]
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8002b26:	68fb      	ldr	r3, [r7, #12]
 8002b28:	8a7a      	ldrh	r2, [r7, #18]
 8002b2a:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8002b2c:	68fb      	ldr	r3, [r7, #12]
 8002b2e:	8aba      	ldrh	r2, [r7, #20]
 8002b30:	841a      	strh	r2, [r3, #32]
}
 8002b32:	f107 071c 	add.w	r7, r7, #28
 8002b36:	46bd      	mov	sp, r7
 8002b38:	bc80      	pop	{r7}
 8002b3a:	4770      	bx	lr

08002b3c <TI3_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8002b3c:	b480      	push	{r7}
 8002b3e:	b087      	sub	sp, #28
 8002b40:	af00      	add	r7, sp, #0
 8002b42:	60f8      	str	r0, [r7, #12]
 8002b44:	8179      	strh	r1, [r7, #10]
 8002b46:	813a      	strh	r2, [r7, #8]
 8002b48:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
 8002b4a:	f04f 0300 	mov.w	r3, #0
 8002b4e:	827b      	strh	r3, [r7, #18]
 8002b50:	f04f 0300 	mov.w	r3, #0
 8002b54:	82bb      	strh	r3, [r7, #20]
 8002b56:	f04f 0300 	mov.w	r3, #0
 8002b5a:	82fb      	strh	r3, [r7, #22]
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= CCER_CC3E_Reset;
 8002b5c:	68fb      	ldr	r3, [r7, #12]
 8002b5e:	8c1b      	ldrh	r3, [r3, #32]
 8002b60:	b29b      	uxth	r3, r3
 8002b62:	461a      	mov	r2, r3
 8002b64:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 8002b68:	f2c0 0300 	movt	r3, #0
 8002b6c:	ea02 0303 	and.w	r3, r2, r3
 8002b70:	461a      	mov	r2, r3
 8002b72:	68fb      	ldr	r3, [r7, #12]
 8002b74:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 8002b76:	68fb      	ldr	r3, [r7, #12]
 8002b78:	8b9b      	ldrh	r3, [r3, #28]
 8002b7a:	827b      	strh	r3, [r7, #18]
  tmpccer = TIMx->CCER;
 8002b7c:	68fb      	ldr	r3, [r7, #12]
 8002b7e:	8c1b      	ldrh	r3, [r3, #32]
 8002b80:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 8);
 8002b82:	897b      	ldrh	r3, [r7, #10]
 8002b84:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8002b88:	82fb      	strh	r3, [r7, #22]
  /* Select the Input and set the filter */
  tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
 8002b8a:	8a7b      	ldrh	r3, [r7, #18]
 8002b8c:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
 8002b90:	827b      	strh	r3, [r7, #18]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8002b92:	88fb      	ldrh	r3, [r7, #6]
 8002b94:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002b98:	b29a      	uxth	r2, r3
 8002b9a:	893b      	ldrh	r3, [r7, #8]
 8002b9c:	ea42 0303 	orr.w	r3, r2, r3
 8002ba0:	b29a      	uxth	r2, r3
 8002ba2:	8a7b      	ldrh	r3, [r7, #18]
 8002ba4:	ea42 0303 	orr.w	r3, r2, r3
 8002ba8:	827b      	strh	r3, [r7, #18]
  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= CCER_CC3P_Reset;
 8002baa:	8abb      	ldrh	r3, [r7, #20]
 8002bac:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8002bb0:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(tmp | (uint16_t)CCER_CC3E_Set);
 8002bb2:	8afa      	ldrh	r2, [r7, #22]
 8002bb4:	8abb      	ldrh	r3, [r7, #20]
 8002bb6:	ea42 0303 	orr.w	r3, r2, r3
 8002bba:	b29b      	uxth	r3, r3
 8002bbc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002bc0:	82bb      	strh	r3, [r7, #20]
  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8002bc2:	68fb      	ldr	r3, [r7, #12]
 8002bc4:	8a7a      	ldrh	r2, [r7, #18]
 8002bc6:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer;
 8002bc8:	68fb      	ldr	r3, [r7, #12]
 8002bca:	8aba      	ldrh	r2, [r7, #20]
 8002bcc:	841a      	strh	r2, [r3, #32]
}
 8002bce:	f107 071c 	add.w	r7, r7, #28
 8002bd2:	46bd      	mov	sp, r7
 8002bd4:	bc80      	pop	{r7}
 8002bd6:	4770      	bx	lr

08002bd8 <TI4_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8002bd8:	b480      	push	{r7}
 8002bda:	b087      	sub	sp, #28
 8002bdc:	af00      	add	r7, sp, #0
 8002bde:	60f8      	str	r0, [r7, #12]
 8002be0:	8179      	strh	r1, [r7, #10]
 8002be2:	813a      	strh	r2, [r7, #8]
 8002be4:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
 8002be6:	f04f 0300 	mov.w	r3, #0
 8002bea:	827b      	strh	r3, [r7, #18]
 8002bec:	f04f 0300 	mov.w	r3, #0
 8002bf0:	82bb      	strh	r3, [r7, #20]
 8002bf2:	f04f 0300 	mov.w	r3, #0
 8002bf6:	82fb      	strh	r3, [r7, #22]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= CCER_CC4E_Reset;
 8002bf8:	68fb      	ldr	r3, [r7, #12]
 8002bfa:	8c1b      	ldrh	r3, [r3, #32]
 8002bfc:	b29b      	uxth	r3, r3
 8002bfe:	461a      	mov	r2, r3
 8002c00:	f64e 73ff 	movw	r3, #61439	; 0xefff
 8002c04:	f2c0 0300 	movt	r3, #0
 8002c08:	ea02 0303 	and.w	r3, r2, r3
 8002c0c:	461a      	mov	r2, r3
 8002c0e:	68fb      	ldr	r3, [r7, #12]
 8002c10:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
 8002c12:	68fb      	ldr	r3, [r7, #12]
 8002c14:	8b9b      	ldrh	r3, [r3, #28]
 8002c16:	827b      	strh	r3, [r7, #18]
  tmpccer = TIMx->CCER;
 8002c18:	68fb      	ldr	r3, [r7, #12]
 8002c1a:	8c1b      	ldrh	r3, [r3, #32]
 8002c1c:	82bb      	strh	r3, [r7, #20]
  tmp = (uint16_t)(TIM_ICPolarity << 12);
 8002c1e:	897b      	ldrh	r3, [r7, #10]
 8002c20:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8002c24:	82fb      	strh	r3, [r7, #22]

  /* Select the Input and set the filter */
  tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
 8002c26:	8a7b      	ldrh	r3, [r7, #18]
 8002c28:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002c2c:	ea4f 5303 	mov.w	r3, r3, lsl #20
 8002c30:	ea4f 5313 	mov.w	r3, r3, lsr #20
 8002c34:	827b      	strh	r3, [r7, #18]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8002c36:	893b      	ldrh	r3, [r7, #8]
 8002c38:	ea4f 2303 	mov.w	r3, r3, lsl #8
 8002c3c:	b29a      	uxth	r2, r3
 8002c3e:	8a7b      	ldrh	r3, [r7, #18]
 8002c40:	ea42 0303 	orr.w	r3, r2, r3
 8002c44:	827b      	strh	r3, [r7, #18]
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 8002c46:	88fb      	ldrh	r3, [r7, #6]
 8002c48:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8002c4c:	b29a      	uxth	r2, r3
 8002c4e:	8a7b      	ldrh	r3, [r7, #18]
 8002c50:	ea42 0303 	orr.w	r3, r2, r3
 8002c54:	827b      	strh	r3, [r7, #18]

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= CCER_CC4P_Reset;
 8002c56:	8abb      	ldrh	r3, [r7, #20]
 8002c58:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002c5c:	82bb      	strh	r3, [r7, #20]
  tmpccer |= (uint16_t)(tmp | (uint16_t)CCER_CC4E_Set);
 8002c5e:	8afa      	ldrh	r2, [r7, #22]
 8002c60:	8abb      	ldrh	r3, [r7, #20]
 8002c62:	ea42 0303 	orr.w	r3, r2, r3
 8002c66:	b29b      	uxth	r3, r3
 8002c68:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8002c6c:	82bb      	strh	r3, [r7, #20]
  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8002c6e:	68fb      	ldr	r3, [r7, #12]
 8002c70:	8a7a      	ldrh	r2, [r7, #18]
 8002c72:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer ;
 8002c74:	68fb      	ldr	r3, [r7, #12]
 8002c76:	8aba      	ldrh	r2, [r7, #20]
 8002c78:	841a      	strh	r2, [r3, #32]
}
 8002c7a:	f107 071c 	add.w	r7, r7, #28
 8002c7e:	46bd      	mov	sp, r7
 8002c80:	bc80      	pop	{r7}
 8002c82:	4770      	bx	lr

08002c84 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *   the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8002c84:	b480      	push	{r7}
 8002c86:	b087      	sub	sp, #28
 8002c88:	af00      	add	r7, sp, #0
 8002c8a:	6078      	str	r0, [r7, #4]
  uint32_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 8002c8c:	f04f 0300 	mov.w	r3, #0
 8002c90:	60fb      	str	r3, [r7, #12]
 8002c92:	f04f 0300 	mov.w	r3, #0
 8002c96:	613b      	str	r3, [r7, #16]
 8002c98:	f04f 030f 	mov.w	r3, #15
 8002c9c:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8002c9e:	687b      	ldr	r3, [r7, #4]
 8002ca0:	78db      	ldrb	r3, [r3, #3]
 8002ca2:	2b00      	cmp	r3, #0
 8002ca4:	d049      	beq.n	8002d3a <NVIC_Init+0xb6>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8002ca6:	f64e 5300 	movw	r3, #60672	; 0xed00
 8002caa:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002cae:	68db      	ldr	r3, [r3, #12]
 8002cb0:	ea6f 0303 	mvn.w	r3, r3
 8002cb4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002cb8:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8002cbc:	60fb      	str	r3, [r7, #12]
    tmppre = (0x4 - tmppriority);
 8002cbe:	68fb      	ldr	r3, [r7, #12]
 8002cc0:	f1c3 0304 	rsb	r3, r3, #4
 8002cc4:	613b      	str	r3, [r7, #16]
    tmpsub = tmpsub >> tmppriority;
 8002cc6:	68fb      	ldr	r3, [r7, #12]
 8002cc8:	697a      	ldr	r2, [r7, #20]
 8002cca:	fa22 f303 	lsr.w	r3, r2, r3
 8002cce:	617b      	str	r3, [r7, #20]

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8002cd0:	687b      	ldr	r3, [r7, #4]
 8002cd2:	785b      	ldrb	r3, [r3, #1]
 8002cd4:	461a      	mov	r2, r3
 8002cd6:	693b      	ldr	r3, [r7, #16]
 8002cd8:	fa02 f303 	lsl.w	r3, r2, r3
 8002cdc:	60fb      	str	r3, [r7, #12]
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8002cde:	687b      	ldr	r3, [r7, #4]
 8002ce0:	789b      	ldrb	r3, [r3, #2]
 8002ce2:	461a      	mov	r2, r3
 8002ce4:	697b      	ldr	r3, [r7, #20]
 8002ce6:	ea02 0303 	and.w	r3, r2, r3
 8002cea:	68fa      	ldr	r2, [r7, #12]
 8002cec:	ea42 0303 	orr.w	r3, r2, r3
 8002cf0:	60fb      	str	r3, [r7, #12]
    tmppriority = tmppriority << 0x04;
 8002cf2:	68fb      	ldr	r3, [r7, #12]
 8002cf4:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8002cf8:	60fb      	str	r3, [r7, #12]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8002cfa:	f24e 1300 	movw	r3, #57600	; 0xe100
 8002cfe:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002d02:	687a      	ldr	r2, [r7, #4]
 8002d04:	7812      	ldrb	r2, [r2, #0]
 8002d06:	4611      	mov	r1, r2
 8002d08:	68fa      	ldr	r2, [r7, #12]
 8002d0a:	b2d2      	uxtb	r2, r2
 8002d0c:	440b      	add	r3, r1
 8002d0e:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002d12:	f24e 1300 	movw	r3, #57600	; 0xe100
 8002d16:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002d1a:	687a      	ldr	r2, [r7, #4]
 8002d1c:	7812      	ldrb	r2, [r2, #0]
 8002d1e:	ea4f 1252 	mov.w	r2, r2, lsr #5
 8002d22:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002d24:	6879      	ldr	r1, [r7, #4]
 8002d26:	7809      	ldrb	r1, [r1, #0]
 8002d28:	f001 011f 	and.w	r1, r1, #31
 8002d2c:	f04f 0001 	mov.w	r0, #1
 8002d30:	fa00 f101 	lsl.w	r1, r0, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002d34:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8002d38:	e014      	b.n	8002d64 <NVIC_Init+0xe0>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002d3a:	f24e 1300 	movw	r3, #57600	; 0xe100
 8002d3e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002d42:	687a      	ldr	r2, [r7, #4]
 8002d44:	7812      	ldrb	r2, [r2, #0]
 8002d46:	ea4f 1252 	mov.w	r2, r2, lsr #5
 8002d4a:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002d4c:	6879      	ldr	r1, [r7, #4]
 8002d4e:	7809      	ldrb	r1, [r1, #0]
 8002d50:	f001 011f 	and.w	r1, r1, #31
 8002d54:	f04f 0001 	mov.w	r0, #1
 8002d58:	fa00 f101 	lsl.w	r1, r0, r1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002d5c:	f102 0220 	add.w	r2, r2, #32
 8002d60:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8002d64:	f107 071c 	add.w	r7, r7, #28
 8002d68:	46bd      	mov	sp, r7
 8002d6a:	bc80      	pop	{r7}
 8002d6c:	4770      	bx	lr
 8002d6e:	bf00      	nop

08002d70 <NVIC_SetVectorTable>:
  *     @arg NVIC_VectTab_FLASH
  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x100.
  * @retval None
  */
void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
{ 
 8002d70:	b480      	push	{r7}
 8002d72:	b083      	sub	sp, #12
 8002d74:	af00      	add	r7, sp, #0
 8002d76:	6078      	str	r0, [r7, #4]
 8002d78:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8002d7a:	f64e 5300 	movw	r3, #60672	; 0xed00
 8002d7e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002d82:	683a      	ldr	r2, [r7, #0]
 8002d84:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8002d88:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 8002d8c:	6879      	ldr	r1, [r7, #4]
 8002d8e:	ea42 0201 	orr.w	r2, r2, r1
 8002d92:	609a      	str	r2, [r3, #8]
}
 8002d94:	f107 070c 	add.w	r7, r7, #12
 8002d98:	46bd      	mov	sp, r7
 8002d9a:	bc80      	pop	{r7}
 8002d9c:	4770      	bx	lr
 8002d9e:	bf00      	nop

08002da0 <AddMeasurments>:

int32_t ADC_ACC[CHANELS_AMOUNT];


void AddMeasurments(__IO uint16_t *src)
	{
 8002da0:	b480      	push	{r7}
 8002da2:	b087      	sub	sp, #28
 8002da4:	af00      	add	r7, sp, #0
 8002da6:	6078      	str	r0, [r7, #4]
		for (int j = 0; j < CHANELS_AMOUNT; j++)
 8002da8:	f04f 0300 	mov.w	r3, #0
 8002dac:	60fb      	str	r3, [r7, #12]
 8002dae:	e00c      	b.n	8002dca <AddMeasurments+0x2a>
		{
			ADC_ACC[j] = 0;
 8002db0:	68fa      	ldr	r2, [r7, #12]
 8002db2:	f642 23e8 	movw	r3, #10984	; 0x2ae8
 8002db6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002dba:	f04f 0100 	mov.w	r1, #0
 8002dbe:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
int32_t ADC_ACC[CHANELS_AMOUNT];


void AddMeasurments(__IO uint16_t *src)
	{
		for (int j = 0; j < CHANELS_AMOUNT; j++)
 8002dc2:	68fb      	ldr	r3, [r7, #12]
 8002dc4:	f103 0301 	add.w	r3, r3, #1
 8002dc8:	60fb      	str	r3, [r7, #12]
 8002dca:	68fb      	ldr	r3, [r7, #12]
 8002dcc:	2b02      	cmp	r3, #2
 8002dce:	ddef      	ble.n	8002db0 <AddMeasurments+0x10>
		{
			ADC_ACC[j] = 0;
		}
		for (int i = 0; i < SAMPLES_AMOUNT; i++)
 8002dd0:	f04f 0300 	mov.w	r3, #0
 8002dd4:	613b      	str	r3, [r7, #16]
 8002dd6:	e024      	b.n	8002e22 <AddMeasurments+0x82>
		{

			for (int j = 0; j < CHANELS_AMOUNT; j++)
 8002dd8:	f04f 0300 	mov.w	r3, #0
 8002ddc:	617b      	str	r3, [r7, #20]
 8002dde:	e019      	b.n	8002e14 <AddMeasurments+0x74>
			{
				ADC_ACC[j] += *src;
 8002de0:	697a      	ldr	r2, [r7, #20]
 8002de2:	6979      	ldr	r1, [r7, #20]
 8002de4:	f642 23e8 	movw	r3, #10984	; 0x2ae8
 8002de8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002dec:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8002df0:	687b      	ldr	r3, [r7, #4]
 8002df2:	881b      	ldrh	r3, [r3, #0]
 8002df4:	b29b      	uxth	r3, r3
 8002df6:	4419      	add	r1, r3
 8002df8:	f642 23e8 	movw	r3, #10984	; 0x2ae8
 8002dfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e00:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
				src++;
 8002e04:	687b      	ldr	r3, [r7, #4]
 8002e06:	f103 0302 	add.w	r3, r3, #2
 8002e0a:	607b      	str	r3, [r7, #4]
			ADC_ACC[j] = 0;
		}
		for (int i = 0; i < SAMPLES_AMOUNT; i++)
		{

			for (int j = 0; j < CHANELS_AMOUNT; j++)
 8002e0c:	697b      	ldr	r3, [r7, #20]
 8002e0e:	f103 0301 	add.w	r3, r3, #1
 8002e12:	617b      	str	r3, [r7, #20]
 8002e14:	697b      	ldr	r3, [r7, #20]
 8002e16:	2b02      	cmp	r3, #2
 8002e18:	dde2      	ble.n	8002de0 <AddMeasurments+0x40>
	{
		for (int j = 0; j < CHANELS_AMOUNT; j++)
		{
			ADC_ACC[j] = 0;
		}
		for (int i = 0; i < SAMPLES_AMOUNT; i++)
 8002e1a:	693b      	ldr	r3, [r7, #16]
 8002e1c:	f103 0301 	add.w	r3, r3, #1
 8002e20:	613b      	str	r3, [r7, #16]
 8002e22:	693a      	ldr	r2, [r7, #16]
 8002e24:	f240 33ff 	movw	r3, #1023	; 0x3ff
 8002e28:	429a      	cmp	r2, r3
 8002e2a:	ddd5      	ble.n	8002dd8 <AddMeasurments+0x38>
			{
				ADC_ACC[j] += *src;
				src++;
			}
		}
	}
 8002e2c:	f107 071c 	add.w	r7, r7, #28
 8002e30:	46bd      	mov	sp, r7
 8002e32:	bc80      	pop	{r7}
 8002e34:	4770      	bx	lr
 8002e36:	bf00      	nop

08002e38 <GetADC>:

void GetADC(int32_t buf[CHANELS_AMOUNT])
{
 8002e38:	b580      	push	{r7, lr}
 8002e3a:	b084      	sub	sp, #16
 8002e3c:	af00      	add	r7, sp, #0
 8002e3e:	6078      	str	r0, [r7, #4]
	AddMeasurments(ADC1ConvertedValue);
 8002e40:	f642 3014 	movw	r0, #11028	; 0x2b14
 8002e44:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002e48:	f642 53a1 	movw	r3, #11681	; 0x2da1
 8002e4c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002e50:	4798      	blx	r3
	for(int i=0;i<CHANELS_AMOUNT;i++)
 8002e52:	f04f 0300 	mov.w	r3, #0
 8002e56:	60fb      	str	r3, [r7, #12]
 8002e58:	e041      	b.n	8002ede <GetADC+0xa6>
		{
		if(ACC_TO_MV(ADC_ACC[i])>0)
 8002e5a:	68fa      	ldr	r2, [r7, #12]
 8002e5c:	f642 23e8 	movw	r3, #10984	; 0x2ae8
 8002e60:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e64:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002e68:	f04f 0264 	mov.w	r2, #100	; 0x64
 8002e6c:	fb02 f303 	mul.w	r3, r2, r3
 8002e70:	f5a3 3338 	sub.w	r3, r3, #188416	; 0x2e000
 8002e74:	f5a3 63c6 	sub.w	r3, r3, #1584	; 0x630
 8002e78:	f240 5216 	movw	r2, #1302	; 0x516
 8002e7c:	4293      	cmp	r3, r2
 8002e7e:	dd22      	ble.n	8002ec6 <GetADC+0x8e>
		{
		buf[i] = ACC_TO_MV(ADC_ACC[i]);
 8002e80:	68fb      	ldr	r3, [r7, #12]
 8002e82:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8002e86:	687b      	ldr	r3, [r7, #4]
 8002e88:	eb02 0103 	add.w	r1, r2, r3
 8002e8c:	68fa      	ldr	r2, [r7, #12]
 8002e8e:	f642 23e8 	movw	r3, #10984	; 0x2ae8
 8002e92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e96:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002e9a:	f04f 0264 	mov.w	r2, #100	; 0x64
 8002e9e:	fb02 f303 	mul.w	r3, r2, r3
 8002ea2:	f5a3 3338 	sub.w	r3, r3, #188416	; 0x2e000
 8002ea6:	f5a3 63c6 	sub.w	r3, r3, #1584	; 0x630
 8002eaa:	f64a 42b3 	movw	r2, #44211	; 0xacb3
 8002eae:	f2c6 4297 	movt	r2, #25751	; 0x6497
 8002eb2:	fb82 0203 	smull	r0, r2, r2, r3
 8002eb6:	ea4f 2262 	mov.w	r2, r2, asr #9
 8002eba:	ea4f 73e3 	mov.w	r3, r3, asr #31
 8002ebe:	ebc3 0302 	rsb	r3, r3, r2
 8002ec2:	600b      	str	r3, [r1, #0]
 8002ec4:	e007      	b.n	8002ed6 <GetADC+0x9e>
		}
		else
			buf[i] = 0;
 8002ec6:	68fb      	ldr	r3, [r7, #12]
 8002ec8:	ea4f 0283 	mov.w	r2, r3, lsl #2
 8002ecc:	687b      	ldr	r3, [r7, #4]
 8002ece:	4413      	add	r3, r2
 8002ed0:	f04f 0200 	mov.w	r2, #0
 8002ed4:	601a      	str	r2, [r3, #0]
	}

void GetADC(int32_t buf[CHANELS_AMOUNT])
{
	AddMeasurments(ADC1ConvertedValue);
	for(int i=0;i<CHANELS_AMOUNT;i++)
 8002ed6:	68fb      	ldr	r3, [r7, #12]
 8002ed8:	f103 0301 	add.w	r3, r3, #1
 8002edc:	60fb      	str	r3, [r7, #12]
 8002ede:	68fb      	ldr	r3, [r7, #12]
 8002ee0:	2b02      	cmp	r3, #2
 8002ee2:	ddba      	ble.n	8002e5a <GetADC+0x22>
		buf[i] = ACC_TO_MV(ADC_ACC[i]);
		}
		else
			buf[i] = 0;
		}
}
 8002ee4:	f107 0710 	add.w	r7, r7, #16
 8002ee8:	46bd      	mov	sp, r7
 8002eea:	bd80      	pop	{r7, pc}

08002eec <ADC_DMA_Init>:

//==============================================================================
void ADC_DMA_Init()
{
 8002eec:	b580      	push	{r7, lr}
 8002eee:	af00      	add	r7, sp, #0
	/* DMA1 channel1 configuration ---------------------------------------------*/
	DMA_DeInit(ADC_DMA_CHANEL);
 8002ef0:	f240 0008 	movw	r0, #8
 8002ef4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002ef8:	f242 23e1 	movw	r3, #8929	; 0x22e1
 8002efc:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002f00:	4798      	blx	r3
	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
 8002f02:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f0a:	f242 424c 	movw	r2, #9292	; 0x244c
 8002f0e:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8002f12:	601a      	str	r2, [r3, #0]
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) ADC1ConvertedValue;
 8002f14:	f642 3214 	movw	r2, #11028	; 0x2b14
 8002f18:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002f1c:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f24:	605a      	str	r2, [r3, #4]
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8002f26:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f2e:	f04f 0200 	mov.w	r2, #0
 8002f32:	609a      	str	r2, [r3, #8]
	DMA_InitStructure.DMA_BufferSize = ADC_BUFFER_SIZE;
 8002f34:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f3c:	f44f 6240 	mov.w	r2, #3072	; 0xc00
 8002f40:	60da      	str	r2, [r3, #12]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8002f42:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f4a:	f04f 0200 	mov.w	r2, #0
 8002f4e:	611a      	str	r2, [r3, #16]
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8002f50:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f58:	f04f 0280 	mov.w	r2, #128	; 0x80
 8002f5c:	615a      	str	r2, [r3, #20]
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
 8002f5e:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f66:	f44f 7280 	mov.w	r2, #256	; 0x100
 8002f6a:	619a      	str	r2, [r3, #24]
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
 8002f6c:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f74:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8002f78:	61da      	str	r2, [r3, #28]
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 8002f7a:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f82:	f04f 0220 	mov.w	r2, #32
 8002f86:	621a      	str	r2, [r3, #32]
	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 8002f88:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f90:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8002f94:	625a      	str	r2, [r3, #36]	; 0x24
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8002f96:	f244 3314 	movw	r3, #17172	; 0x4314
 8002f9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f9e:	f04f 0200 	mov.w	r2, #0
 8002fa2:	629a      	str	r2, [r3, #40]	; 0x28
	DMA_Init(ADC_DMA_CHANEL, &DMA_InitStructure);
 8002fa4:	f240 0008 	movw	r0, #8
 8002fa8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002fac:	f244 3114 	movw	r1, #17172	; 0x4314
 8002fb0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8002fb4:	f242 43fd 	movw	r3, #9469	; 0x24fd
 8002fb8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002fbc:	4798      	blx	r3

	/* Enable DMA1 channel1 */
	DMA_Cmd(ADC_DMA_CHANEL, ENABLE);
 8002fbe:	f240 0008 	movw	r0, #8
 8002fc2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002fc6:	f04f 0101 	mov.w	r1, #1
 8002fca:	f242 538d 	movw	r3, #9613	; 0x258d
 8002fce:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002fd2:	4798      	blx	r3

	/* ADC1 configuration ------------------------------------------------------*/
	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
 8002fd4:	f642 3300 	movw	r3, #11008	; 0x2b00
 8002fd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002fdc:	f04f 0200 	mov.w	r2, #0
 8002fe0:	601a      	str	r2, [r3, #0]
	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 8002fe2:	f642 3300 	movw	r3, #11008	; 0x2b00
 8002fe6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002fea:	f04f 0201 	mov.w	r2, #1
 8002fee:	711a      	strb	r2, [r3, #4]
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
 8002ff0:	f642 3300 	movw	r3, #11008	; 0x2b00
 8002ff4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002ff8:	f04f 0201 	mov.w	r2, #1
 8002ffc:	715a      	strb	r2, [r3, #5]
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 8002ffe:	f642 3300 	movw	r3, #11008	; 0x2b00
 8003002:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003006:	f44f 2260 	mov.w	r2, #917504	; 0xe0000
 800300a:	609a      	str	r2, [r3, #8]
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 800300c:	f642 3300 	movw	r3, #11008	; 0x2b00
 8003010:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003014:	f04f 0200 	mov.w	r2, #0
 8003018:	60da      	str	r2, [r3, #12]
	ADC_InitStructure.ADC_NbrOfChannel = CHANELS_AMOUNT;
 800301a:	f642 3300 	movw	r3, #11008	; 0x2b00
 800301e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003022:	f04f 0203 	mov.w	r2, #3
 8003026:	741a      	strb	r2, [r3, #16]
	ADC_Init(ADC1, &ADC_InitStructure);
 8003028:	f242 4000 	movw	r0, #9216	; 0x2400
 800302c:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003030:	f642 3100 	movw	r1, #11008	; 0x2b00
 8003034:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8003038:	f241 33a9 	movw	r3, #5033	; 0x13a9
 800303c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003040:	4798      	blx	r3

	/* ADC1 regular channel1 */
	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_7Cycles5); //
 8003042:	f242 4000 	movw	r0, #9216	; 0x2400
 8003046:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800304a:	f04f 0100 	mov.w	r1, #0
 800304e:	f04f 0201 	mov.w	r2, #1
 8003052:	f04f 0301 	mov.w	r3, #1
 8003056:	f241 5cc1 	movw	ip, #5569	; 0x15c1
 800305a:	f6c0 0c00 	movt	ip, #2048	; 0x800
 800305e:	47e0      	blx	ip
	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_7Cycles5); //
 8003060:	f242 4000 	movw	r0, #9216	; 0x2400
 8003064:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003068:	f04f 0101 	mov.w	r1, #1
 800306c:	f04f 0202 	mov.w	r2, #2
 8003070:	f04f 0301 	mov.w	r3, #1
 8003074:	f241 5cc1 	movw	ip, #5569	; 0x15c1
 8003078:	f6c0 0c00 	movt	ip, #2048	; 0x800
 800307c:	47e0      	blx	ip
	ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_7Cycles5);  //
 800307e:	f242 4000 	movw	r0, #9216	; 0x2400
 8003082:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003086:	f04f 0102 	mov.w	r1, #2
 800308a:	f04f 0203 	mov.w	r2, #3
 800308e:	f04f 0301 	mov.w	r3, #1
 8003092:	f241 5cc1 	movw	ip, #5569	; 0x15c1
 8003096:	f6c0 0c00 	movt	ip, #2048	; 0x800
 800309a:	47e0      	blx	ip


	/* Enable ADC1 DMA */
	ADC_DMACmd(ADC1, ENABLE);
 800309c:	f242 4000 	movw	r0, #9216	; 0x2400
 80030a0:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80030a4:	f04f 0101 	mov.w	r1, #1
 80030a8:	f241 43a1 	movw	r3, #5281	; 0x14a1
 80030ac:	f6c0 0300 	movt	r3, #2048	; 0x800
 80030b0:	4798      	blx	r3

	/* Enable ADC1 */
	ADC_Cmd(ADC1, ENABLE);
 80030b2:	f242 4000 	movw	r0, #9216	; 0x2400
 80030b6:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80030ba:	f04f 0101 	mov.w	r1, #1
 80030be:	f241 4369 	movw	r3, #5225	; 0x1469
 80030c2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80030c6:	4798      	blx	r3

	/* Enable TempSensor and Vrefint channels: channel16 and Channel17 */
	//ADC_TempSensorVrefintCmd(ENABLE);
	/* Enable ADC1 reset calibaration register */
	ADC_ResetCalibration(ADC1);
 80030c8:	f242 4000 	movw	r0, #9216	; 0x2400
 80030cc:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80030d0:	f241 43d9 	movw	r3, #5337	; 0x14d9
 80030d4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80030d8:	4798      	blx	r3

	/* Check the end of ADC1 reset calibration register */
	while (ADC_GetResetCalibrationStatus(ADC1))
 80030da:	f242 4000 	movw	r0, #9216	; 0x2400
 80030de:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80030e2:	f241 43f9 	movw	r3, #5369	; 0x14f9
 80030e6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80030ea:	4798      	blx	r3
 80030ec:	4603      	mov	r3, r0
 80030ee:	2b00      	cmp	r3, #0
 80030f0:	d1f3      	bne.n	80030da <ADC_DMA_Init+0x1ee>
		;

	/* Start ADC1 calibaration */
	ADC_StartCalibration(ADC1);
 80030f2:	f242 4000 	movw	r0, #9216	; 0x2400
 80030f6:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80030fa:	f241 5331 	movw	r3, #5425	; 0x1531
 80030fe:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003102:	4798      	blx	r3

	/* Check the end of ADC1 calibration */
	while (ADC_GetCalibrationStatus(ADC1))
 8003104:	f242 4000 	movw	r0, #9216	; 0x2400
 8003108:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800310c:	f241 5351 	movw	r3, #5457	; 0x1551
 8003110:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003114:	4798      	blx	r3
 8003116:	4603      	mov	r3, r0
 8003118:	2b00      	cmp	r3, #0
 800311a:	d1f3      	bne.n	8003104 <ADC_DMA_Init+0x218>
		;
}
 800311c:	bd80      	pop	{r7, pc}
 800311e:	bf00      	nop

08003120 <ADC_RCC_Configuration>:

//==============================================================================
void ADC_RCC_Configuration(void)
{
 8003120:	b580      	push	{r7, lr}
 8003122:	af00      	add	r7, sp, #0
	RCC_ADCCLKConfig(RCC_PCLK2_Div6); // ADC CLOCK = 12 MHZ
 8003124:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8003128:	f641 7395 	movw	r3, #8085	; 0x1f95
 800312c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003130:	4798      	blx	r3
	//conversion time for 1 sample = sample clck+ 12.5
	// if ST = 1.5 cycl time = 1.5+12.5 = 14 clk;
	//  (1/12000000) * 14 = 1.666667 uS = 18.66666667 uS
	// TOTOAL TIME FOR 16 chanels = 1.666667*16 =
	/* Enable DMA1 clock */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
 8003132:	f04f 0001 	mov.w	r0, #1
 8003136:	f04f 0101 	mov.w	r1, #1
 800313a:	f242 13a1 	movw	r3, #8609	; 0x21a1
 800313e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003142:	4798      	blx	r3
	/* Enable peripheral clocks --------------------------------------------------*/
	/* Enable ADC1 and GPIOC clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
 8003144:	f44f 7000 	mov.w	r0, #512	; 0x200
 8003148:	f04f 0101 	mov.w	r1, #1
 800314c:	f242 13f9 	movw	r3, #8697	; 0x21f9
 8003150:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003154:	4798      	blx	r3
}
 8003156:	bd80      	pop	{r7, pc}

08003158 <ADC_GPIO_Configuration>:
 * @brief  Configures the different GPIO ports.
 * @param  None
 * @retval None
 */
void ADC_GPIO_Configuration(void)
{
 8003158:	b580      	push	{r7, lr}
 800315a:	b082      	sub	sp, #8
 800315c:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;
 800315e:	f04f 0307 	mov.w	r3, #7
 8003162:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 8003164:	f04f 0300 	mov.w	r3, #0
 8003168:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800316a:	f107 0304 	add.w	r3, r7, #4
 800316e:	f640 0000 	movw	r0, #2048	; 0x800
 8003172:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003176:	4619      	mov	r1, r3
 8003178:	f641 2371 	movw	r3, #6769	; 0x1a71
 800317c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003180:	4798      	blx	r3

}
 8003182:	f107 0708 	add.w	r7, r7, #8
 8003186:	46bd      	mov	sp, r7
 8003188:	bd80      	pop	{r7, pc}
 800318a:	bf00      	nop

0800318c <ADC_Start>:
//==============================================================================
void ADC_Start()
{
 800318c:	b580      	push	{r7, lr}
 800318e:	af00      	add	r7, sp, #0
	ADC_RCC_Configuration();
 8003190:	f243 1321 	movw	r3, #12577	; 0x3121
 8003194:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003198:	4798      	blx	r3
	ADC_GPIO_Configuration();
 800319a:	f243 1359 	movw	r3, #12633	; 0x3159
 800319e:	f6c0 0300 	movt	r3, #2048	; 0x800
 80031a2:	4798      	blx	r3
	ADC_DMA_Init();
 80031a4:	f642 63ed 	movw	r3, #12013	; 0x2eed
 80031a8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80031ac:	4798      	blx	r3

	/* Start ADC1 Software Conversion */
	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 80031ae:	f242 4000 	movw	r0, #9216	; 0x2400
 80031b2:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80031b6:	f04f 0101 	mov.w	r1, #1
 80031ba:	f241 5389 	movw	r3, #5513	; 0x1589
 80031be:	f6c0 0300 	movt	r3, #2048	; 0x800
 80031c2:	4798      	blx	r3
	// while(!DMA_GetFlagStatus(DMA1_FLAG_TC1));

	/* Clear Channel 1 DMA1_FLAG_TC flag */

	//		  DMA_ClearFlag(DMA1_FLAG_TC1);
}
 80031c4:	bd80      	pop	{r7, pc}
 80031c6:	bf00      	nop

080031c8 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80031c8:	b480      	push	{r7}
 80031ca:	b083      	sub	sp, #12
 80031cc:	af00      	add	r7, sp, #0
 80031ce:	4603      	mov	r3, r0
 80031d0:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 80031d2:	f24e 1300 	movw	r3, #57600	; 0xe100
 80031d6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80031da:	f997 2007 	ldrsb.w	r2, [r7, #7]
 80031de:	ea4f 1252 	mov.w	r2, r2, lsr #5
 80031e2:	79f9      	ldrb	r1, [r7, #7]
 80031e4:	f001 011f 	and.w	r1, r1, #31
 80031e8:	f04f 0001 	mov.w	r0, #1
 80031ec:	fa00 f101 	lsl.w	r1, r0, r1
 80031f0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80031f4:	f107 070c 	add.w	r7, r7, #12
 80031f8:	46bd      	mov	sp, r7
 80031fa:	bc80      	pop	{r7}
 80031fc:	4770      	bx	lr
 80031fe:	bf00      	nop

08003200 <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt. \n
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8003200:	b480      	push	{r7}
 8003202:	b083      	sub	sp, #12
 8003204:	af00      	add	r7, sp, #0
 8003206:	4603      	mov	r3, r0
 8003208:	6039      	str	r1, [r7, #0]
 800320a:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 800320c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8003210:	2b00      	cmp	r3, #0
 8003212:	da10      	bge.n	8003236 <NVIC_SetPriority+0x36>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
 8003214:	f64e 5300 	movw	r3, #60672	; 0xed00
 8003218:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800321c:	79fa      	ldrb	r2, [r7, #7]
 800321e:	f002 020f 	and.w	r2, r2, #15
 8003222:	f1a2 0104 	sub.w	r1, r2, #4
 8003226:	683a      	ldr	r2, [r7, #0]
 8003228:	b2d2      	uxtb	r2, r2
 800322a:	ea4f 1202 	mov.w	r2, r2, lsl #4
 800322e:	b2d2      	uxtb	r2, r2
 8003230:	440b      	add	r3, r1
 8003232:	761a      	strb	r2, [r3, #24]
 8003234:	e00d      	b.n	8003252 <NVIC_SetPriority+0x52>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts      */
 8003236:	f24e 1300 	movw	r3, #57600	; 0xe100
 800323a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800323e:	f997 1007 	ldrsb.w	r1, [r7, #7]
 8003242:	683a      	ldr	r2, [r7, #0]
 8003244:	b2d2      	uxtb	r2, r2
 8003246:	ea4f 1202 	mov.w	r2, r2, lsl #4
 800324a:	b2d2      	uxtb	r2, r2
 800324c:	440b      	add	r3, r1
 800324e:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8003252:	f107 070c 	add.w	r7, r7, #12
 8003256:	46bd      	mov	sp, r7
 8003258:	bc80      	pop	{r7}
 800325a:	4770      	bx	lr

0800325c <uartTxDMAConfiguration>:
UART_FIFO_STR u1Fifo;


void uartTxDMAConfiguration(USART_TypeDef *uart, DMA_Channel_TypeDef *dmatx,
		uint8_t *txBuf, uint32_t len, bool ie)
{
 800325c:	b580      	push	{r7, lr}
 800325e:	b090      	sub	sp, #64	; 0x40
 8003260:	af00      	add	r7, sp, #0
 8003262:	60f8      	str	r0, [r7, #12]
 8003264:	60b9      	str	r1, [r7, #8]
 8003266:	607a      	str	r2, [r7, #4]
 8003268:	603b      	str	r3, [r7, #0]
	DMA_InitTypeDef DMA_InitStructure;

	/* DMA1 Channel (triggered by USART_Tx event) Config */
	DMA_DeInit(dmatx);
 800326a:	68b8      	ldr	r0, [r7, #8]
 800326c:	f242 23e1 	movw	r3, #8929	; 0x22e1
 8003270:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003274:	4798      	blx	r3
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &uart->DR;
 8003276:	68fb      	ldr	r3, [r7, #12]
 8003278:	f103 0304 	add.w	r3, r3, #4
 800327c:	617b      	str	r3, [r7, #20]
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) txBuf;
 800327e:	687b      	ldr	r3, [r7, #4]
 8003280:	61bb      	str	r3, [r7, #24]
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8003282:	f04f 0310 	mov.w	r3, #16
 8003286:	61fb      	str	r3, [r7, #28]
	DMA_InitStructure.DMA_BufferSize = len;
 8003288:	683b      	ldr	r3, [r7, #0]
 800328a:	623b      	str	r3, [r7, #32]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800328c:	f04f 0300 	mov.w	r3, #0
 8003290:	627b      	str	r3, [r7, #36]	; 0x24
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8003292:	f04f 0380 	mov.w	r3, #128	; 0x80
 8003296:	62bb      	str	r3, [r7, #40]	; 0x28
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8003298:	f04f 0300 	mov.w	r3, #0
 800329c:	62fb      	str	r3, [r7, #44]	; 0x2c
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 800329e:	f04f 0300 	mov.w	r3, #0
 80032a2:	633b      	str	r3, [r7, #48]	; 0x30
	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 80032a4:	f04f 0300 	mov.w	r3, #0
 80032a8:	637b      	str	r3, [r7, #52]	; 0x34
	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
 80032aa:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 80032ae:	63bb      	str	r3, [r7, #56]	; 0x38
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 80032b0:	f04f 0300 	mov.w	r3, #0
 80032b4:	63fb      	str	r3, [r7, #60]	; 0x3c
	DMA_Init(dmatx, &DMA_InitStructure);
 80032b6:	f107 0314 	add.w	r3, r7, #20
 80032ba:	68b8      	ldr	r0, [r7, #8]
 80032bc:	4619      	mov	r1, r3
 80032be:	f242 43fd 	movw	r3, #9469	; 0x24fd
 80032c2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80032c6:	4798      	blx	r3
	DMA_Cmd(dmatx, ENABLE);
 80032c8:	68b8      	ldr	r0, [r7, #8]
 80032ca:	f04f 0101 	mov.w	r1, #1
 80032ce:	f242 538d 	movw	r3, #9613	; 0x258d
 80032d2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80032d6:	4798      	blx	r3
	//if (ie)
	{
		DMA_ITConfig(USART1_TX_DMA, DMA_IT_TC, ENABLE);
 80032d8:	f240 0044 	movw	r0, #68	; 0x44
 80032dc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80032e0:	f04f 0102 	mov.w	r1, #2
 80032e4:	f04f 0201 	mov.w	r2, #1
 80032e8:	f242 53c5 	movw	r3, #9669	; 0x25c5
 80032ec:	f6c0 0300 	movt	r3, #2048	; 0x800
 80032f0:	4798      	blx	r3
	}
	/* Enable USART_Tx DMA Tansmit request */
	/* Configure DMA1_Channel_Tx interrupt */
	NVIC_SetPriority(USART1_TX_DMA_IRQn, 0x01);
 80032f2:	f04f 000e 	mov.w	r0, #14
 80032f6:	f04f 0101 	mov.w	r1, #1
 80032fa:	f243 2301 	movw	r3, #12801	; 0x3201
 80032fe:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003302:	4798      	blx	r3
	NVIC_EnableIRQ(USART1_TX_DMA_IRQn);
 8003304:	f04f 000e 	mov.w	r0, #14
 8003308:	f243 13c9 	movw	r3, #12745	; 0x31c9
 800330c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003310:	4798      	blx	r3
}
 8003312:	f107 0740 	add.w	r7, r7, #64	; 0x40
 8003316:	46bd      	mov	sp, r7
 8003318:	bd80      	pop	{r7, pc}
 800331a:	bf00      	nop

0800331c <uartRxDMAConfiguration>:
 * @param  uart, dmatx,dmarx,interrupt enable
 * @retval : None
 */
void uartRxDMAConfiguration(USART_TypeDef *uart, DMA_Channel_TypeDef *dmarx,
		unsigned char *rxBuf, uint32_t len)
{
 800331c:	b580      	push	{r7, lr}
 800331e:	b090      	sub	sp, #64	; 0x40
 8003320:	af00      	add	r7, sp, #0
 8003322:	60f8      	str	r0, [r7, #12]
 8003324:	60b9      	str	r1, [r7, #8]
 8003326:	607a      	str	r2, [r7, #4]
 8003328:	603b      	str	r3, [r7, #0]
	DMA_InitTypeDef DMA_InitStructure;

	/* DMA1 Channel (triggered by USART1 Rx event) Config */
	DMA_DeInit(dmarx);
 800332a:	68b8      	ldr	r0, [r7, #8]
 800332c:	f242 23e1 	movw	r3, #8929	; 0x22e1
 8003330:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003334:	4798      	blx	r3
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &uart->DR;
 8003336:	68fb      	ldr	r3, [r7, #12]
 8003338:	f103 0304 	add.w	r3, r3, #4
 800333c:	617b      	str	r3, [r7, #20]
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) rxBuf;
 800333e:	687b      	ldr	r3, [r7, #4]
 8003340:	61bb      	str	r3, [r7, #24]
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8003342:	f04f 0300 	mov.w	r3, #0
 8003346:	61fb      	str	r3, [r7, #28]
	DMA_InitStructure.DMA_BufferSize = len;
 8003348:	683b      	ldr	r3, [r7, #0]
 800334a:	623b      	str	r3, [r7, #32]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800334c:	f04f 0300 	mov.w	r3, #0
 8003350:	627b      	str	r3, [r7, #36]	; 0x24
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8003352:	f04f 0380 	mov.w	r3, #128	; 0x80
 8003356:	62bb      	str	r3, [r7, #40]	; 0x28
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8003358:	f04f 0300 	mov.w	r3, #0
 800335c:	62fb      	str	r3, [r7, #44]	; 0x2c
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 800335e:	f04f 0300 	mov.w	r3, #0
 8003362:	633b      	str	r3, [r7, #48]	; 0x30
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 8003364:	f04f 0320 	mov.w	r3, #32
 8003368:	637b      	str	r3, [r7, #52]	; 0x34
	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
 800336a:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 800336e:	63bb      	str	r3, [r7, #56]	; 0x38
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8003370:	f04f 0300 	mov.w	r3, #0
 8003374:	63fb      	str	r3, [r7, #60]	; 0x3c
	DMA_Init(dmarx, &DMA_InitStructure);
 8003376:	f107 0314 	add.w	r3, r7, #20
 800337a:	68b8      	ldr	r0, [r7, #8]
 800337c:	4619      	mov	r1, r3
 800337e:	f242 43fd 	movw	r3, #9469	; 0x24fd
 8003382:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003386:	4798      	blx	r3
	DMA_Cmd(dmarx, ENABLE);
 8003388:	68b8      	ldr	r0, [r7, #8]
 800338a:	f04f 0101 	mov.w	r1, #1
 800338e:	f242 538d 	movw	r3, #9613	; 0x258d
 8003392:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003396:	4798      	blx	r3
}
 8003398:	f107 0740 	add.w	r7, r7, #64	; 0x40
 800339c:	46bd      	mov	sp, r7
 800339e:	bd80      	pop	{r7, pc}

080033a0 <uart1Init>:
void uart1Init(uint32_t baudrate)
{
 80033a0:	b580      	push	{r7, lr}
 80033a2:	b088      	sub	sp, #32
 80033a4:	af00      	add	r7, sp, #0
 80033a6:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	/* Enable GPIOA clock */
	//
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
 80033a8:	f04f 0004 	mov.w	r0, #4
 80033ac:	f04f 0101 	mov.w	r1, #1
 80033b0:	f242 13f9 	movw	r3, #8697	; 0x21f9
 80033b4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80033b8:	4798      	blx	r3
	  /* Enable GPIO and AFIO clocks */
	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_AFIO, ENABLE);
 80033ba:	f244 0001 	movw	r0, #16385	; 0x4001
 80033be:	f04f 0101 	mov.w	r1, #1
 80033c2:	f242 13f9 	movw	r3, #8697	; 0x21f9
 80033c6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80033ca:	4798      	blx	r3
	//
	//	/* Configure USART1 TX (PA.09) as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 80033cc:	f44f 7300 	mov.w	r3, #512	; 0x200
 80033d0:	83bb      	strh	r3, [r7, #28]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80033d2:	f04f 0303 	mov.w	r3, #3
 80033d6:	77bb      	strb	r3, [r7, #30]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 80033d8:	f04f 0318 	mov.w	r3, #24
 80033dc:	77fb      	strb	r3, [r7, #31]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80033de:	f107 031c 	add.w	r3, r7, #28
 80033e2:	f640 0000 	movw	r0, #2048	; 0x800
 80033e6:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80033ea:	4619      	mov	r1, r3
 80033ec:	f641 2371 	movw	r3, #6769	; 0x1a71
 80033f0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80033f4:	4798      	blx	r3

	/* Configure USART1 RX (PA.10) as input floating */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 80033f6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80033fa:	83bb      	strh	r3, [r7, #28]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 80033fc:	f04f 0304 	mov.w	r3, #4
 8003400:	77fb      	strb	r3, [r7, #31]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003402:	f107 031c 	add.w	r3, r7, #28
 8003406:	f640 0000 	movw	r0, #2048	; 0x800
 800340a:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800340e:	4619      	mov	r1, r3
 8003410:	f641 2371 	movw	r3, #6769	; 0x1a71
 8003414:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003418:	4798      	blx	r3

	/* Enable USART1,  clocks */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 800341a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800341e:	f04f 0101 	mov.w	r1, #1
 8003422:	f242 13f9 	movw	r3, #8697	; 0x21f9
 8003426:	f6c0 0300 	movt	r3, #2048	; 0x800
 800342a:	4798      	blx	r3

	USART_InitStructure.USART_BaudRate = baudrate;
 800342c:	687b      	ldr	r3, [r7, #4]
 800342e:	60fb      	str	r3, [r7, #12]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8003430:	f04f 0300 	mov.w	r3, #0
 8003434:	823b      	strh	r3, [r7, #16]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8003436:	f04f 0300 	mov.w	r3, #0
 800343a:	827b      	strh	r3, [r7, #18]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 800343c:	f04f 0300 	mov.w	r3, #0
 8003440:	82bb      	strh	r3, [r7, #20]
	USART_InitStructure.USART_HardwareFlowControl
 8003442:	f04f 0300 	mov.w	r3, #0
 8003446:	833b      	strh	r3, [r7, #24]
			= USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8003448:	f04f 030c 	mov.w	r3, #12
 800344c:	82fb      	strh	r3, [r7, #22]
	/* Configure USART1 */
	USART_Init(USART1, &USART_InitStructure);
 800344e:	f107 030c 	add.w	r3, r7, #12
 8003452:	f643 0000 	movw	r0, #14336	; 0x3800
 8003456:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800345a:	4619      	mov	r1, r3
 800345c:	f241 7391 	movw	r3, #6033	; 0x1791
 8003460:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003464:	4798      	blx	r3

	uartRxDMAConfiguration(USART1, USART1_RX_DMA, u1Fifo.rxBuf,
 8003466:	f643 0000 	movw	r0, #14336	; 0x3800
 800346a:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800346e:	f240 016c 	movw	r1, #108	; 0x6c
 8003472:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8003476:	4a27      	ldr	r2, [pc, #156]	; (8003514 <uart1Init+0x174>)
 8003478:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800347c:	f243 3c1d 	movw	ip, #13085	; 0x331d
 8003480:	f6c0 0c00 	movt	ip, #2048	; 0x800
 8003484:	47e0      	blx	ip
			UARTRX_FIFO_SIZE);
	USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE);
 8003486:	f643 0000 	movw	r0, #14336	; 0x3800
 800348a:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800348e:	f04f 0180 	mov.w	r1, #128	; 0x80
 8003492:	f04f 0201 	mov.w	r2, #1
 8003496:	f641 139d 	movw	r3, #6557	; 0x199d
 800349a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800349e:	4798      	blx	r3
	/* Enable USART_Rx DMA Receive request */
	USART_DMACmd(USART1, USART_DMAReq_Rx, ENABLE);
 80034a0:	f643 0000 	movw	r0, #14336	; 0x3800
 80034a4:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80034a8:	f04f 0140 	mov.w	r1, #64	; 0x40
 80034ac:	f04f 0201 	mov.w	r2, #1
 80034b0:	f641 139d 	movw	r3, #6557	; 0x199d
 80034b4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80034b8:	4798      	blx	r3

	  /* Enable USART_Rx Receive interrupt */
	  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
 80034ba:	f643 0000 	movw	r0, #14336	; 0x3800
 80034be:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80034c2:	f240 5125 	movw	r1, #1317	; 0x525
 80034c6:	f04f 0201 	mov.w	r2, #1
 80034ca:	f641 03f5 	movw	r3, #6389	; 0x18f5
 80034ce:	f6c0 0300 	movt	r3, #2048	; 0x800
 80034d2:	4798      	blx	r3
	    /* Configure USART1 interrupt */
	    NVIC_SetPriority(USART1_RX_DMA_IRQn, 0x00);
 80034d4:	f04f 0010 	mov.w	r0, #16
 80034d8:	f04f 0100 	mov.w	r1, #0
 80034dc:	f243 2301 	movw	r3, #12801	; 0x3201
 80034e0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80034e4:	4798      	blx	r3
	    NVIC_EnableIRQ(USART1_RX_DMA_IRQn);
 80034e6:	f04f 0010 	mov.w	r0, #16
 80034ea:	f243 13c9 	movw	r3, #12745	; 0x31c9
 80034ee:	f6c0 0300 	movt	r3, #2048	; 0x800
 80034f2:	4798      	blx	r3
	/* Enable the USART1 */
	USART_Cmd(USART1, ENABLE);
 80034f4:	f643 0000 	movw	r0, #14336	; 0x3800
 80034f8:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80034fc:	f04f 0101 	mov.w	r1, #1
 8003500:	f641 03ad 	movw	r3, #6317	; 0x18ad
 8003504:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003508:	4798      	blx	r3
}
 800350a:	f107 0720 	add.w	r7, r7, #32
 800350e:	46bd      	mov	sp, r7
 8003510:	bd80      	pop	{r7, pc}
 8003512:	bf00      	nop
 8003514:	2000434c 	.word	0x2000434c

08003518 <uart1PutChar>:
	}
	return 0;
}
//-----------------------------------------------------------------------------------
int uart1PutChar(unsigned char ch)
{
 8003518:	b480      	push	{r7}
 800351a:	b083      	sub	sp, #12
 800351c:	af00      	add	r7, sp, #0
 800351e:	4603      	mov	r3, r0
 8003520:	71fb      	strb	r3, [r7, #7]

	//	IEC2bits.DMA4IE = 0;
	u1Fifo.txBufB[u1Fifo.txCurrentEnd] = ch;
 8003522:	f244 3340 	movw	r3, #17216	; 0x4340
 8003526:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800352a:	689a      	ldr	r2, [r3, #8]
 800352c:	f244 3340 	movw	r3, #17216	; 0x4340
 8003530:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003534:	4413      	add	r3, r2
 8003536:	79fa      	ldrb	r2, [r7, #7]
 8003538:	f883 244c 	strb.w	r2, [r3, #1100]	; 0x44c
	u1Fifo.txCurrentEnd++;
 800353c:	f244 3340 	movw	r3, #17216	; 0x4340
 8003540:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003544:	689b      	ldr	r3, [r3, #8]
 8003546:	f103 0201 	add.w	r2, r3, #1
 800354a:	f244 3340 	movw	r3, #17216	; 0x4340
 800354e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003552:	609a      	str	r2, [r3, #8]
	u1Fifo.txCurrentEnd &= UARTTX_FIFOB_SIZE_MASK;
 8003554:	f244 3340 	movw	r3, #17216	; 0x4340
 8003558:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800355c:	689b      	ldr	r3, [r3, #8]
 800355e:	ea4f 5283 	mov.w	r2, r3, lsl #22
 8003562:	ea4f 5292 	mov.w	r2, r2, lsr #22
 8003566:	f244 3340 	movw	r3, #17216	; 0x4340
 800356a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800356e:	609a      	str	r2, [r3, #8]

	if (u1Fifo.txCurrentEnd == u1Fifo.txCurrentStart)
 8003570:	f244 3340 	movw	r3, #17216	; 0x4340
 8003574:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003578:	689a      	ldr	r2, [r3, #8]
 800357a:	f244 3340 	movw	r3, #17216	; 0x4340
 800357e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003582:	685b      	ldr	r3, [r3, #4]
 8003584:	429a      	cmp	r2, r3
 8003586:	d11c      	bne.n	80035c2 <uart1PutChar+0xaa>
	{
		u1Fifo.txCurrentEnd--;
 8003588:	f244 3340 	movw	r3, #17216	; 0x4340
 800358c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003590:	689b      	ldr	r3, [r3, #8]
 8003592:	f103 32ff 	add.w	r2, r3, #4294967295
 8003596:	f244 3340 	movw	r3, #17216	; 0x4340
 800359a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800359e:	609a      	str	r2, [r3, #8]
		u1Fifo.txCurrentEnd &= UARTTX_FIFOB_SIZE_MASK;
 80035a0:	f244 3340 	movw	r3, #17216	; 0x4340
 80035a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035a8:	689b      	ldr	r3, [r3, #8]
 80035aa:	ea4f 5283 	mov.w	r2, r3, lsl #22
 80035ae:	ea4f 5292 	mov.w	r2, r2, lsr #22
 80035b2:	f244 3340 	movw	r3, #17216	; 0x4340
 80035b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035ba:	609a      	str	r2, [r3, #8]
		//		IEC2bits.DMA4IE = 1;
		return 0;
 80035bc:	f04f 0300 	mov.w	r3, #0
 80035c0:	e001      	b.n	80035c6 <uart1PutChar+0xae>
	}
	//	IEC2bits.DMA4IE = 1;
	return 1;
 80035c2:	f04f 0301 	mov.w	r3, #1
}
 80035c6:	4618      	mov	r0, r3
 80035c8:	f107 070c 	add.w	r7, r7, #12
 80035cc:	46bd      	mov	sp, r7
 80035ce:	bc80      	pop	{r7}
 80035d0:	4770      	bx	lr
 80035d2:	bf00      	nop

080035d4 <uart1TxTask>:
//-----------------------------------------------------------------------------------
void uart1TxTask()
{
 80035d4:	b580      	push	{r7, lr}
 80035d6:	b084      	sub	sp, #16
 80035d8:	af02      	add	r7, sp, #8
	unsigned int cnt = 0;
 80035da:	f04f 0300 	mov.w	r3, #0
 80035de:	607b      	str	r3, [r7, #4]
	// If DMA COMPLITE
	if ((USART1_TX_DMA->CCR & ((uint32_t) 0x00000001)) == 0)
 80035e0:	f240 0344 	movw	r3, #68	; 0x44
 80035e4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80035e8:	681b      	ldr	r3, [r3, #0]
 80035ea:	f003 0301 	and.w	r3, r3, #1
 80035ee:	2b00      	cmp	r3, #0
 80035f0:	d156      	bne.n	80036a0 <uart1TxTask+0xcc>
	{
		while ((u1Fifo.txCurrentStart != u1Fifo.txCurrentEnd) && (cnt
 80035f2:	e031      	b.n	8003658 <uart1TxTask+0x84>
				< UARTTX_FIFO_SIZE))
		{
			u1Fifo.txBuf[cnt] = u1Fifo.txBufB[u1Fifo.txCurrentStart];
 80035f4:	6879      	ldr	r1, [r7, #4]
 80035f6:	f244 3340 	movw	r3, #17216	; 0x4340
 80035fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035fe:	685a      	ldr	r2, [r3, #4]
 8003600:	f244 3340 	movw	r3, #17216	; 0x4340
 8003604:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003608:	4413      	add	r3, r2
 800360a:	f893 244c 	ldrb.w	r2, [r3, #1100]	; 0x44c
 800360e:	f244 3340 	movw	r3, #17216	; 0x4340
 8003612:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003616:	440b      	add	r3, r1
 8003618:	f883 240c 	strb.w	r2, [r3, #1036]	; 0x40c
			u1Fifo.txCurrentStart++;
 800361c:	f244 3340 	movw	r3, #17216	; 0x4340
 8003620:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003624:	685b      	ldr	r3, [r3, #4]
 8003626:	f103 0201 	add.w	r2, r3, #1
 800362a:	f244 3340 	movw	r3, #17216	; 0x4340
 800362e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003632:	605a      	str	r2, [r3, #4]
			u1Fifo.txCurrentStart &= UARTTX_FIFOB_SIZE_MASK;
 8003634:	f244 3340 	movw	r3, #17216	; 0x4340
 8003638:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800363c:	685b      	ldr	r3, [r3, #4]
 800363e:	ea4f 5283 	mov.w	r2, r3, lsl #22
 8003642:	ea4f 5292 	mov.w	r2, r2, lsr #22
 8003646:	f244 3340 	movw	r3, #17216	; 0x4340
 800364a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800364e:	605a      	str	r2, [r3, #4]
			cnt++;
 8003650:	687b      	ldr	r3, [r7, #4]
 8003652:	f103 0301 	add.w	r3, r3, #1
 8003656:	607b      	str	r3, [r7, #4]
{
	unsigned int cnt = 0;
	// If DMA COMPLITE
	if ((USART1_TX_DMA->CCR & ((uint32_t) 0x00000001)) == 0)
	{
		while ((u1Fifo.txCurrentStart != u1Fifo.txCurrentEnd) && (cnt
 8003658:	f244 3340 	movw	r3, #17216	; 0x4340
 800365c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003660:	685a      	ldr	r2, [r3, #4]
 8003662:	f244 3340 	movw	r3, #17216	; 0x4340
 8003666:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800366a:	689b      	ldr	r3, [r3, #8]
 800366c:	429a      	cmp	r2, r3
 800366e:	d002      	beq.n	8003676 <uart1TxTask+0xa2>
 8003670:	687b      	ldr	r3, [r7, #4]
 8003672:	2b3f      	cmp	r3, #63	; 0x3f
 8003674:	d9be      	bls.n	80035f4 <uart1TxTask+0x20>
			u1Fifo.txBuf[cnt] = u1Fifo.txBufB[u1Fifo.txCurrentStart];
			u1Fifo.txCurrentStart++;
			u1Fifo.txCurrentStart &= UARTTX_FIFOB_SIZE_MASK;
			cnt++;
		}
		if (cnt > 0)
 8003676:	687b      	ldr	r3, [r7, #4]
 8003678:	2b00      	cmp	r3, #0
 800367a:	d011      	beq.n	80036a0 <uart1TxTask+0xcc>
		{
			uartTxDMAConfiguration(USART1, USART1_TX_DMA, u1Fifo.txBuf, cnt,
 800367c:	f04f 0301 	mov.w	r3, #1
 8003680:	9300      	str	r3, [sp, #0]
 8003682:	f643 0000 	movw	r0, #14336	; 0x3800
 8003686:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800368a:	f240 0144 	movw	r1, #68	; 0x44
 800368e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8003692:	4a05      	ldr	r2, [pc, #20]	; (80036a8 <uart1TxTask+0xd4>)
 8003694:	687b      	ldr	r3, [r7, #4]
 8003696:	f243 2c5d 	movw	ip, #12893	; 0x325d
 800369a:	f6c0 0c00 	movt	ip, #2048	; 0x800
 800369e:	47e0      	blx	ip
					1);
		}
	}
}
 80036a0:	f107 0708 	add.w	r7, r7, #8
 80036a4:	46bd      	mov	sp, r7
 80036a6:	bd80      	pop	{r7, pc}
 80036a8:	2000474c 	.word	0x2000474c

080036ac <uart1Write>:
	rezult = uart1PutChar(0x55);
	rezult = uart1PutChar(0x03);
	uart1TxTask();
}
void uart1Write(unsigned char *src, unsigned int len)
{
 80036ac:	b580      	push	{r7, lr}
 80036ae:	b084      	sub	sp, #16
 80036b0:	af00      	add	r7, sp, #0
 80036b2:	6078      	str	r0, [r7, #4]
 80036b4:	6039      	str	r1, [r7, #0]
	unsigned char ch;
	unsigned int rezult;
	if (len == 0)
 80036b6:	683b      	ldr	r3, [r7, #0]
 80036b8:	2b00      	cmp	r3, #0
 80036ba:	d111      	bne.n	80036e0 <uart1Write+0x34>
		return;
 80036bc:	e022      	b.n	8003704 <uart1Write+0x58>
	while (len--)
	{
		ch = *src;
 80036be:	687b      	ldr	r3, [r7, #4]
 80036c0:	781b      	ldrb	r3, [r3, #0]
 80036c2:	72fb      	strb	r3, [r7, #11]
		rezult = uart1PutChar(ch);
 80036c4:	7afb      	ldrb	r3, [r7, #11]
 80036c6:	4618      	mov	r0, r3
 80036c8:	f243 5319 	movw	r3, #13593	; 0x3519
 80036cc:	f6c0 0300 	movt	r3, #2048	; 0x800
 80036d0:	4798      	blx	r3
 80036d2:	4603      	mov	r3, r0
 80036d4:	60fb      	str	r3, [r7, #12]
		src++;
 80036d6:	687b      	ldr	r3, [r7, #4]
 80036d8:	f103 0301 	add.w	r3, r3, #1
 80036dc:	607b      	str	r3, [r7, #4]
 80036de:	e000      	b.n	80036e2 <uart1Write+0x36>
{
	unsigned char ch;
	unsigned int rezult;
	if (len == 0)
		return;
	while (len--)
 80036e0:	bf00      	nop
 80036e2:	683b      	ldr	r3, [r7, #0]
 80036e4:	2b00      	cmp	r3, #0
 80036e6:	bf0c      	ite	eq
 80036e8:	2300      	moveq	r3, #0
 80036ea:	2301      	movne	r3, #1
 80036ec:	b2db      	uxtb	r3, r3
 80036ee:	683a      	ldr	r2, [r7, #0]
 80036f0:	f102 32ff 	add.w	r2, r2, #4294967295
 80036f4:	603a      	str	r2, [r7, #0]
 80036f6:	2b00      	cmp	r3, #0
 80036f8:	d1e1      	bne.n	80036be <uart1Write+0x12>
	{
		ch = *src;
		rezult = uart1PutChar(ch);
		src++;
	}
	uart1TxTask();
 80036fa:	f243 53d5 	movw	r3, #13781	; 0x35d5
 80036fe:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003702:	4798      	blx	r3
}
 8003704:	f107 0710 	add.w	r7, r7, #16
 8003708:	46bd      	mov	sp, r7
 800370a:	bd80      	pop	{r7, pc}

0800370c <DMA1_Channel4_IRQHandler>:

//UART 1 DMA INTERRUPT
void DMA1_Channel4_IRQHandler(void)
{
 800370c:	b580      	push	{r7, lr}
 800370e:	af00      	add	r7, sp, #0

	/* Disable DMA1_Channel4 transfer*/
	DMA_Cmd(USART1_TX_DMA, DISABLE);
 8003710:	f240 0044 	movw	r0, #68	; 0x44
 8003714:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003718:	f04f 0100 	mov.w	r1, #0
 800371c:	f242 538d 	movw	r3, #9613	; 0x258d
 8003720:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003724:	4798      	blx	r3
	/*  Clear DMA1_Channel4 Transfer Complete Flag*/
	DMA_ClearFlag(DMA1_FLAG_TC4);
 8003726:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800372a:	f242 6305 	movw	r3, #9733	; 0x2605
 800372e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003732:	4798      	blx	r3
	uart1TxTask();
 8003734:	f243 53d5 	movw	r3, #13781	; 0x35d5
 8003738:	f6c0 0300 	movt	r3, #2048	; 0x800
 800373c:	4798      	blx	r3
}
 800373e:	bd80      	pop	{r7, pc}

08003740 <USART1_IRQHandler>:
void USART1_IRQHandler(void)
{
 8003740:	b480      	push	{r7}
 8003742:	af00      	add	r7, sp, #0
	//u1Fifo.rxBuf[0] = '$';

}
 8003744:	46bd      	mov	sp, r7
 8003746:	bc80      	pop	{r7}
 8003748:	4770      	bx	lr
 800374a:	bf00      	nop

0800374c <pwmcInit>:
#define PWMC_CHANELS_AMOUNT 2

uint32_t pwmcVlue[PWMC_CHANELS_AMOUNT];

void pwmcInit()
{
 800374c:	b580      	push	{r7, lr}
 800374e:	b088      	sub	sp, #32
 8003750:	af00      	add	r7, sp, #0
	TIM_ICInitTypeDef TIM_ICInitStructure;
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

	NVIC_InitTypeDef NVIC_InitStructure;

	NVIC_InitStructure.NVIC_IRQChannel = TIM8_CC_IRQn;
 8003752:	f04f 032e 	mov.w	r3, #46	; 0x2e
 8003756:	703b      	strb	r3, [r7, #0]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8003758:	f04f 0300 	mov.w	r3, #0
 800375c:	707b      	strb	r3, [r7, #1]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 800375e:	f04f 0300 	mov.w	r3, #0
 8003762:	70bb      	strb	r3, [r7, #2]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8003764:	f04f 0301 	mov.w	r3, #1
 8003768:	70fb      	strb	r3, [r7, #3]
	NVIC_Init(&NVIC_InitStructure);
 800376a:	463b      	mov	r3, r7
 800376c:	4618      	mov	r0, r3
 800376e:	f642 4385 	movw	r3, #11397	; 0x2c85
 8003772:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003776:	4798      	blx	r3

	/* GPIOC Configuration:TIM8 Channel3-4 in Input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;
 8003778:	f44f 7340 	mov.w	r3, #768	; 0x300
 800377c:	83bb      	strh	r3, [r7, #28]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 800377e:	f04f 0304 	mov.w	r3, #4
 8003782:	77fb      	strb	r3, [r7, #31]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8003784:	f107 031c 	add.w	r3, r7, #28
 8003788:	f241 0000 	movw	r0, #4096	; 0x1000
 800378c:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003790:	4619      	mov	r1, r3
 8003792:	f641 2371 	movw	r3, #6769	; 0x1a71
 8003796:	f6c0 0300 	movt	r3, #2048	; 0x800
 800379a:	4798      	blx	r3

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
 800379c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80037a0:	f04f 0101 	mov.w	r1, #1
 80037a4:	f242 13f9 	movw	r3, #8697	; 0x21f9
 80037a8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80037ac:	4798      	blx	r3
	/*---------------------------- TIM8 Configuration ----------------------------*/
	/* Time base configuration */
	TIM_TimeBaseStructure.TIM_Period = 65535;
 80037ae:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80037b2:	813b      	strh	r3, [r7, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = 36000;
 80037b4:	f648 43a0 	movw	r3, #36000	; 0x8ca0
 80037b8:	80bb      	strh	r3, [r7, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;//TIM_CKD_DIV8;
 80037ba:	f04f 0300 	mov.w	r3, #0
 80037be:	817b      	strh	r3, [r7, #10]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80037c0:	f04f 0300 	mov.w	r3, #0
 80037c4:	80fb      	strh	r3, [r7, #6]

	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
 80037c6:	f107 0304 	add.w	r3, r7, #4
 80037ca:	f243 4000 	movw	r0, #13312	; 0x3400
 80037ce:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80037d2:	4619      	mov	r1, r3
 80037d4:	f242 633d 	movw	r3, #9789	; 0x263d
 80037d8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80037dc:	4798      	blx	r3
	// Input Capture Configuration --------------------------------
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_3;
 80037de:	f04f 0308 	mov.w	r3, #8
 80037e2:	823b      	strh	r3, [r7, #16]
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
 80037e4:	f04f 0300 	mov.w	r3, #0
 80037e8:	827b      	strh	r3, [r7, #18]
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
 80037ea:	f04f 0301 	mov.w	r3, #1
 80037ee:	82bb      	strh	r3, [r7, #20]
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV8;
 80037f0:	f04f 030c 	mov.w	r3, #12
 80037f4:	82fb      	strh	r3, [r7, #22]
	TIM_ICInitStructure.TIM_ICFilter = 0x00;
 80037f6:	f04f 0300 	mov.w	r3, #0
 80037fa:	833b      	strh	r3, [r7, #24]

	TIM_ICInit(TIM8, &TIM_ICInitStructure);
 80037fc:	f107 0310 	add.w	r3, r7, #16
 8003800:	f243 4000 	movw	r0, #13312	; 0x3400
 8003804:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003808:	4619      	mov	r1, r3
 800380a:	f242 63bd 	movw	r3, #9917	; 0x26bd
 800380e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003812:	4798      	blx	r3
	// Input Capture Configuration --------------------------------
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_4;
 8003814:	f04f 030c 	mov.w	r3, #12
 8003818:	823b      	strh	r3, [r7, #16]
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
 800381a:	f04f 0300 	mov.w	r3, #0
 800381e:	827b      	strh	r3, [r7, #18]
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
 8003820:	f04f 0301 	mov.w	r3, #1
 8003824:	82bb      	strh	r3, [r7, #20]
	TIM_ICInitStructure.TIM_ICPrescaler = 0;//TIM_ICPSC_DIV8;
 8003826:	f04f 0300 	mov.w	r3, #0
 800382a:	82fb      	strh	r3, [r7, #22]
	TIM_ICInitStructure.TIM_ICFilter = 0x00;
 800382c:	f04f 0300 	mov.w	r3, #0
 8003830:	833b      	strh	r3, [r7, #24]

	TIM_ICInit(TIM8, &TIM_ICInitStructure);
 8003832:	f107 0310 	add.w	r3, r7, #16
 8003836:	f243 4000 	movw	r0, #13312	; 0x3400
 800383a:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800383e:	4619      	mov	r1, r3
 8003840:	f242 63bd 	movw	r3, #9917	; 0x26bd
 8003844:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003848:	4798      	blx	r3

	// Enable the CC2 Interrupt Request
	TIM_ITConfig(TIM8, TIM_IT_CC3, ENABLE);
 800384a:	f243 4000 	movw	r0, #13312	; 0x3400
 800384e:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003852:	f04f 0108 	mov.w	r1, #8
 8003856:	f04f 0201 	mov.w	r2, #1
 800385a:	f242 73dd 	movw	r3, #10205	; 0x27dd
 800385e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003862:	4798      	blx	r3
	// Enable the CC2 Interrupt Request
	TIM_ITConfig(TIM8, TIM_IT_CC4, ENABLE);
 8003864:	f243 4000 	movw	r0, #13312	; 0x3400
 8003868:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800386c:	f04f 0110 	mov.w	r1, #16
 8003870:	f04f 0201 	mov.w	r2, #1
 8003874:	f242 73dd 	movw	r3, #10205	; 0x27dd
 8003878:	f6c0 0300 	movt	r3, #2048	; 0x800
 800387c:	4798      	blx	r3

	// TIM enable counter
	TIM_Cmd(TIM8, ENABLE);
 800387e:	f243 4000 	movw	r0, #13312	; 0x3400
 8003882:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003886:	f04f 0101 	mov.w	r1, #1
 800388a:	f242 7395 	movw	r3, #10133	; 0x2795
 800388e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003892:	4798      	blx	r3



}
 8003894:	f107 0720 	add.w	r7, r7, #32
 8003898:	46bd      	mov	sp, r7
 800389a:	bd80      	pop	{r7, pc}

0800389c <TIM8_CC_IRQHandler>:
void TIM8_CC_IRQHandler(void)
{
 800389c:	b580      	push	{r7, lr}
 800389e:	b082      	sub	sp, #8
 80038a0:	af00      	add	r7, sp, #0
	static uint16_t oldCC3, oldCC4,oldP4;
	static int led1 = 0, led2 = 0;
	uint16_t tmp;
	if (TIM_GetITStatus(TIM8, TIM_IT_CC3) == SET)
 80038a2:	f243 4000 	movw	r0, #13312	; 0x3400
 80038a6:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80038aa:	f04f 0108 	mov.w	r1, #8
 80038ae:	f642 1379 	movw	r3, #10617	; 0x2979
 80038b2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80038b6:	4798      	blx	r3
 80038b8:	4603      	mov	r3, r0
 80038ba:	2b01      	cmp	r3, #1
 80038bc:	d15d      	bne.n	800397a <TIM8_CC_IRQHandler+0xde>
	{
		if (led1 == 0)
 80038be:	f642 23c8 	movw	r3, #10952	; 0x2ac8
 80038c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80038c6:	681b      	ldr	r3, [r3, #0]
 80038c8:	2b00      	cmp	r3, #0
 80038ca:	d10b      	bne.n	80038e4 <TIM8_CC_IRQHandler+0x48>
		{
			GPIO_SetBits(GPIOB, GPIO_Pin_1);
 80038cc:	f640 4000 	movw	r0, #3072	; 0xc00
 80038d0:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80038d4:	f04f 0102 	mov.w	r1, #2
 80038d8:	f641 4331 	movw	r3, #7217	; 0x1c31
 80038dc:	f6c0 0300 	movt	r3, #2048	; 0x800
 80038e0:	4798      	blx	r3
 80038e2:	e00a      	b.n	80038fa <TIM8_CC_IRQHandler+0x5e>
		}
		else
		{
			GPIO_ResetBits(GPIOB, GPIO_Pin_1);
 80038e4:	f640 4000 	movw	r0, #3072	; 0xc00
 80038e8:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80038ec:	f04f 0102 	mov.w	r1, #2
 80038f0:	f641 434d 	movw	r3, #7245	; 0x1c4d
 80038f4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80038f8:	4798      	blx	r3
		}
		led1 ^= 1;
 80038fa:	f642 23c8 	movw	r3, #10952	; 0x2ac8
 80038fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003902:	681b      	ldr	r3, [r3, #0]
 8003904:	f083 0201 	eor.w	r2, r3, #1
 8003908:	f642 23c8 	movw	r3, #10952	; 0x2ac8
 800390c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003910:	601a      	str	r2, [r3, #0]
		// Clear TIM3 Capture compare interrupt pending bit
		TIM_ClearITPendingBit(TIM8, TIM_IT_CC3);
 8003912:	f243 4000 	movw	r0, #13312	; 0x3400
 8003916:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800391a:	f04f 0108 	mov.w	r1, #8
 800391e:	f642 13dd 	movw	r3, #10717	; 0x29dd
 8003922:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003926:	4798      	blx	r3
		tmp = TIM_GetCapture3(TIM8);
 8003928:	f243 4000 	movw	r0, #13312	; 0x3400
 800392c:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003930:	f642 1341 	movw	r3, #10561	; 0x2941
 8003934:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003938:	4798      	blx	r3
 800393a:	4603      	mov	r3, r0
 800393c:	80fb      	strh	r3, [r7, #6]

		// Wind Calculation
		// 100hz = 40 ms
		pwmcVlue[0] = (8 * 100000000 / 25) / ((uint32_t) (tmp - oldCC3) * 5); // Convert in mm/s
 800393e:	88fa      	ldrh	r2, [r7, #6]
 8003940:	f642 23cc 	movw	r3, #10956	; 0x2acc
 8003944:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003948:	881b      	ldrh	r3, [r3, #0]
 800394a:	ebc3 0302 	rsb	r3, r3, r2
 800394e:	461a      	mov	r2, r3
 8003950:	4613      	mov	r3, r2
 8003952:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003956:	441a      	add	r2, r3
 8003958:	f644 0300 	movw	r3, #18432	; 0x4800
 800395c:	f2c0 13e8 	movt	r3, #488	; 0x1e8
 8003960:	fbb3 f2f2 	udiv	r2, r3, r2
 8003964:	f644 338c 	movw	r3, #19340	; 0x4b8c
 8003968:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800396c:	601a      	str	r2, [r3, #0]
		oldCC3 = tmp;
 800396e:	f642 23cc 	movw	r3, #10956	; 0x2acc
 8003972:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003976:	88fa      	ldrh	r2, [r7, #6]
 8003978:	801a      	strh	r2, [r3, #0]
	}
	if (TIM_GetITStatus(TIM8, TIM_IT_CC4) == SET)
 800397a:	f243 4000 	movw	r0, #13312	; 0x3400
 800397e:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003982:	f04f 0110 	mov.w	r1, #16
 8003986:	f642 1379 	movw	r3, #10617	; 0x2979
 800398a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800398e:	4798      	blx	r3
 8003990:	4603      	mov	r3, r0
 8003992:	2b01      	cmp	r3, #1
 8003994:	d171      	bne.n	8003a7a <TIM8_CC_IRQHandler+0x1de>
	{
		if (led2 == 0)
 8003996:	f642 23d0 	movw	r3, #10960	; 0x2ad0
 800399a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800399e:	681b      	ldr	r3, [r3, #0]
 80039a0:	2b00      	cmp	r3, #0
 80039a2:	d10b      	bne.n	80039bc <TIM8_CC_IRQHandler+0x120>
		{
			GPIO_SetBits(GPIOB, GPIO_Pin_0);
 80039a4:	f640 4000 	movw	r0, #3072	; 0xc00
 80039a8:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80039ac:	f04f 0101 	mov.w	r1, #1
 80039b0:	f641 4331 	movw	r3, #7217	; 0x1c31
 80039b4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80039b8:	4798      	blx	r3
 80039ba:	e00a      	b.n	80039d2 <TIM8_CC_IRQHandler+0x136>
		}
		else
		{
			GPIO_ResetBits(GPIOB, GPIO_Pin_0);
 80039bc:	f640 4000 	movw	r0, #3072	; 0xc00
 80039c0:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80039c4:	f04f 0101 	mov.w	r1, #1
 80039c8:	f641 434d 	movw	r3, #7245	; 0x1c4d
 80039cc:	f6c0 0300 	movt	r3, #2048	; 0x800
 80039d0:	4798      	blx	r3
		}
		led2 ^= 1;
 80039d2:	f642 23d0 	movw	r3, #10960	; 0x2ad0
 80039d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80039da:	681b      	ldr	r3, [r3, #0]
 80039dc:	f083 0201 	eor.w	r2, r3, #1
 80039e0:	f642 23d0 	movw	r3, #10960	; 0x2ad0
 80039e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80039e8:	601a      	str	r2, [r3, #0]

		// Clear TIM3 Capture compare interrupt pending bit
		TIM_ClearITPendingBit(TIM8, TIM_IT_CC4);
 80039ea:	f243 4000 	movw	r0, #13312	; 0x3400
 80039ee:	f2c4 0001 	movt	r0, #16385	; 0x4001
 80039f2:	f04f 0110 	mov.w	r1, #16
 80039f6:	f642 13dd 	movw	r3, #10717	; 0x29dd
 80039fa:	f6c0 0300 	movt	r3, #2048	; 0x800
 80039fe:	4798      	blx	r3
		tmp = TIM_GetCapture4(TIM8);
 8003a00:	f243 4000 	movw	r0, #13312	; 0x3400
 8003a04:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003a08:	f642 135d 	movw	r3, #10589	; 0x295d
 8003a0c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003a10:	4798      	blx	r3
 8003a12:	4603      	mov	r3, r0
 8003a14:	80fb      	strh	r3, [r7, #6]
		// Generator RPM calculation
		// 500us - 1 cycle
		pwmcVlue[1] = 60 * 10000000 / ((uint32_t) (tmp - oldCC4 + oldP4) * 5); // Convert in rpm*10^-3 in 1 minute
 8003a16:	88fa      	ldrh	r2, [r7, #6]
 8003a18:	f642 23d4 	movw	r3, #10964	; 0x2ad4
 8003a1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a20:	881b      	ldrh	r3, [r3, #0]
 8003a22:	ebc3 0202 	rsb	r2, r3, r2
 8003a26:	f642 23d6 	movw	r3, #10966	; 0x2ad6
 8003a2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a2e:	881b      	ldrh	r3, [r3, #0]
 8003a30:	4413      	add	r3, r2
 8003a32:	461a      	mov	r2, r3
 8003a34:	4613      	mov	r3, r2
 8003a36:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003a3a:	441a      	add	r2, r3
 8003a3c:	f244 6300 	movw	r3, #17920	; 0x4600
 8003a40:	f2c2 33c3 	movt	r3, #9155	; 0x23c3
 8003a44:	fbb3 f2f2 	udiv	r2, r3, r2
 8003a48:	f644 338c 	movw	r3, #19340	; 0x4b8c
 8003a4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a50:	605a      	str	r2, [r3, #4]
		oldP4 = tmp - oldCC4;
 8003a52:	f642 23d4 	movw	r3, #10964	; 0x2ad4
 8003a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a5a:	881b      	ldrh	r3, [r3, #0]
 8003a5c:	88fa      	ldrh	r2, [r7, #6]
 8003a5e:	ebc3 0302 	rsb	r3, r3, r2
 8003a62:	b29a      	uxth	r2, r3
 8003a64:	f642 23d6 	movw	r3, #10966	; 0x2ad6
 8003a68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a6c:	801a      	strh	r2, [r3, #0]
		oldCC4 = tmp;
 8003a6e:	f642 23d4 	movw	r3, #10964	; 0x2ad4
 8003a72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a76:	88fa      	ldrh	r2, [r7, #6]
 8003a78:	801a      	strh	r2, [r3, #0]
	}

}
 8003a7a:	f107 0708 	add.w	r7, r7, #8
 8003a7e:	46bd      	mov	sp, r7
 8003a80:	bd80      	pop	{r7, pc}
 8003a82:	bf00      	nop

08003a84 <pwmcGet>:

uint32_t pwmcGet(int i)
{
 8003a84:	b480      	push	{r7}
 8003a86:	b083      	sub	sp, #12
 8003a88:	af00      	add	r7, sp, #0
 8003a8a:	6078      	str	r0, [r7, #4]
	if (i == 0)
 8003a8c:	687b      	ldr	r3, [r7, #4]
 8003a8e:	2b00      	cmp	r3, #0
 8003a90:	d105      	bne.n	8003a9e <pwmcGet+0x1a>
	{
		return pwmcVlue[0];
 8003a92:	f644 338c 	movw	r3, #19340	; 0x4b8c
 8003a96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003a9a:	681b      	ldr	r3, [r3, #0]
 8003a9c:	e004      	b.n	8003aa8 <pwmcGet+0x24>
	};
	return pwmcVlue[1];
 8003a9e:	f644 338c 	movw	r3, #19340	; 0x4b8c
 8003aa2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003aa6:	685b      	ldr	r3, [r3, #4]

}
 8003aa8:	4618      	mov	r0, r3
 8003aaa:	f107 070c 	add.w	r7, r7, #12
 8003aae:	46bd      	mov	sp, r7
 8003ab0:	bc80      	pop	{r7}
 8003ab2:	4770      	bx	lr

08003ab4 <main>:

#define vLogicaTask_PRIORITY            ( tskIDLE_PRIORITY + 2 )
#define vRs485Task_PRIORITY            ( tskIDLE_PRIORITY + 1 )

int main(void)
{
 8003ab4:	b580      	push	{r7, lr}
 8003ab6:	b084      	sub	sp, #16
 8003ab8:	af04      	add	r7, sp, #16
	hwInit();
 8003aba:	f240 337d 	movw	r3, #893	; 0x37d
 8003abe:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003ac2:	4798      	blx	r3
	/* Configure the GPIO ports */
	GPIO_Configuration();
 8003ac4:	f643 3361 	movw	r3, #15201	; 0x3b61
 8003ac8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003acc:	4798      	blx	r3

	/* Turn on/off LED(s) */

	xTaskCreate(vLogicaTask, (const signed portCHAR * const ) "Logica",
 8003ace:	f244 0380 	movw	r3, #16512	; 0x4080
 8003ad2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003ad6:	f04f 0202 	mov.w	r2, #2
 8003ada:	9200      	str	r2, [sp, #0]
 8003adc:	f04f 0200 	mov.w	r2, #0
 8003ae0:	9201      	str	r2, [sp, #4]
 8003ae2:	f04f 0200 	mov.w	r2, #0
 8003ae6:	9202      	str	r2, [sp, #8]
 8003ae8:	f04f 0200 	mov.w	r2, #0
 8003aec:	9203      	str	r2, [sp, #12]
 8003aee:	f643 30f9 	movw	r0, #15353	; 0x3bf9
 8003af2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003af6:	4619      	mov	r1, r3
 8003af8:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8003afc:	f04f 0300 	mov.w	r3, #0
 8003b00:	f240 3c99 	movw	ip, #921	; 0x399
 8003b04:	f6c0 0c00 	movt	ip, #2048	; 0x800
 8003b08:	47e0      	blx	ip
			vLogicaTask_STACK_SIZE, NULL, vLogicaTask_PRIORITY,
			(xTaskHandle *) NULL);
	/* Start the scheduler. */

	xTaskCreate(vRs485Task, (const signed portCHAR * const ) "RS485",
 8003b0a:	f244 0388 	movw	r3, #16520	; 0x4088
 8003b0e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003b12:	f04f 0201 	mov.w	r2, #1
 8003b16:	9200      	str	r2, [sp, #0]
 8003b18:	f04f 0200 	mov.w	r2, #0
 8003b1c:	9201      	str	r2, [sp, #4]
 8003b1e:	f04f 0200 	mov.w	r2, #0
 8003b22:	9202      	str	r2, [sp, #8]
 8003b24:	f04f 0200 	mov.w	r2, #0
 8003b28:	9203      	str	r2, [sp, #12]
 8003b2a:	f643 6005 	movw	r0, #15877	; 0x3e05
 8003b2e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003b32:	4619      	mov	r1, r3
 8003b34:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8003b38:	f04f 0300 	mov.w	r3, #0
 8003b3c:	f240 3c99 	movw	ip, #921	; 0x399
 8003b40:	f6c0 0c00 	movt	ip, #2048	; 0x800
 8003b44:	47e0      	blx	ip
			vRs485Task_STACK_SIZE, NULL, vRs485Task_PRIORITY,
			(xTaskHandle *) NULL);

	/* Start the scheduler. */

	vTaskStartScheduler();
 8003b46:	f240 6345 	movw	r3, #1605	; 0x645
 8003b4a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003b4e:	4798      	blx	r3
	while (1)
	{
	};
 8003b50:	e7fe      	b.n	8003b50 <main+0x9c>
 8003b52:	bf00      	nop

08003b54 <vApplicationTickHook>:
void vApplicationIdleHook(void)
{

}
void vApplicationTickHook(void)
{
 8003b54:	b480      	push	{r7}
 8003b56:	af00      	add	r7, sp, #0

}
 8003b58:	46bd      	mov	sp, r7
 8003b5a:	bc80      	pop	{r7}
 8003b5c:	4770      	bx	lr
 8003b5e:	bf00      	nop

08003b60 <GPIO_Configuration>:
	while (1)
		;
}

void GPIO_Configuration(void)
{
 8003b60:	b580      	push	{r7, lr}
 8003b62:	b082      	sub	sp, #8
 8003b64:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	/* Enable GPIOA clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
 8003b66:	f04f 0004 	mov.w	r0, #4
 8003b6a:	f04f 0101 	mov.w	r1, #1
 8003b6e:	f242 13f9 	movw	r3, #8697	; 0x21f9
 8003b72:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003b76:	4798      	blx	r3
	/* Enable GPIOC clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
 8003b78:	f04f 0010 	mov.w	r0, #16
 8003b7c:	f04f 0101 	mov.w	r1, #1
 8003b80:	f242 13f9 	movw	r3, #8697	; 0x21f9
 8003b84:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003b88:	4798      	blx	r3
	/* Enable GPIOB clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
 8003b8a:	f04f 0008 	mov.w	r0, #8
 8003b8e:	f04f 0101 	mov.w	r1, #1
 8003b92:	f242 13f9 	movw	r3, #8697	; 0x21f9
 8003b96:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003b9a:	4798      	blx	r3

	/* Configure PC.4 as Output push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 8003b9c:	f04f 0320 	mov.w	r3, #32
 8003ba0:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8003ba2:	f04f 0301 	mov.w	r3, #1
 8003ba6:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8003ba8:	f04f 0310 	mov.w	r3, #16
 8003bac:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8003bae:	f107 0304 	add.w	r3, r7, #4
 8003bb2:	f241 0000 	movw	r0, #4096	; 0x1000
 8003bb6:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003bba:	4619      	mov	r1, r3
 8003bbc:	f641 2371 	movw	r3, #6769	; 0x1a71
 8003bc0:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003bc4:	4798      	blx	r3

	/* Configure  as Output push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
 8003bc6:	f04f 0303 	mov.w	r3, #3
 8003bca:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8003bcc:	f04f 0301 	mov.w	r3, #1
 8003bd0:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8003bd2:	f04f 0310 	mov.w	r3, #16
 8003bd6:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8003bd8:	f107 0304 	add.w	r3, r7, #4
 8003bdc:	f640 4000 	movw	r0, #3072	; 0xc00
 8003be0:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003be4:	4619      	mov	r1, r3
 8003be6:	f641 2371 	movw	r3, #6769	; 0x1a71
 8003bea:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003bee:	4798      	blx	r3

}
 8003bf0:	f107 0708 	add.w	r7, r7, #8
 8003bf4:	46bd      	mov	sp, r7
 8003bf6:	bd80      	pop	{r7, pc}

08003bf8 <vLogicaTask>:
{
	while (1)
	{


		GPIO_SetBits(GPIOC, GPIO_Pin_5);
 8003bf8:	f241 0000 	movw	r0, #4096	; 0x1000
 8003bfc:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003c00:	f04f 0120 	mov.w	r1, #32
 8003c04:	f641 4331 	movw	r3, #7217	; 0x1c31
 8003c08:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003c0c:	4798      	blx	r3



		/* Insert delay */
		vTaskDelay(50);
 8003c0e:	f04f 0032 	mov.w	r0, #50	; 0x32
 8003c12:	f240 5369 	movw	r3, #1385	; 0x569
 8003c16:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003c1a:	4798      	blx	r3
		/* Turn off led connected to PC.5 pin */
		GPIO_ResetBits(GPIOC, GPIO_Pin_5);
 8003c1c:	f241 0000 	movw	r0, #4096	; 0x1000
 8003c20:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003c24:	f04f 0120 	mov.w	r1, #32
 8003c28:	f641 434d 	movw	r3, #7245	; 0x1c4d
 8003c2c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003c30:	4798      	blx	r3


		/* Insert delay */
		vTaskDelay(50);
 8003c32:	f04f 0032 	mov.w	r0, #50	; 0x32
 8003c36:	f240 5369 	movw	r3, #1385	; 0x569
 8003c3a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003c3e:	4798      	blx	r3
	}
 8003c40:	e7da      	b.n	8003bf8 <vLogicaTask>
 8003c42:	bf00      	nop

08003c44 <sendstr>:

uint32_t T1, oldT1, cntT1;
uint32_t T2, oldT2, cntT2;

void sendstr(char *str)
{
 8003c44:	b580      	push	{r7, lr}
 8003c46:	b082      	sub	sp, #8
 8003c48:	af00      	add	r7, sp, #0
 8003c4a:	6078      	str	r0, [r7, #4]

	uart1Write((uint8_t*) str, strlen(str));
 8003c4c:	6878      	ldr	r0, [r7, #4]
 8003c4e:	f240 03dd 	movw	r3, #221	; 0xdd
 8003c52:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003c56:	4798      	blx	r3
 8003c58:	4603      	mov	r3, r0
 8003c5a:	6878      	ldr	r0, [r7, #4]
 8003c5c:	4619      	mov	r1, r3
 8003c5e:	f243 63ad 	movw	r3, #13997	; 0x36ad
 8003c62:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003c66:	4798      	blx	r3
	//	vTaskDelay(100);
	//	GPIO_ResetBits(GPIOA, GPIO_Pin_8);
}
 8003c68:	f107 0708 	add.w	r7, r7, #8
 8003c6c:	46bd      	mov	sp, r7
 8003c6e:	bd80      	pop	{r7, pc}

08003c70 <sendparam>:

void sendparam(char * name, int value)
{
 8003c70:	b580      	push	{r7, lr}
 8003c72:	b08c      	sub	sp, #48	; 0x30
 8003c74:	af00      	add	r7, sp, #0
 8003c76:	6078      	str	r0, [r7, #4]
 8003c78:	6039      	str	r1, [r7, #0]
	char tmp[32] = "";
 8003c7a:	f04f 0300 	mov.w	r3, #0
 8003c7e:	60bb      	str	r3, [r7, #8]
 8003c80:	f107 030c 	add.w	r3, r7, #12
 8003c84:	f04f 0200 	mov.w	r2, #0
 8003c88:	601a      	str	r2, [r3, #0]
 8003c8a:	f103 0304 	add.w	r3, r3, #4
 8003c8e:	f04f 0200 	mov.w	r2, #0
 8003c92:	601a      	str	r2, [r3, #0]
 8003c94:	f103 0304 	add.w	r3, r3, #4
 8003c98:	f04f 0200 	mov.w	r2, #0
 8003c9c:	601a      	str	r2, [r3, #0]
 8003c9e:	f103 0304 	add.w	r3, r3, #4
 8003ca2:	f04f 0200 	mov.w	r2, #0
 8003ca6:	601a      	str	r2, [r3, #0]
 8003ca8:	f103 0304 	add.w	r3, r3, #4
 8003cac:	f04f 0200 	mov.w	r2, #0
 8003cb0:	601a      	str	r2, [r3, #0]
 8003cb2:	f103 0304 	add.w	r3, r3, #4
 8003cb6:	f04f 0200 	mov.w	r2, #0
 8003cba:	601a      	str	r2, [r3, #0]
 8003cbc:	f103 0304 	add.w	r3, r3, #4
 8003cc0:	f04f 0200 	mov.w	r2, #0
 8003cc4:	601a      	str	r2, [r3, #0]
 8003cc6:	f103 0304 	add.w	r3, r3, #4
	int i;
	tmp[0] = '#';
 8003cca:	f04f 0323 	mov.w	r3, #35	; 0x23
 8003cce:	723b      	strb	r3, [r7, #8]
	for (i = 1; *name != 0; i++)
 8003cd0:	f04f 0301 	mov.w	r3, #1
 8003cd4:	62bb      	str	r3, [r7, #40]	; 0x28
 8003cd6:	e00f      	b.n	8003cf8 <sendparam+0x88>
	{
		tmp[i] = *name;
 8003cd8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003cda:	687a      	ldr	r2, [r7, #4]
 8003cdc:	7812      	ldrb	r2, [r2, #0]
 8003cde:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8003ce2:	440b      	add	r3, r1
 8003ce4:	f803 2c28 	strb.w	r2, [r3, #-40]
		name++;
 8003ce8:	687b      	ldr	r3, [r7, #4]
 8003cea:	f103 0301 	add.w	r3, r3, #1
 8003cee:	607b      	str	r3, [r7, #4]
void sendparam(char * name, int value)
{
	char tmp[32] = "";
	int i;
	tmp[0] = '#';
	for (i = 1; *name != 0; i++)
 8003cf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003cf2:	f103 0301 	add.w	r3, r3, #1
 8003cf6:	62bb      	str	r3, [r7, #40]	; 0x28
 8003cf8:	687b      	ldr	r3, [r7, #4]
 8003cfa:	781b      	ldrb	r3, [r3, #0]
 8003cfc:	2b00      	cmp	r3, #0
 8003cfe:	d1eb      	bne.n	8003cd8 <sendparam+0x68>
	{
		tmp[i] = *name;
		name++;
	}
	tmp[i] = '(';
 8003d00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003d02:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8003d06:	4413      	add	r3, r2
 8003d08:	f04f 0228 	mov.w	r2, #40	; 0x28
 8003d0c:	f803 2c28 	strb.w	r2, [r3, #-40]
#define DNUM 8
	for (int j = DNUM; j > 0; j--)
 8003d10:	f04f 0308 	mov.w	r3, #8
 8003d14:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003d16:	e034      	b.n	8003d82 <sendparam+0x112>
	{
		tmp[i + j] = value % 10 + '0';
 8003d18:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8003d1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d1c:	eb02 0003 	add.w	r0, r2, r3
 8003d20:	6839      	ldr	r1, [r7, #0]
 8003d22:	f246 6367 	movw	r3, #26215	; 0x6667
 8003d26:	f2c6 6366 	movt	r3, #26214	; 0x6666
 8003d2a:	fb83 2301 	smull	r2, r3, r3, r1
 8003d2e:	ea4f 02a3 	mov.w	r2, r3, asr #2
 8003d32:	ea4f 73e1 	mov.w	r3, r1, asr #31
 8003d36:	ebc3 0202 	rsb	r2, r3, r2
 8003d3a:	4613      	mov	r3, r2
 8003d3c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8003d40:	4413      	add	r3, r2
 8003d42:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8003d46:	ebc3 0201 	rsb	r2, r3, r1
 8003d4a:	b2d3      	uxtb	r3, r2
 8003d4c:	f103 0330 	add.w	r3, r3, #48	; 0x30
 8003d50:	b2da      	uxtb	r2, r3
 8003d52:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8003d56:	eb01 0300 	add.w	r3, r1, r0
 8003d5a:	f803 2c28 	strb.w	r2, [r3, #-40]
		value /= 10;
 8003d5e:	683a      	ldr	r2, [r7, #0]
 8003d60:	f246 6367 	movw	r3, #26215	; 0x6667
 8003d64:	f2c6 6366 	movt	r3, #26214	; 0x6666
 8003d68:	fb83 1302 	smull	r1, r3, r3, r2
 8003d6c:	ea4f 01a3 	mov.w	r1, r3, asr #2
 8003d70:	ea4f 73e2 	mov.w	r3, r2, asr #31
 8003d74:	ebc3 0301 	rsb	r3, r3, r1
 8003d78:	603b      	str	r3, [r7, #0]
		tmp[i] = *name;
		name++;
	}
	tmp[i] = '(';
#define DNUM 8
	for (int j = DNUM; j > 0; j--)
 8003d7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d7c:	f103 33ff 	add.w	r3, r3, #4294967295
 8003d80:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003d82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003d84:	2b00      	cmp	r3, #0
 8003d86:	dcc7      	bgt.n	8003d18 <sendparam+0xa8>
	{
		tmp[i + j] = value % 10 + '0';
		value /= 10;
	}
	tmp[i + DNUM + 1] = ')';
 8003d88:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003d8a:	f103 0309 	add.w	r3, r3, #9
 8003d8e:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8003d92:	4413      	add	r3, r2
 8003d94:	f04f 0229 	mov.w	r2, #41	; 0x29
 8003d98:	f803 2c28 	strb.w	r2, [r3, #-40]
	tmp[i + DNUM + 2] = ';';
 8003d9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003d9e:	f103 030a 	add.w	r3, r3, #10
 8003da2:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8003da6:	440b      	add	r3, r1
 8003da8:	f04f 023b 	mov.w	r2, #59	; 0x3b
 8003dac:	f803 2c28 	strb.w	r2, [r3, #-40]
	tmp[i + DNUM + 3] = '\n';
 8003db0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003db2:	f103 030b 	add.w	r3, r3, #11
 8003db6:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8003dba:	4413      	add	r3, r2
 8003dbc:	f04f 020a 	mov.w	r2, #10
 8003dc0:	f803 2c28 	strb.w	r2, [r3, #-40]
	tmp[i + DNUM + 4] = '\r';
 8003dc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003dc6:	f103 030c 	add.w	r3, r3, #12
 8003dca:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8003dce:	440b      	add	r3, r1
 8003dd0:	f04f 020d 	mov.w	r2, #13
 8003dd4:	f803 2c28 	strb.w	r2, [r3, #-40]
	tmp[i + DNUM + 5] = 0;
 8003dd8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003dda:	f103 030d 	add.w	r3, r3, #13
 8003dde:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8003de2:	4413      	add	r3, r2
 8003de4:	f04f 0200 	mov.w	r2, #0
 8003de8:	f803 2c28 	strb.w	r2, [r3, #-40]

	sendstr(tmp);
 8003dec:	f107 0308 	add.w	r3, r7, #8
 8003df0:	4618      	mov	r0, r3
 8003df2:	f643 4345 	movw	r3, #15429	; 0x3c45
 8003df6:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003dfa:	4798      	blx	r3
}
 8003dfc:	f107 0730 	add.w	r7, r7, #48	; 0x30
 8003e00:	46bd      	mov	sp, r7
 8003e02:	bd80      	pop	{r7, pc}

08003e04 <vRs485Task>:

void vRs485Task(void *pvParameters)
{
 8003e04:	b580      	push	{r7, lr}
 8003e06:	b086      	sub	sp, #24
 8003e08:	af00      	add	r7, sp, #0
 8003e0a:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_InitStructure;
	/* The parameters are not used. */
	(void) pvParameters;

	//	/* Configure USART1 RTS (PA.09) as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 8003e0c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003e10:	82bb      	strh	r3, [r7, #20]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8003e12:	f04f 0303 	mov.w	r3, #3
 8003e16:	75bb      	strb	r3, [r7, #22]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8003e18:	f04f 0310 	mov.w	r3, #16
 8003e1c:	75fb      	strb	r3, [r7, #23]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8003e1e:	f107 0314 	add.w	r3, r7, #20
 8003e22:	f640 0000 	movw	r0, #2048	; 0x800
 8003e26:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003e2a:	4619      	mov	r1, r3
 8003e2c:	f641 2371 	movw	r3, #6769	; 0x1a71
 8003e30:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003e34:	4798      	blx	r3
	GPIO_SetBits(GPIOA, GPIO_Pin_8); // allways transive
 8003e36:	f640 0000 	movw	r0, #2048	; 0x800
 8003e3a:	f2c4 0001 	movt	r0, #16385	; 0x4001
 8003e3e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8003e42:	f641 4331 	movw	r3, #7217	; 0x1c31
 8003e46:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003e4a:	4798      	blx	r3

	ADC_Start();
 8003e4c:	f243 138d 	movw	r3, #12685	; 0x318d
 8003e50:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003e54:	4798      	blx	r3
	pwmcInit();
 8003e56:	f243 734d 	movw	r3, #14157	; 0x374d
 8003e5a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003e5e:	4798      	blx	r3
	T1 = 0;
 8003e60:	f644 339c 	movw	r3, #19356	; 0x4b9c
 8003e64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e68:	f04f 0200 	mov.w	r2, #0
 8003e6c:	601a      	str	r2, [r3, #0]
	T2 = 0;
 8003e6e:	f644 3394 	movw	r3, #19348	; 0x4b94
 8003e72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003e76:	f04f 0200 	mov.w	r2, #0
 8003e7a:	601a      	str	r2, [r3, #0]
	uart1Init(115200);
 8003e7c:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 8003e80:	f243 33a1 	movw	r3, #13217	; 0x33a1
 8003e84:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003e88:	4798      	blx	r3
	while (1)
	{

		int32_t adcData[CHANELS_AMOUNT];
		T1 = pwmcGet(0);
 8003e8a:	f04f 0000 	mov.w	r0, #0
 8003e8e:	f643 2385 	movw	r3, #14981	; 0x3a85
 8003e92:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003e96:	4798      	blx	r3
 8003e98:	4602      	mov	r2, r0
 8003e9a:	f644 339c 	movw	r3, #19356	; 0x4b9c
 8003e9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ea2:	601a      	str	r2, [r3, #0]
		T2 = pwmcGet(1);
 8003ea4:	f04f 0001 	mov.w	r0, #1
 8003ea8:	f643 2385 	movw	r3, #14981	; 0x3a85
 8003eac:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003eb0:	4798      	blx	r3
 8003eb2:	4602      	mov	r2, r0
 8003eb4:	f644 3394 	movw	r3, #19348	; 0x4b94
 8003eb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ebc:	601a      	str	r2, [r3, #0]

		if (T1 == oldT1)
 8003ebe:	f644 339c 	movw	r3, #19356	; 0x4b9c
 8003ec2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ec6:	681a      	ldr	r2, [r3, #0]
 8003ec8:	f644 33a0 	movw	r3, #19360	; 0x4ba0
 8003ecc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ed0:	681b      	ldr	r3, [r3, #0]
 8003ed2:	429a      	cmp	r2, r3
 8003ed4:	d113      	bne.n	8003efe <vRs485Task+0xfa>
		{
			if (cntT1 > 0)
 8003ed6:	f644 3398 	movw	r3, #19352	; 0x4b98
 8003eda:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ede:	681b      	ldr	r3, [r3, #0]
 8003ee0:	2b00      	cmp	r3, #0
 8003ee2:	d014      	beq.n	8003f0e <vRs485Task+0x10a>
				cntT1--;
 8003ee4:	f644 3398 	movw	r3, #19352	; 0x4b98
 8003ee8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003eec:	681b      	ldr	r3, [r3, #0]
 8003eee:	f103 32ff 	add.w	r2, r3, #4294967295
 8003ef2:	f644 3398 	movw	r3, #19352	; 0x4b98
 8003ef6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003efa:	601a      	str	r2, [r3, #0]
 8003efc:	e008      	b.n	8003f10 <vRs485Task+0x10c>
		}
		else
		{
			cntT1 = 8*5; // .4m/s
 8003efe:	f644 3398 	movw	r3, #19352	; 0x4b98
 8003f02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f06:	f04f 0228 	mov.w	r2, #40	; 0x28
 8003f0a:	601a      	str	r2, [r3, #0]
 8003f0c:	e000      	b.n	8003f10 <vRs485Task+0x10c>
		T2 = pwmcGet(1);

		if (T1 == oldT1)
		{
			if (cntT1 > 0)
				cntT1--;
 8003f0e:	bf00      	nop
		}
		else
		{
			cntT1 = 8*5; // .4m/s
		}
		if (T2 == oldT2)
 8003f10:	f644 3394 	movw	r3, #19348	; 0x4b94
 8003f14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f18:	681a      	ldr	r2, [r3, #0]
 8003f1a:	f644 33b4 	movw	r3, #19380	; 0x4bb4
 8003f1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f22:	681b      	ldr	r3, [r3, #0]
 8003f24:	429a      	cmp	r2, r3
 8003f26:	d113      	bne.n	8003f50 <vRs485Task+0x14c>
		{
			if (cntT2 > 0)
 8003f28:	f644 33b8 	movw	r3, #19384	; 0x4bb8
 8003f2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f30:	681b      	ldr	r3, [r3, #0]
 8003f32:	2b00      	cmp	r3, #0
 8003f34:	d014      	beq.n	8003f60 <vRs485Task+0x15c>
				cntT2--;
 8003f36:	f644 33b8 	movw	r3, #19384	; 0x4bb8
 8003f3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f3e:	681b      	ldr	r3, [r3, #0]
 8003f40:	f103 32ff 	add.w	r2, r3, #4294967295
 8003f44:	f644 33b8 	movw	r3, #19384	; 0x4bb8
 8003f48:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f4c:	601a      	str	r2, [r3, #0]
 8003f4e:	e008      	b.n	8003f62 <vRs485Task+0x15e>
		}
		else
		{
			cntT2 = 100; // 20s <3RPM
 8003f50:	f644 33b8 	movw	r3, #19384	; 0x4bb8
 8003f54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f58:	f04f 0264 	mov.w	r2, #100	; 0x64
 8003f5c:	601a      	str	r2, [r3, #0]
 8003f5e:	e000      	b.n	8003f62 <vRs485Task+0x15e>
			cntT1 = 8*5; // .4m/s
		}
		if (T2 == oldT2)
		{
			if (cntT2 > 0)
				cntT2--;
 8003f60:	bf00      	nop
		else
		{
			cntT2 = 100; // 20s <3RPM
		}

		if (cntT1 == 0)
 8003f62:	f644 3398 	movw	r3, #19352	; 0x4b98
 8003f66:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f6a:	681b      	ldr	r3, [r3, #0]
 8003f6c:	2b00      	cmp	r3, #0
 8003f6e:	d10b      	bne.n	8003f88 <vRs485Task+0x184>
		{
			sendparam("T1", 0);
 8003f70:	f244 0090 	movw	r0, #16528	; 0x4090
 8003f74:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003f78:	f04f 0100 	mov.w	r1, #0
 8003f7c:	f643 4371 	movw	r3, #15473	; 0x3c71
 8003f80:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003f84:	4798      	blx	r3
 8003f86:	e00e      	b.n	8003fa6 <vRs485Task+0x1a2>
		}
		else
		{
			sendparam("T1", T1);
 8003f88:	f644 339c 	movw	r3, #19356	; 0x4b9c
 8003f8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f90:	681b      	ldr	r3, [r3, #0]
 8003f92:	f244 0090 	movw	r0, #16528	; 0x4090
 8003f96:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003f9a:	4619      	mov	r1, r3
 8003f9c:	f643 4371 	movw	r3, #15473	; 0x3c71
 8003fa0:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003fa4:	4798      	blx	r3
		}
		if (cntT2 == 0)
 8003fa6:	f644 33b8 	movw	r3, #19384	; 0x4bb8
 8003faa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fae:	681b      	ldr	r3, [r3, #0]
 8003fb0:	2b00      	cmp	r3, #0
 8003fb2:	d10b      	bne.n	8003fcc <vRs485Task+0x1c8>
		{
			sendparam("T2", 0);
 8003fb4:	f244 0094 	movw	r0, #16532	; 0x4094
 8003fb8:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003fbc:	f04f 0100 	mov.w	r1, #0
 8003fc0:	f643 4371 	movw	r3, #15473	; 0x3c71
 8003fc4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003fc8:	4798      	blx	r3
 8003fca:	e00e      	b.n	8003fea <vRs485Task+0x1e6>
		}
		else
		{
			sendparam("T2", T2);
 8003fcc:	f644 3394 	movw	r3, #19348	; 0x4b94
 8003fd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fd4:	681b      	ldr	r3, [r3, #0]
 8003fd6:	f244 0094 	movw	r0, #16532	; 0x4094
 8003fda:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003fde:	4619      	mov	r1, r3
 8003fe0:	f643 4371 	movw	r3, #15473	; 0x3c71
 8003fe4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003fe8:	4798      	blx	r3
		}
		oldT1 = T1;
 8003fea:	f644 339c 	movw	r3, #19356	; 0x4b9c
 8003fee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ff2:	681a      	ldr	r2, [r3, #0]
 8003ff4:	f644 33a0 	movw	r3, #19360	; 0x4ba0
 8003ff8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ffc:	601a      	str	r2, [r3, #0]
		oldT2 = T2;
 8003ffe:	f644 3394 	movw	r3, #19348	; 0x4b94
 8004002:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004006:	681a      	ldr	r2, [r3, #0]
 8004008:	f644 33b4 	movw	r3, #19380	; 0x4bb4
 800400c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004010:	601a      	str	r2, [r3, #0]

		GetADC(adcData);
 8004012:	f107 0308 	add.w	r3, r7, #8
 8004016:	4618      	mov	r0, r3
 8004018:	f642 6339 	movw	r3, #11833	; 0x2e39
 800401c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004020:	4798      	blx	r3
		sendparam("A1", adcData[0]);
 8004022:	68bb      	ldr	r3, [r7, #8]
 8004024:	f244 0098 	movw	r0, #16536	; 0x4098
 8004028:	f6c0 0000 	movt	r0, #2048	; 0x800
 800402c:	4619      	mov	r1, r3
 800402e:	f643 4371 	movw	r3, #15473	; 0x3c71
 8004032:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004036:	4798      	blx	r3
		sendparam("A2", adcData[1]);
 8004038:	68fb      	ldr	r3, [r7, #12]
 800403a:	f244 009c 	movw	r0, #16540	; 0x409c
 800403e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004042:	4619      	mov	r1, r3
 8004044:	f643 4371 	movw	r3, #15473	; 0x3c71
 8004048:	f6c0 0300 	movt	r3, #2048	; 0x800
 800404c:	4798      	blx	r3
		sendparam("A3", adcData[2]);
 800404e:	693b      	ldr	r3, [r7, #16]
 8004050:	f244 00a0 	movw	r0, #16544	; 0x40a0
 8004054:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004058:	4619      	mov	r1, r3
 800405a:	f643 4371 	movw	r3, #15473	; 0x3c71
 800405e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004062:	4798      	blx	r3
		vTaskDelay(200);
 8004064:	f04f 00c8 	mov.w	r0, #200	; 0xc8
 8004068:	f240 5369 	movw	r3, #1385	; 0x569
 800406c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004070:	4798      	blx	r3

	}
 8004072:	e70a      	b.n	8003e8a <vRs485Task+0x86>
 8004074:	454c4449 	.word	0x454c4449
 8004078:	00000000 	.word	0x00000000

0800407c <heapSTRUCT_SIZE>:
 800407c:	00000010 69676f4c 00006163 38345352     ....Logica..RS48
 800408c:	00000035 00003154 00003254 00003141     5...T1..T2..A1..
 800409c:	00003241 00003341                       A2..A3..
